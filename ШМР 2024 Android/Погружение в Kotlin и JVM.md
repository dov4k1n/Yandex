# `Kotlin`
* Мультипарадигменный
* Статически типизированный
* Кроссплатформенный
* Общего назначения

Был разработан как лучшая версия и замена `Java`, для комплияции `bytecode` и для исполнения на `виртуальных машинах`

Но со временем это изменилось и котлин теперь компилируется не только в байткод, но и, например, в `Javascript` для web-разработки, нативный код

Байткод попадает в `VM`, чаще всего в `JVM`, и он уже запускается на различных настоящих машинах (на телефонах, компьютерах, ноутбках), а точнее на разных операционных системах

# Содержание
Ответим на такие вопросы:
* Как собирается приложение?
* Как исполняется приложение?
* Какие возможности доступны в языке и... почему?

Порядок лекции:
1. `Сборка приложения` (как мы его собираем, где исполняем, кто его собирает)
2. `Виртуальные машины`
3. `Компилятор и плагины`
4. `Kotlin Features` (Зная всю информацию выше, посмотрим на фичи языка котлин. Так будет понятнее, зачем они нужны и где действительно помогают)

## `1` Сборка Android приложения
![alt text](image.png)
1. Есть исходники формата `.kt` и `.java`
2. Из них можем получить байткод формата `.class`
3. Можем добавить различные библиотеки `.jar`
4. Получаем `.dex` файл
5. К нему можем добавить `resources`
6. И всё это упаковывается в `.apk` файл (на самом деле это просто zip-архив. Можно переименовать, разархивировать и посмотреть из чего он состоит)

Всё, что присходит на этапе 1-5 называется `Compile Time`

У Android-разработчика есть 3 времени:
1. `Design Time` – придумывание и написание кода
2. `Compile Time` – код собирается и исполняется различными компиляторами
3. `Run Time` – всё, что происходит при запуске приложения после его сборки

### `1.1` На этапе сборки работают компиляторы

1. В первую очередь это `Kotlin Compiler`

   .kt и .java `–>` .class

2. За ним идут ещё два компилятора `dexer` и `shrinker`
   
   .jar и .class `–>` .dex
   
   `dexer d8` – компилятор java-байткода в dex-байткод – формат, в котором умеет исполняться байткод на виртуальных машинах андроида (vm android разные бывают). Главная фишка дексера – дешугаринг. Это такой процесс, когда различные новые фишки языка могут быть скомпилированы с обратной совместимостью с более старыми виртуальными машинами

   `shrinker r8` – компилятор-оптимизатор
   * Удаляет неиспользуемое: код, ресурсы, строки. Это уменьшает размер приложения и ускоряет его работу
   * Оптимизирует код – какие-то участки кода можно писать не самым эффективным способом, а шринкер знает, как  его сделать более эффективным для исполнения на какой-то машине
   * Запутывает код (obfuscation) – приложения можно декомпилировать и достать исходный код. Чтобы ваш код не утекал так легко, его запутывают
3. Далее происходит просто упаковка в .apk

Жизнь приложения на этом только начинается, наступает дистрибуция – его выгружают в `Store`

Опубликованное приложение устанавливается на телефоны

### `1.2` Установка и запуск
При установке происходит ещё одна компиляция – `AOT compilation` (Ahead of Time compilation)

Виртуальные машины работают с `JIT compilation` (Just in Time compilation), а в андроиде начиная с 5-й версии происходит AOT компиляция

Далее приложение запускается – начинается runtime, и в нём работает JIT компиляция

То есть код на этапе сборки уже компилировался тремя компиляторами, а потом он ещё будет продолжать компилироваться всю жизнь, установленную на телефон

Такие этапы:
1. AOT compilation
2. installation
3. Runtime
4. JIT compilation

Ими занимается виртуальная машина, на которой запускается приложение

## `2` Виртуальные машины 

### `2.1` JVM – Java Virtual Machine

Всё запускается на виртуальных машинах. Самая известная – java virtual machine, на её основе строится android virtual machine (с dex-байткодом вместо java-байткода)

Если знать, как устроена JVM, легко узнать и как устроены андроидные машины

### `2.1` Какая идея стояла за виртуальной машиной
![alt text](image-1.png)
Есть исходники, например, на плюсах. Существует много разных компиляторов, которые преобразуют код в машинный код или в код для ОС. Затем он запускается на разных девайсах с разной архитектурой

Но нам как разработчикам не хочется думать, кто и где какую версию запускает

Хочется один раз скомпилировать, отдать и чтоб оно работало

Идея java машины в этом и состоит:
1. Компилируем байткод, получаем .class файлы
2. Отдаём их в виртуальную машину
3. А виртульная машина уже установлена на различных устройствах. И если она там есть, там наш код можно исполнить

То есть идея «что-то сделай один раз и исполняй везде»

### `2.3` Dalvik VM (Andriod 4.4-)
В андроиде не java-байткод, а dex-байткод, и не java virtual machine, а какая-то другая виртуальная машина, которая умеет исполнять .dex файлы

Раньше ей был Dalvik, а потом ART (Android runtime)

![alt text](image-2.png)
Нескомпилированный dex-code занимает мало места, но при запуске приложения весь код нужно постоянно компилировать – это требует ресурсы железа и быстрее сажает батарейку

### `2.4` ART (Android 5.0)
![alt text](image-3.png)
Много кода приложения компилируется заранее во время установки, поэтому приложение работает быстрее и тратит меньше ресурсов

### `2.5` ART (Android 7.0)
![alt text](image-4.png)
Вернули JIT компиляцию, т.к. скомпилировать всё заранее невозможно – стандартная библиотека джавы предоставляется виртуальной машиной, её нельзя скомпилировать заранее

Там есть такие штуки как рефлексия, аннотации, класс лоудеры. Они препятствуют тому, чтобы можно было вычислить, как код ведёт себя в runtime, поэтому приходится его компилировать кусочками в процессе

### `2.6` ART (Android 9.0)
![alt text](image-5.png)
В девятом андроиде пошли дальше

Если есть миллион устройств, которые уже компилируют одно и то же приложение под свои процессоры, можно попытаться поделиться этой информацией между устройствами

`Google Play` как маркет этим занимается. Мы можем ему предоставить некоторый baseline profile (файл, в котором описано, как лучше компилировать наши файлы), с ним AOT compiler знает лучше, как обрабатывать наш код, а дальше приложение на устройстве выполняет JIT компиляцию, собирает информацию во время работы и делится ею с Google Play. Тогда при установке можно отправить ещё один профайл – cloud profile, и девайс получит опыт миллионов других устройств, чтобы запустить приложение, и оно будет работать ещё быстрее

До таких идей доходят в процессе оптимизации работы андроида, поэтому приложения становятся всё быстрее и быстрее в новых версиях

### `2.7` Цикл работы Android Runtime
![alt text](image-6.png)

### `2.8` Виртуальная машина
это система, которая эмулирует аппаратное обеспечение компьютера и исполняет программы. То есть машина внутри другой машины

