# `Kotlin`
* Мультипарадигменный
* Статически типизированный
* Кроссплатформенный
* Общего назначения

Был разработан как лучшая версия и замена `Java`, для комплияции `bytecode` и для исполнения на `виртуальных машинах`

Но со временем это изменилось и котлин теперь компилируется не только в байткод, но и, например, в `Javascript` для web-разработки, нативный код

Байткод попадает в `VM`, чаще всего в `JVM`, и он уже запускается на различных настоящих машинах (на телефонах, компьютерах, ноутбках), а точнее на разных операционных системах

# Содержание
Ответим на такие вопросы:
* Как собирается приложение?
* Как исполняется приложение?
* Какие возможности доступны в языке и... почему?

Порядок лекции:
1. [`Сборка приложения`](#1-сборка-android-приложения) (как мы его собираем, где исполняем, кто его собирает)
2. [`Виртуальные машины`](#2-виртуальные-машины)
    
    2.1 [JVM – Java Virtual Machine](#21-jvm--java-virtual-machine)
    
    2.2 [Какая идея стояла за виртуальной машиной](#22-какая-идея-стояла-за-виртуальной-машиной)
    
    2.3 [Dalvik VM (Android 4.4-)](#23-dalvik-vm-andriod-44-)
    
    2.4 [ART (Android 5.0)](#24-art-android-50)
   
    2.5 [ART (Android 7.0)](#25-art-android-70)
   
    2.6 [ART (Android 9.0)](#26-art-android-90)
    
    2.7 [Цикл работы Android Runtime](#27-цикл-работы-android-runtime)
   
    2.8 [Виртуальная машина](#28-виртуальная-машина)
    
    2.9 [Android OS](#29-android-os)
   
    2.10 [App Process подробнее: Java Memory Model](#210-app-process-подробнее-java-memory-model)

3.  [`Компилятор и плагины`](#3-kotlin-compiler)
4.  [`Kotlin Features`](#4-kotlin-features) (Зная всю информацию выше, посмотрим на фичи языка котлин. Так будет понятнее, зачем они нужны и где действительно помогают)

## `1` Сборка Android приложения
![alt text](image.png)
1. Есть исходники формата `.kt` и `.java`
2. Из них можем получить байткод формата `.class`
3. Можем добавить различные библиотеки `.jar`
4. Получаем `.dex` файл
5. К нему можем добавить `resources`
6. И всё это упаковывается в `.apk` файл (на самом деле это просто zip-архив. Можно переименовать, разархивировать и посмотреть из чего он состоит)

Всё, что присходит на этапе 1-5 называется `Compile Time`

У Android-разработчика есть 3 времени:
1. `Design Time` – придумывание и написание кода
2. `Compile Time` – код собирается и исполняется различными компиляторами
3. `Run Time` – всё, что происходит при запуске приложения после его сборки

### `1.1` На этапе сборки работают компиляторы

1. В первую очередь это `Kotlin Compiler`

   .kt и .java `–>` .class

2. За ним идут ещё два компилятора `dexer` и `shrinker`
   
   .jar и .class `–>` .dex
   
   `dexer d8` – компилятор java-байткода в dex-байткод – формат, в котором умеет исполняться байткод на виртуальных машинах андроида (vm android разные бывают). Главная фишка дексера – дешугаринг. Это такой процесс, когда различные новые фишки языка могут быть скомпилированы с обратной совместимостью с более старыми виртуальными машинами

   `shrinker r8` – компилятор-оптимизатор
   * Удаляет неиспользуемое: код, ресурсы, строки. Это уменьшает размер приложения и ускоряет его работу
   * Оптимизирует код – какие-то участки кода можно писать не самым эффективным способом, а шринкер знает, как  его сделать более эффективным для исполнения на какой-то машине
   * Запутывает код (obfuscation) – приложения можно декомпилировать и достать исходный код. Чтобы ваш код не утекал так легко, его запутывают
3. Далее происходит просто упаковка в .apk

Жизнь приложения на этом только начинается, наступает дистрибуция – его выгружают в `Store`

Опубликованное приложение устанавливается на телефоны

### `1.2` Установка и запуск
При установке происходит ещё одна компиляция – `AOT compilation` (Ahead of Time compilation)

Виртуальные машины работают с `JIT compilation` (Just in Time compilation), а в андроиде начиная с 5-й версии происходит AOT компиляция

Далее приложение запускается – начинается runtime, и в нём работает JIT компиляция

То есть код на этапе сборки уже компилировался тремя компиляторами, а потом он ещё будет продолжать компилироваться всю жизнь, установленную на телефон

Такие этапы:
1. AOT compilation
2. installation
3. Runtime
4. JIT compilation

Ими занимается виртуальная машина, на которой запускается приложение

## `2` Виртуальные машины 

### `2.1` JVM – Java Virtual Machine

Всё запускается на виртуальных машинах. Самая известная – java virtual machine, на её основе строится android virtual machine (с dex-байткодом вместо java-байткода)

Если знать, как устроена JVM, легко узнать и как устроены андроидные машины

### `2.2` Какая идея стояла за виртуальной машиной
![alt text](image-1.png)
Есть исходники, например, на плюсах. Существует много разных компиляторов, которые преобразуют код в машинный код или в код для ОС. Затем он запускается на разных девайсах с разной архитектурой

Но нам как разработчикам не хочется думать, кто и где какую версию запускает

Хочется один раз скомпилировать, отдать и чтоб оно работало

Идея java машины в этом и состоит:
1. Компилируем байткод, получаем .class файлы
2. Отдаём их в виртуальную машину
3. А виртульная машина уже установлена на различных устройствах. И если она там есть, там наш код можно исполнить

То есть идея «что-то сделай один раз и исполняй везде»

### `2.3` Dalvik VM (Andriod 4.4-)
В андроиде не java-байткод, а dex-байткод, и не java virtual machine, а какая-то другая виртуальная машина, которая умеет исполнять .dex файлы

Раньше ей был Dalvik, а потом ART (Android runtime)

![alt text](image-2.png)
Нескомпилированный dex-code занимает мало места, но при запуске приложения весь код нужно постоянно компилировать – это требует ресурсы железа и быстрее сажает батарейку

### `2.4` ART (Android 5.0)
![alt text](image-3.png)
Много кода приложения компилируется заранее во время установки, поэтому приложение работает быстрее и тратит меньше ресурсов

### `2.5` ART (Android 7.0)
![alt text](image-4.png)
Вернули JIT компиляцию, т.к. скомпилировать всё заранее невозможно – стандартная библиотека джавы предоставляется виртуальной машиной, её нельзя скомпилировать заранее

Там есть такие штуки как рефлексия, аннотации, класс лоудеры. Они препятствуют тому, чтобы можно было вычислить, как код ведёт себя в runtime, поэтому приходится его компилировать кусочками в процессе

### `2.6` ART (Android 9.0)
![alt text](image-5.png)
В девятом андроиде пошли дальше

Если есть миллион устройств, которые уже компилируют одно и то же приложение под свои процессоры, можно попытаться поделиться этой информацией между устройствами

`Google Play` как маркет этим занимается. Мы можем ему предоставить некоторый baseline profile (файл, в котором описано, как лучше компилировать наши файлы), с ним AOT compiler знает лучше, как обрабатывать наш код, а дальше приложение на устройстве выполняет JIT компиляцию, собирает информацию во время работы и делится ею с Google Play. Тогда при установке можно отправить ещё один профайл – cloud profile, и девайс получит опыт миллионов других устройств, чтобы запустить приложение, и оно будет работать ещё быстрее

До таких идей доходят в процессе оптимизации работы андроида, поэтому приложения становятся всё быстрее и быстрее в новых версиях

### `2.7` Цикл работы Android Runtime
![alt text](image-6.png)

### `2.8` Виртуальная машина
это система, которая эмулирует аппаратное обеспечение компьютера и исполняет программы. То есть машина внутри другой машины

Бывают разных видов: `системные` и `процессные`

![alt text](image-7.png)

**Системные виртуальные** машины устанавливаются на сервера, часто используются в больших датацентрах

Как эти сервера устроены:
* Есть мощная машина с кучей железа
* На ней запускается симулятор (так часто называют виртуальную машину для серверов)
* На симуляторе устанавливают ОС
* В этой ОС крутятся приложения

И так одну физическую машину можно разграничить на какие-то зоны и получить набор из виртуальных машин, поделив ресурсы физической машины

В андроиде используются **процессные виртуальные машины**. Они устроены чуть иначе:
* Операционная система работает с железом напрямую
* Есть даже какие-то низкоуровневые приложения, которые работают с этой операционной системой (у обычного пользователя нет к ним доступа)
* Рядом устанавливается экземпляр виртуальной машины, внутри которого запускается приложение. Их может создаваться несколько: когда в телефоне запускается 5 приложений, для каждого из них создаётся свой экземпляр виртуальной машины

Документация гугла:

![alt text](image-8.png)

### `2.9` Android OS
Как этой всё запускается?

![alt text](image-9.png)

1. Пользователь запускает что-то в телефоне, происходит событие на запуск приложения
2. Система ловит это событие. Есть специально заготовленный класс `Zygote` (биологический термин). Зиготы делятся – порождается процесс `process.fork()`
3. Отдельный процесс инициализируется:
   
   * Запускается виртуальная машина (`ART VM`)
   * Устанавливается особый обработчик исключений (`ExceptionHandler`), чтобы если ваш процесс испортился, он не повлиял на всю систему
   * Запускается главный поток (`Main Thread`)
   * Происходит связывание сервисов(`Bind Services`) между процессами: в системе работают какие-то сервисы, дающие доступ к драйверам, камере, физическим носителям, к Acitivity-manager и т.д. Обращение к таким штукам не быстрые, часто приводят к зависаниям
4. Когда процесс готов, на нём создаётся единственный класс `Application`
5. В этом Application запускается `Acivity`, `Service`, всё, что указано в манифесте
6. Пользователь это видит и доволен

### `2.10` App Process подробнее: Java Memory Model
он устроен так же, как и JVM. А точнее, он даёт доступ к памяти, а эта память устроена в ART точно так же, как и в JVM. Это называется `Java Memory Model`

![alt text](image-10.png)

* В этой модели есть главный поток и какие-то другие потоки (которые мы создаём для асинхронной работы)
* В потоках мы вызываем методы, выделяем память под переменные и т.д.
* Примерно так строится единый стек вызовов в потоке (`Thread Stack`)
* Отдельная область памяти называется куча (`Heap`). В ней находятся сами объекты, а в стеке только ссылки на них (`references`). Эти ссылки могут идти на общие объекты, могут на разные. Здесь начинается тема следующей лекции про многопоточность

На самом деле всё знание про Java Memory Model про то, как же нам синхронизировать работу этих потоков. Но в этой лекции будем не об этом, а посмотрим повнимательнее, как устроена эта память

#### Какие ошибки могут случиться в стеке:
* `MethodNotFoundException` – метод может быть не найден, потому что почему-то он куда-то не загрузился
* `OutOfMemoryException` – может не хватить памяти, когда мы выделяем место под очередную переменную. Например, когда загружаем большую картинку
* `NullPointerException` – когда наша ссылка больше никуда не указывает
* `StackOverflowException` – выход за границу стека
* `NoClassDefFoundException` – класс не найден при выделении памяти

У стека есть единственное свойство – его размер. Мы можем его задать, если сами запускаем виртуальную машину, при помощи флага `-Xss1024k`

В старых андроидах размер стека был очень маленький:
* API 3 ([Android 1.5](https://android.googlesource.com/platform/dalvik.git/+/4da052510571aea4711d04de25a24b58cab1dadc%5E1..4da052510571aea4711d04de25a24b58cab1dadc/)) = 8 KB
* API 4-10 ([Android 1.6](https://android.googlesource.com/platform/dalvik/+/android-1.6_r1/vm/Thread.h) - [Android 2.3.7](https://android.googlesource.com/platform/dalvik/+/android-2.3.7_r1/vm/Thread.h)) = 12 KB
* API 14-17 ([Android 4.0](https://android.googlesource.com/platform/dalvik/+/android-cts-4.0_r1/vm/Thread.h) - [Android 4.2.2](https://android.googlesource.com/platform/dalvik/+/android-4.2.2_r1.1/vm/Thread.h)) = 16 KB
* Сейчас = 8 MB (не точно, так как размер стека определяют производители андроид устройства)

Размером стека мы не управляем, поэтому нужно аккуратно писать код, быть аккуратными с рекурсиями, использовать хвостовую рекурсию (которая компилируется и разворачивается), внерекурсивные вызовы. Потому что, если что, изменить мы это не сможем – устройства, на которых запускается приложение, у нас не под контролем, в отличии, например от бекенд-разработки, где, если что-то не так, можно поднять размер стека

#### Теперь про кучу – место, где живут сами объекты

Строго говоря, память это не только куча, но и ещё одно пространство – раньше оно называлось `PermGen` (Permanent Generation), сейчас называется `MetaSpace` начиная с восьмой версии Java. В них хранится немного разная информация

Куча это не один сплошной кусок памяти, он делится на поколения: есть молодые и старые

![alt text](image-11.png)

Эти поколения наблюдаются специальной штукой, которая называется `Garbage Collector` (GC). Он их мониторит, удаляет оттуда объекты или перемещает

И даже молодые поколения состоят из нескольких этапов:
* Поколение `Eden` – самое молодое, куда попадает только что созданный объект
* Поколение `S0`
* Поколение `S1`

Они нужны, чтобы GC работал чуть оптимальнее – если бы он запускался на весь Heap, пришлось бы остановить работу приложения, чтобы проанализировать то, что там находится

Мы памятью напрямую не управляем, за нас это делает виртуальная машина при помощи GC

В молодых поколениях объекты нужно собирать чаще, а если объект уже пережил 10-20 сборок, то, наверное, он будет жить и дальше, и такие объекты можно смотреть чуть-чуть реже

Существуют разные GC: какие-то работают параллельно, какие-то останавливают все потоки и идут определять достижимость объектов из памяти. Возможности выбирать GC у нас тоже нет – он зашит на девайсе. Как правило, сейчас работают параллельные, которые работают в фоне

В отличие от Heap, которая является памятью внутри виртуальной машины, MetaSpace – это нативная память (динамическая), она доступна железу напрямую. Там хранятся самые важные вещи для работы приложения, которые почти никогда не должны выгружаться

Например, там хранятся `Class Metadata` – таблицы, где записано, какие методы к каким классам относятся, как они устроены, что позволяет стеку правильно работать. Так же туда предоставляется доступы к классам, которые поступают извне. Например, стандартная библотека Java

В Java и Kotlin есть класслоудеры, которые позволяют что-то добавить или убрать из MetaSpace

В старых версиях (PermGen) эта область была фиксированного размера и это приводило к OutOfMemoryException. MetaSpace динамическая, она расширяется

До Java 8 здесь ещё находился `String Pool`, сейчас он и другие пулы наодятся в Heap

#### Пулы (`Pools`) – это некоторые области, где хранятся переиспользуемые объекты. Бывают разные: String Pool, Int Pool, Char Pool, Byte Pool, Short Pool

В пуле могут находиться одинаковые по содержанию, но разные по ссылке объекты, если использовать какие-то сложные методы создания объектов:

```kotlin
// String literals
"hello" == "hello"                                      // true
"hello" === "hello"                                     // true

// String builders
"hello" == StringBuiler("hello").toString()             // true
"hello" === StringBuilder("hello").toString()           // false

// Intern from Pool
"hello" === StringBuilder("hello").toString().intern()  // true
```

В котлине '==' это проверка на равенство по содержанию, а '===' по ссылке

StringBuilder генерирует строку как объект, поэтому созданные так строки по содержанию эквивалентны, а по ссылке разные

Существует метод `intern()` (интернирование), он говорит "не надо создавать новый объект, сложи его в пул, а если в пуле уже лежит этот объект, достань его оттуда". Тогда по ссылке они будут одинаковы

В Int Pool есть ограничение в 1 байт. Если все числа попадают в 1 байт, они будут браться из пула, если числа больше размером, то они будут браться откуда-то снаружи (будут создаваться новые объекты в куче)

```kotlin
val a: Int? = 127
val b: Int? = 127

a == b                  // true
a === b                 // true

val c: Int? = 128
val d: Int? = 128

c == d                  // true
c === d                 // false
```

В этом примере специально использован nullable тип, чтобы обмануть комплиятор. Примитивные типы данных хранятся напрямую в стеке и не выделяют никаких ссылок в кучу. А объектные типы с ссылкой заставляют создать объект, и тогда компилятор создаёт их

С интами идея простая: в вашем коде некоторые числа используются гораздо чаще, чем другие. И чтобы под них выделить заранее объекты и не создать десяток одинаковых существует пул

Все эти пулы нужны для оптимизации потребления памяти, скорости работы виртуальной машины

#### GC – определение мусора

Как определить, какой объект является мусором?

![alt text](image-12.png)

Для этого существует понятие `GC Roots`. Они позволяют понять, что собрать, а что удалить

GC Root – это точка старта, откуда GC будет обходить ссылки и вычислять достижимость объектов. Если объект достижим – он живой, если нет – надо его убирать. GC видит всё, он отмечает достижимые объекты, а всё остальное попадает в мусор. GC Root находится вне кучи

Здесь существует ловушка, в которую разработчики могут попасть

![alt text](image-13.png)

Например, Object 2 уже не используется, но где-то утекла ссылка. Такая утёкшая ссылка называется `утечкой памяти` (memory leak). Она транзитивно может переходить и на другие объекты и не давать очистить огромный кусок памяти. За такими вещами надо следить

![alt text](image-14.png)

В реальном примере это могли бы быть классы Application, Activity, EventListener

У нас есть Activity, у неё есть UI Element, и мы в Application устанавливаем какой-то глобальный Listener, который меняет кнопку. Если забыть убрать ссылку из Application на этот Listener, то Activity никогда не очистится

Поэтому нужно быть аккуратным, в разных LifeCycle-зависимых методах снимать ссылки симметрично и следить за утечками

Несмотря на то, что GC за нами всё чистит, наша задача – следить, чтобы никакая ссылка не утекла

## `3` Kotlin Compiler

## `4` Kotlin Features