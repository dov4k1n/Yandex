1
00:00:53,10 --> 00:00:57,330
Всем привет! Сегодня с нами студенты летней школы,

2
00:00:57,490 --> 00:01:03,970
воленослушатели и слушатели открытого лектория. И всем спасибо, что пришли. Зовут меня Василий

3
00:01:03,970 --> 00:01:10,810
Шумилов. Я архитектор в Android Яндекс Музыки. Сегодня нас ждет лекция на тему сетевого

4
00:01:10,810 --> 00:01:16,250
взаимодействия в Андроиде. Я бы даже сказал на тему эффективного сетевого взаимодействия.

5
00:01:16,250 --> 00:01:20,10
Материал я подбирал специально для текущей школы, так

6
00:01:20,10 --> 00:01:22,650
что я искренне надеюсь, что он будет вам полезен.

7
00:01:23,590 --> 00:01:27,230
Мы обсудим современные вызовы, тенденции, технологии

8
00:01:27,230 --> 00:01:32,470
и стандарты, включая самые современные штуки вроде

9
00:01:32,470 --> 00:01:35,130
HTTP3, Protobuf и gRPC.

10
00:01:35,990 --> 00:01:37,650
Не забудем, конечно, и классику.

11
00:01:39,50 --> 00:01:41,770
Длиной лекция будет до полутора часов с учетом

12
00:01:41,770 --> 00:01:42,130
пауз.

13
00:01:42,850 --> 00:01:44,790
Пауз под вопросы будет выделено две.

14
00:01:44,790 --> 00:01:48,370
Одна где-то в районе середины лекции, а вторая в конце.

15
00:01:49,50 --> 00:01:52,250
Так что не стесняйтесь задавать вопросы по ссылке

16
00:01:52,250 --> 00:01:56,210
на Аха Слайдс, и я постараюсь на все ответить, насколько

17
00:01:56,210 --> 00:01:57,330
хватит моих знаний.

18
00:01:58,590 --> 00:02:02,150
Советую запоминать номер слайда, если это возможно,

19
00:02:02,470 --> 00:02:04,870
который вызвал вопрос, так мне будет проще ответить.

20
00:02:07,500 --> 00:02:09,610
Задавать вопросы можно в любое время, но отвечать

21
00:02:09,610 --> 00:02:10,870
я буду в течение двух пауз.

22
00:02:12,10 --> 00:02:14,250
Погнали, начнем с самого главного вопроса.

23
00:02:14,250 --> 00:02:17,950
Зачем нам, мобильным разработчикам, нужно разбираться в сетевых

24
00:02:17,950 --> 00:02:18,770
взаимодействиях?

25
00:02:19,710 --> 00:02:21,370
Ответ здесь по-своему прост.

26
00:02:21,650 --> 00:02:23,930
От этого зависит качество наших приложений.

27
00:02:24,930 --> 00:02:29,230
На самом деле здесь работает общее правило, как и с любыми

28
00:02:29,230 --> 00:02:30,530
другими технологиями.

29
00:02:30,970 --> 00:02:34,550
Что-то такое базовое, среднее можно сделать без погружения

30
00:02:34,550 --> 00:02:35,10
в детали.

31
00:02:36,270 --> 00:02:39,850
Но пользователям высокое качество нравится, а низкое

32
00:02:39,850 --> 00:02:40,530
не нравится.

33
00:02:40,530 --> 00:02:45,550
Из-за долгой загрузки данных пользователи расстраиваются

34
00:02:46,70 --> 00:02:47,910
от ошибок загрузки.

35
00:02:49,30 --> 00:02:53,270
Чем выше качество, тем выше оценка в сторе и тем больше

36
00:02:53,270 --> 00:02:53,970
пользователей.

37
00:03:00,710 --> 00:03:03,930
Работа с сетевым взаимодействием на мобильных устройствах

38
00:03:03,930 --> 00:03:05,170
это непростая задача.

39
00:03:05,930 --> 00:03:08,230
Мы находимся в условиях серьезных ограничений.

40
00:03:08,230 --> 00:03:10,550
Я сначала приведу обратный пример.

41
00:03:11,250 --> 00:03:13,870
У приложений для настольных компьютеров все попроще.

42
00:03:14,370 --> 00:03:18,90
У них либо вообще нет батареи, либо она очень большая по

43
00:03:18,90 --> 00:03:19,130
сравнению с телефоном.

44
00:03:20,610 --> 00:03:24,350
У сети, к которой они подключены, задержка обычно весьма

45
00:03:24,350 --> 00:03:28,770
низкая, и пакеты в этой сети не теряются, и трафик безлимитный.

46
00:03:29,370 --> 00:03:30,870
А у нас прямо все наоборот.

47
00:03:31,350 --> 00:03:34,390
Если слишком много делаешь запроса и садишь батарею,

48
00:03:35,10 --> 00:03:36,850
задержки непредсказуемы.

49
00:03:36,850 --> 00:03:41,350
Пакет может дойти до сервера за 30 миллисекунд, может

50
00:03:41,350 --> 00:03:43,530
за 300 миллисекунд, а может за 3000 миллисекунд.

51
00:03:44,410 --> 00:03:45,90
Как повезет.

52
00:03:45,330 --> 00:03:48,110
И задержка, кстати, влияет на скорость передачи данных.

53
00:03:50,970 --> 00:03:53,470
Доступность у мобильного интернета тоже не супер.

54
00:03:54,350 --> 00:03:57,810
Пакеты сравнительно часто теряются, если вышка сотовой

55
00:03:57,810 --> 00:03:59,370
связи не в прямой видимости.

56
00:04:00,450 --> 00:04:03,770
И трафик у мобильного интернета чаще всего не безлимитный.

57
00:04:03,770 --> 00:04:08,50
В некоторых городах, странах или в роуминге трафик может

58
00:04:08,50 --> 00:04:10,270
быть очень дорогим, его надо экономить.

59
00:04:11,290 --> 00:04:14,330
Так что было бы все просто, если бы наш телефон и сервер

60
00:04:14,330 --> 00:04:18,190
были соединены проводом напрямую, но такая роскошь

61
00:04:18,190 --> 00:04:19,190
нам недоступна.

62
00:04:19,910 --> 00:04:22,910
Больно много нужно проводов, да и уже телефон на улицу

63
00:04:22,910 --> 00:04:23,290
не взять.

64
00:04:24,490 --> 00:04:27,330
Можно подойти к серверной стойке и подключиться

65
00:04:27,330 --> 00:04:32,910
по кабелю, но тогда комната, наверное, обычного любого

66
00:04:32,910 --> 00:04:35,130
пользователя интернета выглядел бы как-то так,

67
00:04:35,890 --> 00:04:39,290
и он бы подключился аж ко всем своим соседям, может

68
00:04:39,290 --> 00:04:40,730
к соседнему дому чуть-чуть.

69
00:04:41,750 --> 00:04:44,50
Поэтому мы начнем сегодня образовательную часть

70
00:04:44,50 --> 00:04:48,410
с такой фундаментальной вещи как TCP-IP и почему дома

71
00:04:48,410 --> 00:04:50,710
нам необязательно иметь комнату с проводами.

72
00:04:52,350 --> 00:04:56,470
Модель TCP-IP — это описание того, какие у сетевого взаимодействия

73
00:04:56,470 --> 00:05:00,830
есть концептуальные уровни и как протоколы каждого

74
00:05:00,830 --> 00:05:02,70
уровня должны себя вести.

75
00:05:03,130 --> 00:05:06,730
Модель помогает и производителям сетевого оборудования,

76
00:05:06,930 --> 00:05:10,490
и разработчикам программного обеспечения меньше конфликтовать

77
00:05:10,490 --> 00:05:13,250
и говорить на одном языке.

78
00:05:14,10 --> 00:05:15,990
В рамках модели у нас есть четыре уровня.

79
00:05:16,630 --> 00:05:19,570
Если мы отправим данные из нашего приложения куда-либо,

80
00:05:20,90 --> 00:05:23,350
они, скорее всего, пройдут сквозь все эти четыре уровня.

81
00:05:24,430 --> 00:05:29,310
Начнется все с уровня приложения, который обеспечивает связь

82
00:05:29,310 --> 00:05:31,870
между приложениями, прямо то, что надо.

83
00:05:33,230 --> 00:05:36,370
Например, мы отправим простой HTTP-запрос.

84
00:05:37,530 --> 00:05:38,770
Я еще расскажу про HTTP.

85
00:05:39,750 --> 00:05:42,290
На уровне приложения мы этот запрос сформируем

86
00:05:42,290 --> 00:05:46,310
и передадим ответственность за его отправку транспортному уровню.

87
00:05:47,950 --> 00:05:51,590
На транспортном уровне обеспечивается связь между хостами,

88
00:05:52,110 --> 00:05:55,650
то есть наши данные пролетят от телефона до сервера,

89
00:05:55,650 --> 00:05:59,910
может быть, аж через половину земного шара и обработаются

90
00:05:59,910 --> 00:06:03,650
кем надо, а не где-то потеряются или кем-то еще обработаются.

91
00:06:04,350 --> 00:06:07,810
Это очень сложно, но нам практически не нужно об

92
00:06:07,810 --> 00:06:09,250
этом думать, и это чудесно.

93
00:06:10,750 --> 00:06:12,650
Что тогда за интернет-уровень?

94
00:06:13,870 --> 00:06:17,470
Этот уровень обеспечивает взаимодействие между независимыми

95
00:06:17,470 --> 00:06:18,190
сетями.

96
00:06:20,50 --> 00:06:23,90
У вас дома есть локальная сеть под управлением вашего

97
00:06:23,90 --> 00:06:23,510
роутера.

98
00:06:25,10 --> 00:06:30,50
У вашего соседа дома тоже есть сеть, у вашего провайдера

99
00:06:30,50 --> 00:06:32,850
есть сеть, а в ней находитесь вы и ваш сосед.

100
00:06:34,510 --> 00:06:38,350
Данные обычно передаются из сети в сеть, и за это

101
00:06:38,350 --> 00:06:39,770
отвечает интернет-уровень.

102
00:06:41,510 --> 00:06:43,990
И последний, самый низкий уровень — это канальный.

103
00:06:44,450 --> 00:06:47,750
Он умеет передавать данные в пределах одного канала.

104
00:06:48,310 --> 00:06:50,730
Иными словами, этот уровень знает, как передать данные

105
00:06:50,730 --> 00:06:54,650
между физически соединенными устройствами по конкретному

106
00:06:54,650 --> 00:06:56,650
проводу или без провода.

107
00:06:57,530 --> 00:07:00,130
Все протоколы, о которых я буду рассказывать, можно

108
00:07:00,130 --> 00:07:02,550
отнести к одному из этих четырех уровней.

109
00:07:04,150 --> 00:07:07,70
Этот последний канальный уровень на мобильных клиентов

110
00:07:07,70 --> 00:07:08,230
очень сильно влияет.

111
00:07:10,150 --> 00:07:15,270
4G, LTE, 3G, 2G или еще что-то похуже.

112
00:07:15,950 --> 00:07:19,490
Еще существуют в мире лифты, тоннели, высокие здания,

113
00:07:19,490 --> 00:07:24,110
горы, отдаленные местности — много вещей есть, которые

114
00:07:24,110 --> 00:07:28,50
могут помешать нам обменяться данными с сервером, поэтому

115
00:07:28,50 --> 00:07:31,90
мы и будем рассматривать все, что мы будем рассматривать.

116
00:07:32,150 --> 00:07:35,810
В основе взаимодействия между узлами лежат IPv4 и

117
00:07:35,810 --> 00:07:37,290
IPv6 и порты.

118
00:07:38,250 --> 00:07:41,550
Эти протоколы обеспечивают адресацию устройств в сети.

119
00:07:42,190 --> 00:07:45,190
Каждый узел в сети имеет уникальный IP-адрес.

120
00:07:45,190 --> 00:07:50,910
IP-версии 4 используют 32-битные адреса, что позволяет адресовать

121
00:07:50,910 --> 00:07:53,870
всего лишь около четырех миллиардов устройств.

122
00:07:54,530 --> 00:07:57,530
Это много, но в масштабе планеты немного.

123
00:07:58,890 --> 00:08:02,810
Адреса в IPv4 записываются четырьмя группами по 8 бит

124
00:08:02,810 --> 00:08:03,470
через точку.

125
00:08:04,950 --> 00:08:12,10
В IPv6 адреса размером 128 бит, а значит адресовать

126
00:08:19,430 --> 00:08:26,70
Адресы имеют 8 групп по 16 бит, и группы записываются

127
00:08:26,70 --> 00:08:28,270
уже через двоеточие, а не точку.

128
00:08:29,690 --> 00:08:32,350
В стандарте записи также допустимо пропустить группу

129
00:08:32,350 --> 00:08:36,70
нулей в середине адреса, чтобы не писать эти лишние

130
00:08:36,70 --> 00:08:37,590
нули, если их там много.

131
00:08:39,50 --> 00:08:42,710
Порты же используются для идентификации конкретных

132
00:08:42,710 --> 00:08:45,430
приложений на конкретном устройстве.

133
00:08:46,190 --> 00:08:51,690
Например, HTTP обычно использует порт 80, а HTTPS — порт 443.

134
00:08:53,50 --> 00:08:56,190
За счет того, что каждый порт ассоциирован с определенным

135
00:08:56,190 --> 00:09:00,470
приложением, на одном устройстве с одним IP-адресом может

136
00:09:00,470 --> 00:09:02,450
быть запущено несколько приложений.

137
00:09:03,590 --> 00:09:12,990
Еще одна важная технология — это DNS, которая преобразует

138
00:09:12,990 --> 00:09:14,730
доменные имена в IP-адреса.

139
00:09:15,290 --> 00:09:19,610
Когда вы в браузере вводите URL, DNS преобразует этот

140
00:09:19,610 --> 00:09:23,930
URL в IP-адрес соответствующего сервера, и в нашем коде

141
00:09:23,930 --> 00:09:26,710
на андроиде будет происходить ровно то же самое.

142
00:09:27,830 --> 00:09:30,910
Доменные имена, например, Яндекс.Музыки преобразуются

143
00:09:33,410 --> 00:09:37,150
ДНС работает как телефонная книга для интернета, позволяя

144
00:09:37,150 --> 00:09:40,950
пользователям обычным обращаться к веб-сайтам

145
00:09:40,950 --> 00:09:46,470
по их именам, а не по числовым IP-адресам, которые невозможно

146
00:09:46,470 --> 00:09:47,30
запомнить.

147
00:09:53,330 --> 00:09:57,590
Транспортный протокол TCP — это база на текущий

148
00:09:57,590 --> 00:09:58,230
момент времени.

149
00:09:58,230 --> 00:10:01,970
Он надежный, он устанавливает соединение между хостами

150
00:10:01,970 --> 00:10:03,210
перед передачей данных.

151
00:10:04,830 --> 00:10:08,450
TCP разбивает сначала данные на пакеты, нумерует их и

152
00:10:08,450 --> 00:10:09,90
отправляет.

153
00:10:09,590 --> 00:10:12,990
Получатель подтверждает получение каждого такого

154
00:10:12,990 --> 00:10:13,470
пакета.

155
00:10:13,890 --> 00:10:18,230
Если пакет потерян, то отправитель повторяет его отправку.

156
00:10:19,770 --> 00:10:23,510
За счет этого TCP обеспечивает надежную и последовательную

157
00:10:23,510 --> 00:10:26,850
доставку данных, но ценой увеличенных накладных

158
00:10:26,850 --> 00:10:27,330
расходов.

159
00:10:28,190 --> 00:10:33,910
С UDP все проще по-своему, про него говорят, что выстрелил

160
00:10:33,910 --> 00:10:34,490
и забыл.

161
00:10:35,730 --> 00:10:38,890
Нет лишних задержек, но нет и никаких гарантий.

162
00:10:40,350 --> 00:10:45,670
В играх его встретить можно повсеместно, а вот в прикладных

163
00:10:45,670 --> 00:10:47,930
приложениях в чистом виде он используется редко.

164
00:10:49,630 --> 00:10:53,130
В рамках TCP есть процесс под названием рукопожатие.

165
00:10:53,130 --> 00:10:57,890
Оно занимает больше времени, чем сам запрос.

166
00:10:58,990 --> 00:11:01,510
Бывают исключения, но в целом так, если запросы

167
00:11:01,510 --> 00:11:02,50
небольшие.

168
00:11:02,750 --> 00:11:05,370
Так что правильная работа с рукопожатием может ускорить

169
00:11:05,370 --> 00:11:08,870
ваши запросы в два раза или замедлить, если неправильно.

170
00:11:09,670 --> 00:11:12,410
Без погружения в детали рукопожатие позволяет

171
00:11:12,410 --> 00:11:16,850
установить TCP-соединение, договориться клиенту и

172
00:11:16,850 --> 00:11:20,470
серверу, что все окей, и после чего уже можно посылать

173
00:11:20,470 --> 00:11:20,810
данные.

174
00:11:21,950 --> 00:11:25,70
Рукопожатие в чистом виде происходит за три посылки,

175
00:11:25,370 --> 00:11:27,670
но стандарт разрешает вместе с третьей посылкой

176
00:11:27,670 --> 00:11:31,430
положить сразу и данные, так что на деле рукопожатие

177
00:11:32,130 --> 00:11:35,350
будет занимать скорее две посылки, чем три, но это

178
00:11:35,350 --> 00:11:36,70
все равно много.

179
00:11:38,210 --> 00:11:43,90
При том, что есть еще ТЛС-рукопожатие, которое позволяет установить

180
00:11:43,90 --> 00:11:44,870
безопасное TCP-соединение.

181
00:11:45,830 --> 00:11:49,450
ТЛС — это про безопасность, и в классической схеме

182
00:11:49,450 --> 00:11:52,710
такое рукопожатие происходит за шесть посылок, то есть

183
00:11:52,710 --> 00:11:55,450
сетевую задержку можно смело умножать на шесть.

184
00:11:56,450 --> 00:11:58,850
Это уже не просто медленная джуть.

185
00:12:00,610 --> 00:12:03,530
На современных девайсах и при использовании современных

186
00:12:03,530 --> 00:12:08,310
протоколов все может быть не так плохо, но на условном

187
00:12:08,310 --> 00:12:12,130
даже Android 8, который вроде бы не такой уж старый, вполне

188
00:12:12,130 --> 00:12:14,430
может случиться какая-то такая картина.

189
00:12:15,290 --> 00:12:20,690
Мы еще будем сегодня говорить побольше про TLS, HTTP2, HTTP3,

190
00:12:21,270 --> 00:12:23,710
и посмотрим, что там смогли придумать, чтобы стало

191
00:12:23,710 --> 00:12:24,210
быстрее.

192
00:12:25,790 --> 00:12:28,910
А я веду к тому, что при наличии возможности соединения

193
00:12:28,910 --> 00:12:30,230
нужно переиспользовать.

194
00:12:31,170 --> 00:12:32,510
Они не одноразовые.

195
00:12:33,590 --> 00:12:37,870
Мы, например, в Android Яндекс.Музыки детально мониторим качество

196
00:12:37,870 --> 00:12:40,950
и видим, как рукопожатие влияет на каждый отдельный

197
00:12:40,950 --> 00:12:41,330
запрос.

198
00:12:41,330 --> 00:12:46,610
Когда у нас был HTTP версии 1.1, мы остро ощущали проблему

199
00:12:46,610 --> 00:12:47,830
количества соединений.

200
00:12:48,810 --> 00:12:52,170
Ряд сценариев подразумевает отправку параллельных

201
00:12:52,170 --> 00:12:52,810
запросов.

202
00:12:53,470 --> 00:12:56,250
В таком случае поддерживать для переиспользования

203
00:12:56,250 --> 00:13:00,150
нужно не одно соединение, а два, три или семь.

204
00:13:01,990 --> 00:13:07,510
Если разобраться с переиспользованием, можно считать, что у вас

205
00:13:07,510 --> 00:13:09,930
уже все довольно неплохо, более-менее.

206
00:13:10,510 --> 00:13:13,50
Это, наверное, самая критичная оптимизация, за которой

207
00:13:13,50 --> 00:13:13,710
нужно следить.

208
00:13:13,910 --> 00:13:15,410
Но мы еще посмотрим, как за ней следить.

209
00:13:17,990 --> 00:13:21,490
Чтобы всем этим управлять и работать сетью хоть сколько

210
00:13:21,490 --> 00:13:26,650
эффективно, нам понадобятся библиотеки, и мы будем потихоньку

211
00:13:26,650 --> 00:13:29,850
по ходу лекций настраивать классический, самый популярный

212
00:13:29,850 --> 00:13:33,730
в андроиде клиент, OKHTTP, чтобы привязывать теорию

213
00:13:33,730 --> 00:13:34,590
к практике.

214
00:13:36,10 --> 00:13:38,770
Позже мы еще посмотрим на более новые технологии,

215
00:13:38,950 --> 00:13:41,450
например, Ktor, но сначала классика.

216
00:13:42,290 --> 00:13:45,670
У QHTTP подключается в проект одной строкой и все, можно

217
00:13:45,670 --> 00:13:46,230
настраивать.

218
00:13:47,550 --> 00:13:50,30
За переиспользование соединений отвечает в нем

219
00:13:50,30 --> 00:13:51,50
connection pool.

220
00:13:52,210 --> 00:13:55,630
По умолчанию он настроен на кэширование пяти соединений

221
00:13:55,630 --> 00:13:57,810
с таймаутом каждого в пять минут.

222
00:13:58,470 --> 00:14:00,270
Это поле max idle connections.

223
00:14:01,470 --> 00:14:04,790
Это хороший вариант для большинства приложений,

224
00:14:05,150 --> 00:14:07,830
но вы можете подобрать более оптимальные значения

225
00:14:07,830 --> 00:14:08,850
под свои нужды.

226
00:14:09,530 --> 00:14:12,90
Может быть, у вас периодически случается семь, а не пять

227
00:14:12,90 --> 00:14:14,750
параллельных запросов, как было у нас, тогда можно

228
00:14:14,750 --> 00:14:15,730
указать цифру семь.

229
00:14:16,470 --> 00:14:18,670
Тайм-аут же нужно согласовать с бэкэндом.

230
00:14:19,750 --> 00:14:24,270
Одинаковый тайм-аут может, хоть и не сильно, но чуть-чуть

231
00:14:24,270 --> 00:14:28,790
помочь качеству сетевого взаимодействия, как и пул.

232
00:14:28,790 --> 00:14:34,390
За тайм-аут отвечает поле Keep Alive Duration, 5 минут, стандартное

233
00:14:34,390 --> 00:14:38,550
значение тоже ок, но можно двигать, главное, чтобы

234
00:14:38,550 --> 00:14:39,310
было одинаково.

235
00:14:40,810 --> 00:14:44,590
Частой ошибкой здесь можно встретить создание нескольких

236
00:14:44,590 --> 00:14:46,950
экземпляров клиента в разных частях приложения.

237
00:14:47,830 --> 00:14:51,470
Так делать в 95% случаев не надо.

238
00:14:52,50 --> 00:14:54,530
Лучше иметь один экземпляр сетевого клиента на все

239
00:14:54,530 --> 00:14:57,550
приложение, потому что разработчики его заложили

240
00:14:57,550 --> 00:14:59,510
под это множество оптимизаций.

241
00:15:02,190 --> 00:15:05,870
Обычно стоит провернуть еще одну вещь — настроить

242
00:15:05,870 --> 00:15:10,10
тайм-ауты отдельных сетевых запросов, вернее, частей

243
00:15:10,10 --> 00:15:11,150
сетевых запросов.

244
00:15:11,790 --> 00:15:14,470
Десять секунд, которые указаны по умолчанию, это довольно

245
00:15:14,470 --> 00:15:14,830
мало.

246
00:15:15,790 --> 00:15:19,670
Вспомним лифты, метро, плохую сеть, и неудачные запросы

247
00:15:19,670 --> 00:15:22,30
перестают укладываться в эти десять секунд.

248
00:15:23,350 --> 00:15:29,350
Можно поднять здесь тайм-аут хотя бы до 30 секунд на установление

249
00:15:29,350 --> 00:15:32,910
соединения, на чтение и на запись, и тогда ошибок

250
00:15:32,910 --> 00:15:36,430
будет поменьше и, скорее всего, вообще без потерь

251
00:15:36,430 --> 00:15:37,590
каких-то качеств.

252
00:15:40,310 --> 00:15:43,490
Что же за аббревиатура HTTP, которую я тут уже несколько

253
00:15:43,490 --> 00:15:45,130
раз использовал, обгоняя лекцию?

254
00:15:46,190 --> 00:15:48,450
Это протокол передачи данных.

255
00:15:56,770 --> 00:16:02,130
Протокол текстовый, сравнительно простой и понятный, допускает

256
00:16:02,130 --> 00:16:06,650
поддержание одного соединения с последовательными запросами

257
00:16:06,650 --> 00:16:08,150
в рамках этого соединения.

258
00:16:08,850 --> 00:16:12,450
Два запроса одновременно сделать в соединении нельзя,

259
00:16:13,270 --> 00:16:16,450
можно только сначала дождаться ответа одного запроса,

260
00:16:18,490 --> 00:16:23,490
В HTTP 1.1 для взаимодействия с сервером используются

261
00:16:23,490 --> 00:16:28,130
методы GET, POST, PUT и DELETE и другие.

262
00:16:28,790 --> 00:16:32,330
GET запрашивает представление некого ресурса, в данном

263
00:16:32,330 --> 00:16:33,830
случае информации о треке.

264
00:16:35,10 --> 00:16:39,670
POST же отправляет данные на сервер для создания или

265
00:16:39,670 --> 00:16:43,430
обновления представления ресурса, и по стандарту

266
00:16:43,430 --> 00:16:46,750
что это не идемпотентный метод, то есть отправив

267
00:16:46,750 --> 00:16:50,590
несколько запросов, мы создадим несколько треков

268
00:16:50,590 --> 00:16:54,510
или оформим несколько заказов, если у нас интернет-магазин,

269
00:16:54,850 --> 00:16:55,690
и в таком духе.

270
00:16:56,970 --> 00:17:03,350
PUT похож на POST, он либо создает новый ресурс, но отличие

271
00:17:03,350 --> 00:17:06,710
в том, что он может заменить представление уже существующего

272
00:17:06,710 --> 00:17:07,290
ресурса.

273
00:17:09,530 --> 00:17:14,750
Этот метод по стандарту идемпотентный, то есть

274
00:17:14,750 --> 00:17:18,430
если много раз его вызвать, то результат будет один

275
00:17:18,430 --> 00:17:20,50
и тот же, ресурс создан.

276
00:17:21,590 --> 00:17:25,230
Делит, удаляет указанный ресурс, как следует из названия,

277
00:17:25,550 --> 00:17:28,110
и метод тоже идемпотентный, два раза удалив ресурс,

278
00:17:28,130 --> 00:17:31,130
результат будет один, ресурс удалится.

279
00:17:32,490 --> 00:17:37,230
Есть еще head, options, patch, trace и connect, но на них я время

280
00:17:37,230 --> 00:17:40,570
Кому будет интересно, в интернете информации много,

281
00:17:41,630 --> 00:17:44,430
а в андроиде они используются слишком уж редко.

282
00:17:46,530 --> 00:17:50,170
Чтобы сделать быстрее и лучше, придумали Http2.

283
00:17:51,550 --> 00:17:55,350
Стандарт приняли в 2015 году, относительно недавно.

284
00:17:56,570 --> 00:18:01,150
Он приносит большое множество оптимизаций, новых концепций.

285
00:18:01,370 --> 00:18:05,470
Он сложнее, чем предыдущая версия протокола, у него

286
00:18:05,470 --> 00:18:08,350
более неоднородные из-за сложности поддержки.

287
00:18:09,870 --> 00:18:14,850
На сайте Cloudflare написано, что почти 62% мирового трафика

288
00:18:15,550 --> 00:18:20,970
человеческого без учета роботов идет по HTTP2, и на

289
00:18:20,970 --> 00:18:24,270
удивление 30% трафика идет по HTTP3.

290
00:18:26,130 --> 00:18:29,290
Вроде бы, данным можно верить, потому что Cloudflare — серьезная

291
00:18:29,290 --> 00:18:29,750
компания.

292
00:18:29,750 --> 00:18:36,670
Здесь важно оговорить только один нюанс, что процентов

293
00:18:36,670 --> 00:18:42,450
60 общемирового трафика генерируется шестью американскими

294
00:18:42,450 --> 00:18:43,290
компаниями.

295
00:18:45,850 --> 00:18:48,970
Реальная поддержка по количеству веб-сайтов

296
00:18:48,970 --> 00:18:53,750
может быть пониже, чем трафик, но на самом деле смысл

297
00:18:53,750 --> 00:18:54,290
там похож.

298
00:18:55,350 --> 00:19:01,50
Поэтому я считаю, что в 2024 году мобильным разработчикам

299
00:19:01,50 --> 00:19:06,90
нужно посерьезнее задуматься уже даже об HTTP 3 и уж тем

300
00:19:06,90 --> 00:19:08,910
более во всю использовать HTTP 2.

301
00:19:11,340 --> 00:19:14,490
Помните картинку, где соединение устанавливалось за 6 шагов?

302
00:19:15,290 --> 00:19:17,750
Чтобы договориться о версии протокола, мы могли бы

303
00:19:17,750 --> 00:19:20,170
еще разок сходить туда-обратно.

304
00:19:20,870 --> 00:19:23,490
Было бы 8 шагов, последствия сами понимаете.

305
00:19:23,490 --> 00:19:27,910
К счастью, HTTP протокол может попросить TLS договориться

306
00:19:27,910 --> 00:19:30,410
о своей версии в рамках рукопожатия.

307
00:19:31,550 --> 00:19:34,370
Это расширение протокола TLS, которое называется

308
00:19:34,370 --> 00:19:35,610
ALPN.

309
00:19:36,810 --> 00:19:39,330
Как-то погружаться в детали этого процесса совершенно

310
00:19:39,330 --> 00:19:42,430
не обязательно, но аббревиатуру можно иногда встретить,

311
00:19:43,90 --> 00:19:44,490
и аббревиатура важна.

312
00:19:45,770 --> 00:19:49,110
Большинство современных клиентов и серверов поддерживают

313
00:19:49,110 --> 00:19:53,10
это расширение по умолчанию, но следует удостовериться,

314
00:19:53,10 --> 00:19:58,70
что ваши конкретные технологии тоже все поддерживают и все там работает.

315
00:19:59,530 --> 00:20:05,910
В FTP, наверное, второй версии самое интересное для всех фича — это мультиплексирование.

316
00:20:07,650 --> 00:20:12,490
В прошлой версии мы, если хотели отправить несколько запросов параллельно, мы должны были

317
00:20:12,490 --> 00:20:16,790
открыть столько же TCP-соединений, сколько запросов параллельно мы хотим отправить.

318
00:20:18,570 --> 00:20:23,690
При мультиплексировании все запросы к одному хосту

319
00:20:24,490 --> 00:20:29,30
и ответы от него идут через одно соединение, но при

320
00:20:29,30 --> 00:20:30,310
этом параллельно.

321
00:20:32,870 --> 00:20:36,530
Отсюда вырастает один из недостатков, довольно важных.

322
00:20:37,410 --> 00:20:42,390
HTTP2 сильнее зависит от стабильности сети, от потери

323
00:20:42,390 --> 00:20:43,90
пакетов.

324
00:20:43,90 --> 00:20:50,370
Из-за проблемы под названием head-of-line-blocking, это довольно

325
00:20:50,370 --> 00:20:54,870
хитрая проблема уровня TCP, а у нас теперь всего одно

326
00:20:54,870 --> 00:20:59,510
соединение TCP, так что мы в опасности.

327
00:21:00,930 --> 00:21:04,670
В рамках соединения медленный или потерянный пакет одного

328
00:21:04,670 --> 00:21:09,930
запроса может привести к тому, что все остальные

329
00:21:09,930 --> 00:21:12,50
запросы будут стоять в очереди.

330
00:21:12,50 --> 00:21:15,990
На слайде нарисована ситуация, где у нас идет три параллельных

331
00:21:15,990 --> 00:21:17,70
запроса, а, b и c.

332
00:21:17,910 --> 00:21:22,950
Два пакета запроса а успели пройти, а потом пакет запроса

333
00:21:22,950 --> 00:21:23,730
b потерялся.

334
00:21:24,370 --> 00:21:28,30
Из-за этого ни запрос а, ни запрос b и уж не тем более

335
00:21:28,30 --> 00:21:31,130
запрос c завершиться не смогут.

336
00:21:31,630 --> 00:21:34,370
Они все будут ждать тот один пакет запроса b, который

337
00:21:34,370 --> 00:21:34,950
потерялся.

338
00:21:37,90 --> 00:21:39,510
С точки зрения теории это может привести к такому

339
00:21:39,510 --> 00:21:43,850
результату, что на 50-м перцентиле запросы станут проходить

340
00:21:43,850 --> 00:21:46,410
быстрее, чем раньше, а на 90-м — медленнее.

341
00:21:47,530 --> 00:21:51,790
Такой как бы негативный Робин Гуд, и мы в музыке

342
00:21:51,790 --> 00:21:54,350
на самом деле и получили такой результат на практике.

343
00:21:55,790 --> 00:22:00,570
Но в нашем случае, на деле, когда мы разобрались, ничего

344
00:22:00,570 --> 00:22:02,110
плохого прям мы не нашли.

345
00:22:02,590 --> 00:22:07,670
Мы нашли, что у нас стали проходить хуже такие запросы,

346
00:22:07,670 --> 00:22:12,510
прохождение которых решалось случайностью, удуновением

347
00:22:12,510 --> 00:22:12,930
ветра.

348
00:22:15,910 --> 00:22:20,930
Но получилось у нас все хорошо не сразу, и очень

349
00:22:20,930 --> 00:22:24,610
важно все замерять, сравнивать, проводить АБ-тесты.

350
00:22:25,650 --> 00:22:28,690
Лекция про метрики и тесты еще будет, но она, если не

351
00:22:28,690 --> 00:22:30,150
ошибаюсь, последняя в курсе.

352
00:22:30,630 --> 00:22:34,670
Если вдруг не терпится, можно посмотреть прошлогоднюю

353
00:22:34,670 --> 00:22:37,850
лекцию или поразбираться самому в замерах.

354
00:22:39,930 --> 00:22:44,610
Еще в HTTP2 есть сжатие заголовков, и формат передачи данных

355
00:22:44,610 --> 00:22:46,490
стал бинарным, а не текстовым.

356
00:22:47,810 --> 00:22:50,830
Есть еще такие фичи, как пуш со стороны сервера

357
00:22:50,830 --> 00:22:54,310
и приоритизация запросов, но они используются довольно

358
00:22:54,310 --> 00:22:56,570
редко, еще реже успешно.

359
00:22:58,610 --> 00:23:04,150
Чтобы начать использовать HTTP2 через OKHTTP, в общем-то

360
00:23:04,150 --> 00:23:07,450
ничего делать и не надо, если у вас все обновлено

361
00:23:07,450 --> 00:23:08,770
до свежей версии.

362
00:23:09,350 --> 00:23:12,390
Но на всякий случай можете проверить, что в списке протоколов

363
00:23:12,390 --> 00:23:15,310
HTTP 2 стоит на первом месте.

364
00:23:16,370 --> 00:23:19,210
Тут очень важен порядок и приоритет отдается тому,

365
00:23:19,810 --> 00:23:20,950
кто ближе к началу.

366
00:23:22,50 --> 00:23:26,370
Есть еще возможность сказать, что мы поддерживаем исключительно

367
00:23:26,370 --> 00:23:31,470
HTTP 2, прямо только его, HTTP 1.1 не поддерживаем, даже

368
00:23:31,470 --> 00:23:32,470
вторым приоритетом.

369
00:23:34,250 --> 00:23:37,990
Так делать не советуют, потому что растут риски

370
00:23:38,990 --> 00:23:43,310
остаться без сети, если с HTTP2 что-то пойдет не так.

371
00:23:44,410 --> 00:23:47,570
Согласитесь, лучше хоть какую-то сеть иметь, чем

372
00:23:47,570 --> 00:23:48,30
не иметь.

373
00:23:50,410 --> 00:23:54,670
Фича приоритизации запросов в QHTTP, кстати, не поддержана.

374
00:23:56,670 --> 00:24:00,110
Теперь посмотрим на самый новый стандарт, самый интересный.

375
00:24:00,110 --> 00:24:07,10
Это стандарт 1922 года, Http3, в нем еще больше оптимизации,

376
00:24:07,130 --> 00:24:10,910
еще больше новых концепций, и я бы сказал, что он очень

377
00:24:10,910 --> 00:24:14,290
сложный в изучении и в реализации.

378
00:24:15,370 --> 00:24:18,750
Протокол умеет все, что умел Http2, плюс добавляет

379
00:24:18,750 --> 00:24:21,990
свои фичи, в основном за счет протокола QUIC.

380
00:24:24,190 --> 00:24:27,710
Вся эта штука классная на бумаге, но немного слабовато

381
00:24:27,710 --> 00:24:29,710
еще имеет в реальном мире поддержку.

382
00:24:30,550 --> 00:24:34,350
Мы ранее видели, что через эту версию протокола идет

383
00:24:34,350 --> 00:24:39,590
30% общего мирового трафика, но оказывается, что еще

384
00:24:39,590 --> 00:24:42,970
и почти 30% веб-сайтов этот протокол поддерживают.

385
00:24:43,650 --> 00:24:47,270
То есть поддержка есть, и это по данным V3.Tech, с которым

386
00:24:47,270 --> 00:24:48,550
тоже вроде бы можно верить.

387
00:24:51,290 --> 00:24:56,810
На замену TCP в HTTP3 пришел QUIC, который немного странно

388
00:24:56,810 --> 00:25:00,510
укладывается в стандартные модели типа рассмотренной

389
00:25:00,510 --> 00:25:07,290
TCP, TCP IP или OSI, если где-то слышу.

390
00:25:09,170 --> 00:25:12,870
Квик работает поверх UDP соединения, но с гарантированной

391
00:25:12,870 --> 00:25:14,750
доставкой, будто бы это TCP.

392
00:25:15,410 --> 00:25:17,770
При этом он обеспечивает разум и какие-то функции

393
00:25:17,770 --> 00:25:22,550
уровня приложения, которые обычно там были, и вопросы

394
00:25:22,550 --> 00:25:30,830
безопасности, в нем же инкапсулированные вопросы транспорта, он расплылся.

395
00:25:31,190 --> 00:25:33,610
Поэтому он хоть и называется протоколом транспортного

396
00:25:33,610 --> 00:25:36,450
уровня, но с небольшими оговорками.

397
00:25:38,550 --> 00:25:42,750
В теории этот протокол должен значительно лучше вести

398
00:25:42,750 --> 00:25:46,210
себя в сетях с потерями пакетов или нестабильными

399
00:25:46,210 --> 00:25:46,810
задержками.

400
00:25:46,810 --> 00:25:49,370
А это прямо наш случай, так что надо пробовать.

401
00:25:52,10 --> 00:25:56,150
По протоколу еще важно отметить, что он существует

402
00:25:56,150 --> 00:25:59,490
только совместно с ТЛС, и незащищенное соединение

403
00:25:59,490 --> 00:26:00,970
более установить нельзя.

404
00:26:01,670 --> 00:26:06,330
Это по-своему даже хорошо, это безопаснее, но нам разработчикам

405
00:26:06,330 --> 00:26:07,850
в отладке это посложнее.

406
00:26:09,630 --> 00:26:13,90
Еще в QUIC нет соединений в привычном понимании.

407
00:26:15,510 --> 00:26:21,390
Весь мир живет себе спокойно десятилетия с пониманием

408
00:26:21,390 --> 00:26:24,610
того, что слово «соединение» примерно эквивалентно

409
00:26:24,610 --> 00:26:26,550
слову «TCP-соединение».

410
00:26:26,550 --> 00:26:30,830
Тут раз и TCP нет, и все переворачивается, тяжело перестроиться.

411
00:26:31,810 --> 00:26:35,810
В QUIC введено понятие connection ID и connection migration.

412
00:26:37,150 --> 00:26:40,530
В теории за счет этих штук можно не обрывать соединение

413
00:26:40,530 --> 00:26:44,270
при переходе с Wi-Fi на мобильную сеть, скажем, при выходе

414
00:26:44,270 --> 00:26:44,610
из дома.

415
00:26:45,810 --> 00:26:49,810
В реальности большим числом серверных и клиентских

416
00:26:49,810 --> 00:26:53,590
библиотек это поведение не поддержано до сих пор,

417
00:26:54,130 --> 00:26:57,50
потому что сложно и непонятно.

418
00:26:57,950 --> 00:27:01,30
Но местами это работает, в принципе поддержка есть.

419
00:27:01,930 --> 00:27:05,670
Еще один большой плюс у QUIC в том, что протокол реализуется

420
00:27:05,670 --> 00:27:06,330
программно.

421
00:27:06,570 --> 00:27:09,610
Это дает одинаковое поведение на всех версиях прошивок

422
00:27:09,610 --> 00:27:10,70
клиентов.

423
00:27:11,90 --> 00:27:13,950
В разговоре про TLS я упоминал, что там ситуация может быть

424
00:27:13,950 --> 00:27:14,390
разной.

425
00:27:15,530 --> 00:27:18,750
На четырнадцатом андроиде, скажем, все быстро и безопасно,

426
00:27:19,30 --> 00:27:20,710
а на восьмом медленно.

427
00:27:21,530 --> 00:27:24,810
И не только медленно, но еще и небезопасно, ну, менее

428
00:27:24,810 --> 00:27:25,530
безопасно.

429
00:27:26,830 --> 00:27:29,830
Теперь такой проблемы нет, у всех всегда все новое,

430
00:27:30,830 --> 00:27:31,210
круто.

431
00:27:32,190 --> 00:27:35,110
И, конечно же, Квик решает проблему ходу флайнблокинга

432
00:27:35,510 --> 00:27:37,170
на своем программном уровне.

433
00:27:37,170 --> 00:27:42,130
Теперь запрос может заблокировать только сам себя, что звучит

434
00:27:42,130 --> 00:27:45,170
правильно и неизбежно, ничего лучше придумать

435
00:27:45,550 --> 00:27:46,330
я не смог.

436
00:27:48,10 --> 00:27:53,410
А теперь ложка дегтя после вот этой красиво выглядящей

437
00:27:53,410 --> 00:27:53,870
теории.

438
00:27:55,730 --> 00:27:59,70
Например, в сети условного аэропорта могут попросту

439
00:27:59,70 --> 00:28:02,750
блокировать UDP-трафик, и тогда квик работать не

440
00:28:02,750 --> 00:28:03,10
будет.

441
00:28:03,10 --> 00:28:07,190
Говорят, что таких сетей около 5%, я лично не проверял,

442
00:28:07,290 --> 00:28:07,950
но говорят.

443
00:28:08,850 --> 00:28:12,690
Поэтому при включении HTTP3 оставлять фоллбэк на более

444
00:28:12,690 --> 00:28:15,890
раннюю версию совершенно обязательно.

445
00:28:17,750 --> 00:28:22,910
Также для HTTP3, как и на самом деле для HTTP2, критически

446
00:28:22,910 --> 00:28:25,610
важна правильно настроена инфраструктура бэкэмба.

447
00:28:26,510 --> 00:28:31,430
Это шлюзы, балансировщики, отдельные сервисы и прочее.

448
00:28:31,430 --> 00:28:31,810
Проще.

449
00:28:32,210 --> 00:28:35,570
А иначе все его преимущества могут сойти на нет и может

450
00:28:35,570 --> 00:28:38,490
стать даже хуже, чем было с HTTP 1.1.

451
00:28:40,830 --> 00:28:44,90
А если в вашей компании, например, были сетевые фильтры

452
00:28:44,90 --> 00:28:48,530
или какие-то прокси, которые слушали TCP трафик, то они

453
00:28:48,530 --> 00:28:51,730
работать перестанут.

454
00:28:52,390 --> 00:28:57,190
А если эти средства были аппаратными, то все плохо,

455
00:28:57,190 --> 00:29:00,870
потому что они обновятся через пару лет, такой уж

456
00:29:00,870 --> 00:29:03,70
релизный цикл железных вещей.

457
00:29:04,550 --> 00:29:08,350
Примерно год назад я думал, что HTTP 3 уже можно будет

458
00:29:08,350 --> 00:29:12,310
использовать во всю, но на самом деле прогресс

459
00:29:12,310 --> 00:29:16,650
от года к года я вижу небольшой, особенно в части Android, но

460
00:29:16,650 --> 00:29:17,50
он есть.

461
00:29:17,890 --> 00:29:22,490
Что-то где-то, конечно, доделали, но поддержка еще пока слабовата.

462
00:29:22,490 --> 00:29:26,970
Я думаю, все потому, что протокол слишком сложно

463
00:29:26,970 --> 00:29:27,570
реализовать.

464
00:29:27,910 --> 00:29:31,650
Столько всего накрутили, что разработчики просто

465
00:29:31,650 --> 00:29:32,450
не справляются.

466
00:29:33,450 --> 00:29:34,250
Куда же без этого?

467
00:29:35,10 --> 00:29:37,830
Важно помнить, что когда появляется что-то новое,

468
00:29:38,490 --> 00:29:41,290
на это новое появляются и новые виды атак.

469
00:29:42,210 --> 00:29:47,790
Когда появляется что-то такое сложное, как HTTP3, атак

470
00:29:47,790 --> 00:29:51,450
там много, но HTTP2 где-то рядом, это следует держать

471
00:29:51,450 --> 00:29:51,870
в голове.

472
00:29:53,790 --> 00:29:57,170
Я бы хотел показать, как включить поддержку в QHTTP,

473
00:29:57,730 --> 00:30:03,610
но к сожалению, QHTTP так не умеет и не просто не умеет,

474
00:30:03,630 --> 00:30:04,770
а не планирует уметь.

475
00:30:05,550 --> 00:30:09,890
Разработчики говорят, что стандарт слишком сложный

476
00:30:09,890 --> 00:30:12,830
и вообще, если бы они даже написали реализацию квика

477
00:30:12,830 --> 00:30:16,670
на Котлине, то по сравнению с нативной она была бы слишком

478
00:30:16,670 --> 00:30:17,230
медленной.

479
00:30:18,270 --> 00:30:22,990
Я попозже покажу другой сетевой движок под названием

480
00:30:22,990 --> 00:30:24,530
«Кронет», который смог.

481
00:30:26,970 --> 00:30:31,890
Мы почти не затрагивали вопрос безопасности, потому

482
00:30:31,890 --> 00:30:35,810
что если пользоваться HTTPS и специально не портить

483
00:30:36,510 --> 00:30:39,890
стандартные настройки, то все с безопасностью будет

484
00:30:39,890 --> 00:30:41,70
довольно неплохо.

485
00:30:41,930 --> 00:30:44,470
Есть только одна вещь, которую часто добавляют вручную,

486
00:30:44,470 --> 00:30:46,810
она называется TLS-пининг.

487
00:30:49,40 --> 00:30:52,730
Пининг позволяет приложению проверить, является ли сервер,

488
00:30:54,310 --> 00:30:58,610
с которым приложение хочет соединиться, именно тем

489
00:30:58,610 --> 00:31:02,490
сервером, с которым оно хотелось соединиться, то

490
00:31:02,490 --> 00:31:04,670
есть защищает от атаки man-in-the-middle.

491
00:31:05,990 --> 00:31:08,590
Это когда злоумышленник находится между вами и

492
00:31:08,590 --> 00:31:12,650
сервером и может как-то перехватывать передаваемые данные и что-то

493
00:31:12,650 --> 00:31:13,250
с ними делать.

494
00:31:14,590 --> 00:31:19,910
От такой атаки ТЛС по умолчанию вполне надежно защищают,

495
00:31:20,50 --> 00:31:23,290
но остаются лазейки, и эти лазейки как раз пиннингом

496
00:31:23,290 --> 00:31:23,950
закрываются.

497
00:31:29,410 --> 00:31:34,730
Это в основном следствие неправильного поведения

498
00:31:34,730 --> 00:31:37,730
пользователя, которого обманули, которого заставили

499
00:31:37,730 --> 00:31:41,510
установить какой-то поддельный корневой сертификат на

500
00:31:41,510 --> 00:31:45,770
свое устройство, обмануть людей бывает довольно просто.

501
00:31:46,590 --> 00:31:48,670
Вот если такой сертификат человек себе на устройство

502
00:31:48,670 --> 00:31:51,690
установит, то атака менеджмент становится возможной.

503
00:31:56,70 --> 00:32:00,650
TLS-пиннинг сам по себе в нашем коде выглядит довольно

504
00:32:01,750 --> 00:32:02,250
тупорно.

505
00:32:03,70 --> 00:32:06,690
Это проверка вставленного прямо в код отпечатка сертификата

506
00:32:06,690 --> 00:32:11,230
нашего доверенного сервера, и эта проверка позволяет

507
00:32:11,230 --> 00:32:14,490
не доверять никаким другим сертификатам, кроме указанного,

508
00:32:15,650 --> 00:32:18,410
и тогда даже вредоносный корневой сертификат не

509
00:32:18,410 --> 00:32:19,810
позволит обойти защиту.

510
00:32:20,830 --> 00:32:26,130
Чтобы получить такой, как на слайде SHA-256-hash, нужно

511
00:32:26,130 --> 00:32:31,350
публичный сертификат сервера скормить в OpenSSL через терминал.

512
00:32:32,50 --> 00:32:34,590
У нас в TechOverflow легко находятся ответы, как это сделать.

513
00:32:35,770 --> 00:32:41,610
В общем, достаточно создать Certificate Pinner, ввести в него

514
00:32:41,610 --> 00:32:46,470
нужный домен, хеш-сертификаты этого домена, и TLS-пиннинг

515
00:32:46,470 --> 00:32:49,30
начнет работать, и ваши пользователи будут еще

516
00:32:49,30 --> 00:32:53,50
надежнее защищены от атаки man-in-the-middle и вообще от большинства

517
00:32:53,50 --> 00:32:53,330
атак.

518
00:32:54,170 --> 00:32:57,670
И тут можно себя поздравить с тем, что мы уже можем

519
00:32:57,670 --> 00:33:00,510
эффективно и безопасно соединиться с сервером.

520
00:33:00,510 --> 00:33:08,450
Мы уже можем передать на сервер большую строку или какие-то байты, но что они будут значить?

521
00:33:09,170 --> 00:33:14,370
Как серверу их читать? И об этом мы поговорим после паузы на вопросы.

522
00:33:17,790 --> 00:33:27,190
Вопросы задавайте, если еще не задали, на 5-6 минут здесь остановимся, а я пойду смотреть, есть ли уже что-то заданное.

523
00:33:43,30 --> 00:33:47,250
Какие есть лайфхаки или оптимизации по загружке

524
00:33:47,250 --> 00:33:51,110
состояния из бэкэнда при запуске приложения?

525
00:33:52,190 --> 00:33:55,550
Состояние при этом нужно для определения, какой экран

526
00:33:55,550 --> 00:33:56,470
показывать.

527
00:34:02,770 --> 00:34:06,350
Это немножко архитектурный вопрос.

528
00:34:08,210 --> 00:34:14,150
Если вам правда нужен сетевой запрос немедленно и с ответом

529
00:34:14,150 --> 00:34:17,990
от настоящего сервера, то никаких лайфхаков тут

530
00:34:17,990 --> 00:34:20,710
не придумать и нужно ждать ответ.

531
00:34:22,330 --> 00:34:33,990
Если же все можно упростить или поменять, то тогда можно

532
00:34:33,990 --> 00:34:35,130
ответ закэшировать.

533
00:34:36,830 --> 00:34:40,850
Я еще буду упоминать немножко кэширования ближе к концу

534
00:34:40,850 --> 00:34:41,250
лекции.

535
00:34:47,550 --> 00:34:50,990
Если ускорить все до максимума, чтобы быстро работало,

536
00:34:51,290 --> 00:34:54,310
лучше избавиться от этого сетевого запроса на критическом

537
00:34:54,310 --> 00:34:54,570
пути.

538
00:35:03,330 --> 00:35:07,330
Существует ли библиотека с поддержкой Http3 на Android?

539
00:35:10,450 --> 00:35:16,30
Да, я еще расскажу про нее, там есть свои нюансы, но

540
00:35:16,30 --> 00:35:16,750
она существует.

541
00:35:18,850 --> 00:35:23,270
Еще один вопрос, почему в IPv6 разделение групп через

542
00:35:23,270 --> 00:35:24,850
через двоеточие, а не через точку.

543
00:35:26,150 --> 00:35:27,410
Я, честно говоря, не знаю.

544
00:35:28,450 --> 00:35:32,390
Мне кажется, больших каких-то причин глобальных для этого

545
00:35:32,390 --> 00:35:32,670
нет.

546
00:35:38,570 --> 00:35:41,710
Какие еще есть способы пиннинга сертификата, кроме как

547
00:35:41,710 --> 00:35:43,390
прописывания в коде напрямую?

548
00:35:48,10 --> 00:35:51,390
Сложно сказать, потому что в этом и заключается

549
00:35:51,390 --> 00:35:53,730
пиннинг в прописывании сертификата.

550
00:35:54,550 --> 00:36:03,650
Если вы его будете пытаться получить по сети, это в целом

551
00:36:03,650 --> 00:36:09,470
возможно, но это ломает в плане безопасности всю

552
00:36:09,470 --> 00:36:10,50
концепцию.

553
00:36:10,230 --> 00:36:14,950
Потому что если у вас запрос, где вы спросите, а какой

554
00:36:14,950 --> 00:36:17,910
сертификат мне пиннить, если этот запрос перехватят,

555
00:36:17,910 --> 00:36:23,990
а у вас еще нет пиннинга, то все, как бы пиннинга не будет, такой момент.

556
00:36:24,290 --> 00:36:28,670
В основном все хардкодят, прям везде, так что я бы так делал.

557
00:36:56,680 --> 00:37:02,480
Так, и, наверное, последний вопрос. Сервер PUSH — это технология PUSH-уведомлений,

558
00:37:02,480 --> 00:37:05,460
и реализована ли она на TCP.

559
00:37:09,700 --> 00:37:16,60
Здесь ответ непрямой, но сервер PUSH — это не PUSH-уведомление.

560
00:37:17,40 --> 00:37:20,480
PUSH-уведомления реализуются довольно сложно на основе

561
00:37:20,480 --> 00:37:23,180
своих протоколов и чуть ли не своих сокетов.

562
00:37:23,560 --> 00:37:27,560
Зависит все от того, насколько эффективно разработчики

563
00:37:27,560 --> 00:37:28,360
постарались.

564
00:37:29,320 --> 00:37:37,420
То есть в Google Play пуши реализуются довольно сложно, вот, где-то

565
00:37:37,420 --> 00:37:39,980
это просто открытый сокет, в который пушат данные,

566
00:37:41,220 --> 00:37:46,820
это не сервер пуш, это стандарт HTTP, ну, как-то так.

567
00:37:53,500 --> 00:37:56,620
Окей, ну, погнали дальше, если что, в конце еще отвечу

568
00:37:59,300 --> 00:38:03,440
Как же мы будем общаться на одном языке с нашим сервером?

569
00:38:04,540 --> 00:38:07,640
Здесь мир придумал огромное множество подходов к сериализации

570
00:38:07,640 --> 00:38:08,40
данных.

571
00:38:08,800 --> 00:38:13,60
На андроиде наиболее распространены верхние три — это JSON, Protobuf

572
00:38:13,60 --> 00:38:15,520
и XML со звездочкой.

573
00:38:16,460 --> 00:38:20,300
При этом для сетевых коммуникаций XML уже особо не используется,

574
00:38:20,800 --> 00:38:24,00
потому что считается устаревшим, потому что он слишком громоздкий.

575
00:38:24,780 --> 00:38:30,500
А вот JSON и protobuf очень даже в ходу, и JSON многие могли

576
00:38:30,500 --> 00:38:31,00
уже видеть.

577
00:38:31,640 --> 00:38:38,660
У самого формата нету строгой схемы данных, которая была

578
00:38:38,660 --> 00:38:41,980
бы заранее определена, он как бы создается на ходу.

579
00:38:42,700 --> 00:38:46,480
Но на андроиде мы все-таки обычно объявляем ему какую-никакую

580
00:38:46,480 --> 00:38:49,920
схему со своей стороны, хотя бы, если так можно

581
00:38:49,920 --> 00:38:50,580
назвать.

582
00:38:50,580 --> 00:38:55,940
Нас к этому толкают типизированный язык и библиотеки.

583
00:38:57,360 --> 00:39:02,480
Мы обычно объявляем класс DTO, Data Transfer Object, прописываем

584
00:39:02,480 --> 00:39:06,600
в нем поля, правила их сериализации, потом этот объект создаем,

585
00:39:07,560 --> 00:39:10,780
отдаем его в библиотеку, в данном случае это Kotlin

586
00:39:10,780 --> 00:39:15,00
Xerialization, и получаем на выходе строку.

587
00:39:16,200 --> 00:39:20,80
Важно не полагаться на имена пропертий в DTO, потому

588
00:39:20,80 --> 00:39:22,160
Потому что после обфускации они меняются.

589
00:39:23,500 --> 00:39:28,700
И вообще в контракте с вашим бэкэндом именование может

590
00:39:28,700 --> 00:39:32,120
быть через нижнее подчеркивание, потому что не все пишут

591
00:39:32,120 --> 00:39:36,820
на Java, а мы в свой код поля с нижним подчеркиванием

592
00:39:36,820 --> 00:39:37,720
не хотим.

593
00:39:39,240 --> 00:39:42,640
Полученную строку после реализации может прочитать

594
00:39:42,640 --> 00:39:45,220
и отредактировать фактически любой разработчик или

595
00:39:45,220 --> 00:39:48,120
тестировщик без особых проблем, и это большой плюс.

596
00:39:49,980 --> 00:39:53,640
Эту строку можно передать по сети и разложить обратно

597
00:39:53,640 --> 00:39:54,60
в объект.

598
00:39:55,300 --> 00:39:59,460
Можно идти общаться с сервером на одном языке, языке JSON,

599
00:40:00,320 --> 00:40:02,480
и здесь мог бы быть конец.

600
00:40:04,560 --> 00:40:07,280
Но это не конец, и самое интересное ждет нас впереди.

601
00:40:08,620 --> 00:40:11,960
Про Kotlin X.Realization было уже упоминано в лекции по

602
00:40:11,960 --> 00:40:15,800
Kotlin, но добавление в проект там вроде бы не обсуждалось.

603
00:40:15,800 --> 00:40:19,580
И в проект его можно добавить вот так, он идет в виде плагина

604
00:40:19,580 --> 00:40:20,480
и библиотеки.

605
00:40:21,240 --> 00:40:25,600
Подключить нужно и то, и другое, и с другими библиотеками

606
00:40:25,600 --> 00:40:27,660
ситуация обычно будет аналогичная.

607
00:40:28,220 --> 00:40:30,20
Инструкции, если что, в интернете полно.

608
00:40:32,560 --> 00:40:36,680
Аналогом JSON является Protobuf, и Protobuf пошел дальше.

609
00:40:36,860 --> 00:40:40,420
Он, в отличие от JSON, имеет строго определенную схему.

610
00:40:41,00 --> 00:40:44,20
Эта схема компилируется в классы под практически

611
00:40:44,20 --> 00:40:51,820
любой популярный язык, в том числе, конечно, Java и частично Kotlin, но его полноценная поддержка

612
00:40:51,820 --> 00:41:00,420
для Kotlin еще пока в работе, но она и так достаточна. Вот в этой строгой схеме заключается первый

613
00:41:00,420 --> 00:41:07,620
громадный плюс формата. Мы можем общаться по-настоящему в одном языке с нашим сервером, потому что

614
00:41:07,620 --> 00:41:12,140
контракт у нас жестко зафиксирован в коде, и в одностороннем

615
00:41:12,140 --> 00:41:15,960
порядке забыть, что-то передать, какое-то обязательное

616
00:41:15,960 --> 00:41:21,420
поле можно только из злодейских побуждений, а не из забывчивости,

617
00:41:21,580 --> 00:41:22,480
как в случае с JSON.

618
00:41:24,840 --> 00:41:27,540
Второй плюс у протобафа заключается в бинарности

619
00:41:27,540 --> 00:41:30,140
формата и очень высокой степени компактности.

620
00:41:31,440 --> 00:41:36,240
Протобаф значительно компактнее формата JSON, универсальную

621
00:41:36,240 --> 00:41:39,920
цифру, я не могу сказать, но вот есть пример.

622
00:41:40,480 --> 00:41:44,960
Все зависит от конкретных данных, без сжатия разница

623
00:41:44,960 --> 00:41:48,580
может быть до четырех раз, а со сжатием до двух раз,

624
00:41:49,360 --> 00:41:52,960
и чем больше объем данных, тем разница меньше.

625
00:41:53,700 --> 00:41:56,800
Это немного контраинтуитивно, но это так.

626
00:41:57,540 --> 00:42:00,400
Все дело в том, что данные передаются всегда по сети

627
00:42:00,400 --> 00:42:06,280
в сжатом формате, и большой JSON-текст хорошо ужимается

628
00:42:06,280 --> 00:42:07,200
перед передачей.

629
00:42:09,900 --> 00:42:15,400
На сжатых данных, начиная примерно с 17 килобайт, особенно

630
00:42:15,400 --> 00:42:19,620
если данные внутри себя содержат повторы, которые

631
00:42:19,620 --> 00:42:25,600
архиватору хорошо упаковать можно, разница держится

632
00:42:25,600 --> 00:42:27,900
на уровне процентов 15-20.

633
00:42:27,900 --> 00:42:29,900
Протобафф выигрывает все равно.

634
00:42:32,460 --> 00:42:35,920
При этом протобафф еще и сериализуется с меньшей

635
00:42:35,920 --> 00:42:39,420
нагрузкой на процессор, чем JSON, потому что он бинарный,

636
00:42:39,480 --> 00:42:43,680
там все четко, нету никаких строчек, и поэтому протобафф

637
00:42:43,680 --> 00:42:45,140
опять же немножко эффективнее.

638
00:42:46,380 --> 00:42:50,240
Его, наверное, главным минусом является то, что человек

639
00:42:50,240 --> 00:42:53,100
едва ли может прочесть бинарное содержимое.

640
00:42:53,860 --> 00:42:57,300
Человеку для этого нужны под рукой файл со схемой

641
00:42:57,300 --> 00:43:00,620
данных и некая программа, которая проводила бы эту

642
00:43:00,620 --> 00:43:01,460
децерализацию.

643
00:43:03,140 --> 00:43:05,380
Вторым минусом является сложность.

644
00:43:06,40 --> 00:43:10,340
В языке Proto есть множество ключевых слов и неочевидных

645
00:43:10,340 --> 00:43:14,440
сходу особенностей, где вообще это язык, который

646
00:43:15,60 --> 00:43:15,940
компилируется.

647
00:43:18,560 --> 00:43:21,720
Завести на проекте ProtoBuf, естественно, значительно

648
00:43:21,720 --> 00:43:26,500
сложнее, чем JSON, и тут я бы провел аналогию с HTTP3.

649
00:43:26,500 --> 00:43:32,440
Если вы хотите выжать максимум в плане надежности и производительности,

650
00:43:32,600 --> 00:43:36,300
тогда это ваш выбор, а иначе можно посмотреть на что-то

651
00:43:36,300 --> 00:43:36,800
попроще.

652
00:43:39,40 --> 00:43:43,640
Вот так можно Protobuf добавить в проект Google Protobuf, что бывают

653
00:43:43,640 --> 00:43:45,860
разные реализации у стандарта.

654
00:43:47,180 --> 00:43:50,80
Он идет в виде плагина, библиотеки и компилятора

655
00:43:50,80 --> 00:43:55,780
Protofi, то есть подключить и настроить нужно три вещи.

656
00:43:55,780 --> 00:44:00,220
Запоминать код не нужно, но можете вспомнить про

657
00:44:00,220 --> 00:44:02,620
этот слайд, потому что в интернете не очень много

658
00:44:02,620 --> 00:44:06,900
актуальных инструкций и почти нет инструкций под

659
00:44:06,900 --> 00:44:10,380
Gradle Kotlin скрипты, а не Groovy скрипты.

660
00:44:15,800 --> 00:44:18,160
Осталось спроектировать наш API.

661
00:44:19,80 --> 00:44:22,620
В мобильных приложениях чаще всего у нас взаимодействие

662
00:44:22,620 --> 00:44:26,480
Это типа запрос-ответ, поэтому о нем мы поговорим.

663
00:44:28,800 --> 00:44:32,740
В мире есть сейчас три наиболее популярных подхода к проектированию

664
00:44:32,740 --> 00:44:33,460
такого API.

665
00:44:33,780 --> 00:44:36,400
Это REST, RPC и GraphQL.

666
00:44:39,80 --> 00:44:42,500
REST является безусловным лидером по распространенности,

667
00:44:42,680 --> 00:44:45,480
но RPC и GraphQL тоже часто можно встретить.

668
00:44:47,80 --> 00:44:50,980
Здесь я хочу озвучить мысль, которая мне особо запомнилась

669
00:44:50,980 --> 00:44:52,360
с одного доклада.

670
00:44:52,840 --> 00:44:57,100
На любом из этих современных крутых и эффективных протоколах,

671
00:44:58,600 --> 00:45:04,800
технологиях, можно спроектировать как хорошее API, так можно

672
00:45:04,800 --> 00:45:06,80
спроектировать и плохое.

673
00:45:06,820 --> 00:45:13,660
Если у вас было не очень хорошее REST API, то самим

674
00:45:13,660 --> 00:45:16,560
по себе переходом на другую технологию, вы свою проблему

675
00:45:16,560 --> 00:45:17,860
скорее всего не решите.

676
00:45:19,600 --> 00:45:22,60
В реальном мире есть интересный пример.

677
00:45:23,260 --> 00:45:26,700
В 2016 году GitHub заявила о переходе на GraphQL.

678
00:45:27,240 --> 00:45:29,620
Говорит, REST доставляет нам много проблем, переходим.

679
00:45:30,700 --> 00:45:33,680
Вышла параллельно новая статья, что за GraphQL будущее

680
00:45:33,680 --> 00:45:34,720
и все в таком духе.

681
00:45:35,780 --> 00:45:40,40
Часть проблем своих GitHub правда решил, судя по всему,

682
00:45:40,740 --> 00:45:42,480
но он создал и другие проблемы.

683
00:45:43,360 --> 00:45:48,720
А сейчас уже на дворе 2024 год, а GitHub, REST закапывать вообще

684
00:45:48,720 --> 00:45:49,440
не собираются.

685
00:45:49,600 --> 00:45:53,20
Поддерживают его полноценно, и в итоге обе версии поддерживают.

686
00:45:54,200 --> 00:45:56,960
Судите сами, что там произошло, но было так.

687
00:45:59,200 --> 00:46:02,360
Посыл уже мой в том, что проектированию API нужно

688
00:46:02,360 --> 00:46:06,740
уделять очень и очень большое внимание, потому что оно

689
00:46:06,740 --> 00:46:07,600
с вами надолго.

690
00:46:08,760 --> 00:46:12,240
И пусть это прозвучит банально, но нужно выбирать технологию

691
00:46:12,240 --> 00:46:16,440
подпотребности и ни в коем случае не натягивать потребности

692
00:46:16,440 --> 00:46:17,400
на технологию.

693
00:46:19,600 --> 00:46:24,120
Если взвешивать все за и против и следовать лучшим

694
00:46:24,120 --> 00:46:27,680
практикам проектирования, то у вас все будет гладко.

695
00:46:30,540 --> 00:46:34,900
Когда я рассказывал про методы HTTP, я сразу как пример

696
00:46:34,900 --> 00:46:36,780
и показал типичный REST-запрос.

697
00:46:38,80 --> 00:46:43,60
Идеология REST строится вокруг HTTP методов, и это делает

698
00:46:43,60 --> 00:46:46,520
его унифицированным и довольно простым для понимания.

699
00:46:47,980 --> 00:46:52,120
GET, POST, PUT и DELETE, которые мы уже видели, это наиболее

700
00:46:52,120 --> 00:46:56,660
часто используемые HTTP методы, и они же, наверное,

701
00:46:58,300 --> 00:47:00,100
единственные, которые используются в REST.

702
00:47:02,920 --> 00:47:05,40
Детально запрос обычно представляется так.

703
00:47:05,40 --> 00:47:11,960
Метод в данном случае get, далее идет домен, потом ресурс,

704
00:47:12,640 --> 00:47:16,460
потом параметр пути, это в данном случае идентификатор трека 123,

705
00:47:17,440 --> 00:47:19,280
и потом параметр запроса.

706
00:47:20,560 --> 00:47:25,920
В данном случае это как бы я прошу третью версию трека.

707
00:47:27,200 --> 00:47:29,700
Параметр запроса — это обычная опциональная часть,

708
00:47:29,920 --> 00:47:31,740
которой можно что-то уточнить.

709
00:47:36,860 --> 00:47:40,340
В рамках API обычно можно передавать как текстовые

710
00:47:40,340 --> 00:47:45,480
данные в формате JSON, так и бинарные данные в формате

711
00:47:45,480 --> 00:47:46,160
protobuf.

712
00:47:46,880 --> 00:47:50,660
Но это вам будет доступно только если у вас HTTP 2 или

713
00:47:50,660 --> 00:47:51,100
3.

714
00:47:55,180 --> 00:47:59,620
Вернемся к HTTP и через него можно сделать запрос.

715
00:48:00,440 --> 00:48:02,920
Но так обычно никто не делает, но можно.

716
00:48:04,120 --> 00:48:06,800
Для этого нужно создать объект-реквест, передать

717
00:48:06,800 --> 00:48:10,420
туда URL и метод, и скормить это все в клиент через new

718
00:48:10,420 --> 00:48:11,220
call и enqueue.

719
00:48:11,860 --> 00:48:15,300
А в callback мы получим результат, который нужно вручную читать

720
00:48:15,300 --> 00:48:19,320
из потока байтов, и конвертировать это в какие-то наши классы

721
00:48:19,320 --> 00:48:20,320
и приводить к карутину.

722
00:48:21,100 --> 00:48:25,220
Это все не очень-то тривиально, и обычно эту часть за нас

723
00:48:25,220 --> 00:48:29,20
делают разработчики библиотек, а мы не пользуемся QHTTP напрямую.

724
00:48:34,260 --> 00:48:39,40
На помощь нам придет самый популярный вариант работы

725
00:48:39,40 --> 00:48:44,420
средств API, сейчас это Retrofit, это до недавних пор практически

726
00:48:44,420 --> 00:48:46,460
неотрывная пара для OKHTTP.

727
00:48:47,880 --> 00:48:51,500
Эта библиотека позволяет объявлять интерфейс API

728
00:48:51,500 --> 00:48:55,180
лаконичным образом при помощи аннотации и потом

729
00:48:55,180 --> 00:48:57,740
трансформировать все это в реальные вызовы при

730
00:48:57,740 --> 00:48:58,860
помощи рефлексии.

731
00:49:00,20 --> 00:49:04,420
В данном примере я описываю все тот же запрос по получению

732
00:49:04,420 --> 00:49:06,680
информации о треке по его идентификатору, то есть

733
00:49:06,680 --> 00:49:09,840
метод get путь track с параметром пути track id.

734
00:49:11,60 --> 00:49:15,460
Вот этот placeholder в фигурных скобочках track id, он заместится

735
00:49:15,460 --> 00:49:19,80
на реально переданный track id, такая вот магия, например

736
00:49:19,80 --> 00:49:19,600
123.

737
00:49:21,120 --> 00:49:23,840
Далее, чтобы получить инстанс этого интерфейса, нужно

738
00:49:23,840 --> 00:49:28,160
можно сначала сконфигурировать непосредственно Retrofit, то

739
00:49:28,160 --> 00:49:31,160
есть задать туда базовый URL, передать оптимально

740
00:49:31,160 --> 00:49:35,960
настроенный, как мы умеем, OKHTTP клиент и передать конвертер.

741
00:49:36,620 --> 00:49:40,200
Конвертер в данном случае код Linux Serialization, но можно

742
00:49:40,200 --> 00:49:43,340
и другие, например, Xon или Moshe или еще что-то.

743
00:49:45,60 --> 00:49:48,320
Такую настройку вообще обычно нужно делать разок

744
00:49:48,320 --> 00:49:51,260
за проект и иногда что-то там чуть-чуть докручивать.

745
00:49:52,660 --> 00:49:57,260
Когда мы создадим объект, можно через Retrofit Create получить

746
00:49:57,260 --> 00:50:01,540
инстанс нашего трек-CPI и сделать непосредственно

747
00:50:01,540 --> 00:50:02,400
сетевой запрос.

748
00:50:05,620 --> 00:50:11,820
Любой сетевой клиент будет кидать ошибки, потому что

749
00:50:11,820 --> 00:50:16,720
в них в мире ввода-вывода никуда без них.

750
00:50:17,280 --> 00:50:20,560
Ловить в Try-Catch я советую всегда конкретные ошибки.

751
00:50:20,560 --> 00:50:23,480
Не стоит ловить trouble или просто общий exception.

752
00:50:25,00 --> 00:50:30,340
На слайде я знаю, что связка OKCTP, Retrofit и Kotlin X Serialization может

753
00:50:30,340 --> 00:50:32,240
насыпать вот таких три ошибки.

754
00:50:34,160 --> 00:50:37,240
Не стоит давать этим ошибкам распространяться в разные

755
00:50:37,240 --> 00:50:38,220
части приложения.

756
00:50:38,980 --> 00:50:42,160
Лучше где-то в репозитории или другой сущности слоя

757
00:50:42,160 --> 00:50:46,40
данных привести эти ошибки к общему и универсальному

758
00:50:46,40 --> 00:50:46,440
виду.

759
00:50:46,440 --> 00:50:50,580
Я рекомендую путь заворачивания ошибок в силот-класс.

760
00:50:51,680 --> 00:50:55,700
Следующее утверждение будет немного холиварным и субъективным,

761
00:50:56,100 --> 00:51:00,820
но трекетч для обработки сетевых запросов выглядит

762
00:51:00,820 --> 00:51:05,940
не очень, легко забывается, и вообще не поймешь, где

763
00:51:05,940 --> 00:51:09,980
он уже случился, где не случился и так далее.

764
00:51:12,80 --> 00:51:15,380
Если специфичные ошибки распространятся по приложению,

765
00:51:15,380 --> 00:51:18,760
то рефакторить их потом абсолютно неприятно.

766
00:51:20,540 --> 00:51:24,380
Здесь я предлагаю определить класс с названием типа

767
00:51:24,380 --> 00:51:25,320
NetworkResult.

768
00:51:25,960 --> 00:51:29,260
Название не столько важно, как важна суть, и в этот

769
00:51:29,260 --> 00:51:30,740
класс складываются ошибки.

770
00:51:32,160 --> 00:51:36,40
С остальными технологиями и клиентами, то есть нейротрофитом

771
00:51:36,40 --> 00:51:39,120
и неокотленных сериализейшин, я советую делать ровно

772
00:51:39,120 --> 00:51:39,420
также.

773
00:51:42,380 --> 00:51:46,60
Чтобы эта схема заработала, нам нужны две зависимости

774
00:51:46,60 --> 00:51:53,840
Retrofit и конвертер, который бы работал с Kotlin X Serialization.

775
00:51:56,60 --> 00:51:58,600
Следующий подход у нас на очереди — это RPC.

776
00:51:59,360 --> 00:52:02,340
У него есть разные реализации, но наибольшее признание

777
00:52:02,340 --> 00:52:08,260
получило gRPC, то есть RPC от Google, он очень тесно интегрирован

778
00:52:08,260 --> 00:52:13,80
Google протобав и других форматов не допускает.

779
00:52:14,340 --> 00:52:18,400
Протокол классный, он быстрый, надежный и функциональный,

780
00:52:19,320 --> 00:52:22,780
но порог входа в него по сложности значительно выше,

781
00:52:23,60 --> 00:52:23,440
чем в REST.

782
00:52:24,740 --> 00:52:31,700
Этот протокол сейчас работает поверх версии HTTP2, но в скором

783
00:52:31,700 --> 00:52:34,660
времени вроде бы собирается HTTP3 тоже поддержать.

784
00:52:36,320 --> 00:52:38,160
Протокол позволяет делать многое.

785
00:52:38,280 --> 00:52:42,780
Мы можем делать просто запрос-ответ, как в REST, можем

786
00:52:42,780 --> 00:52:46,900
запустить стрим со стороны сервера, можем даже стрим

787
00:52:46,900 --> 00:52:48,100
со стороны клиента.

788
00:52:48,980 --> 00:52:51,440
Довольно необычные вещи, которые хорошо работают

789
00:52:51,440 --> 00:52:52,460
в gRPC.

790
00:52:53,200 --> 00:52:55,80
Мы можем даже запустить стрим в обе стороны.

791
00:52:56,780 --> 00:53:01,100
Реально работающий стриминг на моем опыте одна из важнейших

792
00:53:01,100 --> 00:53:04,00
причин, по которым этот протокол выбирают.

793
00:53:05,120 --> 00:53:07,660
С помощью стриминга мы можем эффективно получать

794
00:53:07,660 --> 00:53:12,280
обновления в реальном времени, не делая запросы

795
00:53:12,280 --> 00:53:14,320
раз в секунду или еще чего-то такого.

796
00:53:17,720 --> 00:53:25,20
На Android и на iOS все у JRPC хорошо, а вот у браузеров поддержка

797
00:53:25,20 --> 00:53:25,480
похуже.

798
00:53:25,680 --> 00:53:29,740
Им либо требуется дополнительная работа в виде развертывания

799
00:53:29,740 --> 00:53:33,860
дополнительных прокси, либо часть функции недоступна

800
00:53:33,860 --> 00:53:34,260
для них.

801
00:53:35,160 --> 00:53:36,280
Такая ситуация не очень.

802
00:53:37,860 --> 00:53:42,700
Несколько слайдов назад я показывал MessageTrack, и для

803
00:53:42,700 --> 00:53:47,120
этого слайда я взял тот же самый протофайл, но еще

804
00:53:47,120 --> 00:53:53,40
дописал в него запрос getTrackRequest с одним параметром id, и еще

805
00:53:53,40 --> 00:53:55,180
пониже самое интересное TracksService.

806
00:53:55,180 --> 00:54:00,320
В этом сервисе я определил запрос под названием get-track,

807
00:54:00,500 --> 00:54:04,80
который get-track-request принимает на вход и возвращает информацию

808
00:54:04,80 --> 00:54:04,560
о треке.

809
00:54:07,440 --> 00:54:12,620
Это контракт взаимодействия с нашим сервером, который

810
00:54:13,800 --> 00:54:17,640
зафиксирован прямо в нашем файле, а значит он на всех

811
00:54:17,640 --> 00:54:22,880
платформах будет железобетонно одинаковым и самодокументированным,

812
00:54:22,880 --> 00:54:25,680
потому что документацию можно в этом же файле ввести.

813
00:54:27,300 --> 00:54:31,120
И это второй громадный плюс, во многом ради которого

814
00:54:31,120 --> 00:54:34,920
на крупных проектах разработчики делают выбор в пользу gRPC.

815
00:54:38,80 --> 00:54:42,60
Вот так это выглядит в коде, создается запрос и стаб.

816
00:54:42,500 --> 00:54:46,440
Стаб — это генерируемый класс, который позволяет

817
00:54:46,440 --> 00:54:47,960
обращаться к сервису.

818
00:54:49,300 --> 00:54:53,180
Затем обычным suspent методом мы делаем запросы и получаем

819
00:54:53,180 --> 00:54:53,560
ответ.

820
00:54:56,660 --> 00:55:01,840
Красиво, но в настройке сложно, есть нюансы с поддержкой.

821
00:55:03,880 --> 00:55:07,120
Я совсем здесь не буду останавливаться на слайде с настройкой,

822
00:55:07,920 --> 00:55:11,00
но для тех, кто заинтересуется, будет возможность подсмотреть.

823
00:55:12,260 --> 00:55:15,540
Потому что полноценного и актуального гайда я в интернете

824
00:55:22,100 --> 00:55:26,840
В нем пара концепций еще не была рассмотрена и одна

825
00:55:26,840 --> 00:55:30,520
из них — это интерцепторы, по-русски перехватчики,

826
00:55:31,80 --> 00:55:34,20
механизм, который позволяет отслеживать и изменять

827
00:55:34,20 --> 00:55:35,180
сетевые запросы.

828
00:55:36,280 --> 00:55:41,40
Каждый сетевой запрос проходит все интерцепторы по цепочке

829
00:55:41,40 --> 00:55:45,880
один за другим, в обе стороны, и на запрос, и на ответ.

830
00:55:47,80 --> 00:55:49,680
Еще интерцепторы бывают двух видов — это аппликейшн

831
00:55:49,680 --> 00:55:50,340
и нетворк.

832
00:55:51,640 --> 00:55:55,500
В свое время мне было довольно тяжело осознать разницу,

833
00:55:55,540 --> 00:55:59,80
хотя она укладывается в пару предложений.

834
00:56:01,140 --> 00:56:04,40
Например, если у вас настроено автоматическое повторение

835
00:56:04,40 --> 00:56:10,180
запросов в случае ошибки в ретрае, то на уровне приложения

836
00:56:10,180 --> 00:56:14,40
у вас на уровне приложения всегда будет один запрос,

837
00:56:14,900 --> 00:56:18,980
а вот на уровне сети при ретраях у вас будет несколько

838
00:56:18,980 --> 00:56:19,660
запросов.

839
00:56:20,580 --> 00:56:23,260
Интерцептор уровня приложения будет вызван один раз,

840
00:56:24,120 --> 00:56:28,400
а уровня нетворка столько раз, сколько было реальных

841
00:56:28,400 --> 00:56:29,320
запросов в сеть.

842
00:56:30,740 --> 00:56:33,660
Здесь еще и кэширование рядом находится, потому

843
00:56:33,660 --> 00:56:39,480
что оно может убрать запрос в сеть, но на уровне приложения

844
00:56:39,480 --> 00:56:42,700
Один запрос все равно будет, один вызов интерцептора.

845
00:56:43,200 --> 00:56:45,660
А у нетворка может быть от 0 до n.

846
00:56:46,260 --> 00:56:47,320
Вот такая разница.

847
00:56:50,620 --> 00:56:54,380
Например, можно создать вот такой интерцептор для

848
00:56:54,380 --> 00:56:57,180
подстановки заголовка с токеном авторизации в

849
00:56:57,180 --> 00:56:57,880
каждый запрос.

850
00:56:58,640 --> 00:57:01,260
Мы еще про авторизацию поговорим немного, это такая

851
00:57:01,260 --> 00:57:01,940
затравка.

852
00:57:03,220 --> 00:57:07,700
Здесь мы получаем оригинальный реквест, через билдер добавляем

853
00:57:07,700 --> 00:57:11,800
туда заголовок и просим всю цепочку продолжить работу.

854
00:57:13,260 --> 00:57:17,660
Потом добавляем этот интерцептор в конфигурацию okhttp клиента

855
00:57:18,340 --> 00:57:25,860
как application, когда просто add-interceptor это application, потому

856
00:57:25,860 --> 00:57:29,500
что вроде как просто нет смысла добавлять его как

857
00:57:29,500 --> 00:57:29,960
network.

858
00:57:30,220 --> 00:57:33,340
Но это можно было бы сделать, это никем не запрещено.

859
00:57:35,580 --> 00:57:39,820
Еще недавно казалось, что КХТТП с нами навсегда, потому

860
00:57:39,820 --> 00:57:40,300
что он везде.

861
00:57:41,440 --> 00:57:44,660
Но изучив вопрос, я начал думать, что это не совсем

862
00:57:44,660 --> 00:57:45,60
так.

863
00:57:45,680 --> 00:57:49,60
Как я уже говорил, он, во-первых, не планирует поддерживать

864
00:57:49,60 --> 00:57:49,880
ХТТП-3.

865
00:57:50,720 --> 00:57:55,760
Второе, что пусть и не супер критично, но в приоритизацию

866
00:57:55,760 --> 00:57:57,300
запросов он тоже не умеет.

867
00:57:59,380 --> 00:58:05,580
Если посмотреть на классическую связку QHTTP и ретрофит, то

868
00:58:05,580 --> 00:58:09,120
ее переиспользование в мультиплатформе невозможно,

869
00:58:10,760 --> 00:58:12,00
хотя хотелось бы.

870
00:58:12,780 --> 00:58:20,480
У нас в Яндекс.Музыке на андроиде от 150 до 200 запросов

871
00:58:20,480 --> 00:58:20,980
разных.

872
00:58:22,100 --> 00:58:27,780
Это сотни, тысячи разных DTO и конверторов, кода, которые

873
00:58:27,780 --> 00:58:28,660
это обслуживает.

874
00:58:29,360 --> 00:58:32,100
Пока еще руки не дошли, но мы бы хотели разрабатывать

875
00:58:32,100 --> 00:58:35,560
все это один раз, то есть вынести в мультиплатформу

876
00:58:35,560 --> 00:58:39,180
и хотя бы союз, это иметь в общей части кодовой базы.

877
00:58:40,560 --> 00:58:43,560
Но кто не хотел бы, мы в классической связке так

878
00:58:43,560 --> 00:58:44,80
не можем.

879
00:58:46,380 --> 00:58:49,960
Здесь разработчики UKHCTP предлагают нам выход и говорят,

880
00:58:49,960 --> 00:58:55,900
«Используйте Ktor, но движок можете оставить у KHTTP».

881
00:58:55,900 --> 00:58:59,920
У них на самом деле были даже попытки выйти в мультиплатформу,

882
00:59:00,160 --> 00:59:03,520
но они их почему-то в одной из альфа-версий бросили.

883
00:59:08,760 --> 00:59:10,480
Что же такое Ktor?

884
00:59:11,20 --> 00:59:13,560
Это крупный фреймворк, на котором можно написать

885
00:59:13,560 --> 00:59:15,800
как серверное приложение, так и клиентское.

886
00:59:15,800 --> 00:59:23,520
Он популярен в мире, в Яндексе у многих команд есть, и

887
00:59:23,520 --> 00:59:25,640
он отлично подходит для андроид-приложений.

888
00:59:26,640 --> 00:59:29,520
Он, естественно, может быть использован в мультиплатформе,

889
00:59:30,540 --> 00:59:34,120
и написанные на нем запросы, конфигурации тоже могут

890
00:59:34,120 --> 00:59:36,20
быть в мультиплатформе.

891
00:59:38,60 --> 00:59:43,320
Он написан на Kotlin и максимально совместим с остальным нашим

892
00:59:43,320 --> 00:59:46,820
кодом, имея удобный API на карутинах.

893
00:59:48,520 --> 00:59:54,00
Третий большой плюс — у него есть множество официальных

894
00:59:54,00 --> 00:59:56,900
плагинов, которыми можно расширить его под любые

895
00:59:57,460 --> 00:59:59,60
свои запросы.

896
00:59:59,180 --> 01:00:04,80
Есть и неофициальные плагины, можно много всего сделать.

897
01:00:04,900 --> 01:00:10,460
Там можно настроить логирование, кэширование, авторизацию,

898
01:00:10,460 --> 01:00:16,480
формат передачи данных, заголовки, сжатия, и все,

899
01:00:16,640 --> 01:00:17,620
что можно придумать.

900
01:00:19,340 --> 01:00:21,980
В том числе можно настроить сетевой движок.

901
01:00:23,740 --> 01:00:26,900
Это интересная вещь, то есть даже сетевой движок

902
01:00:26,900 --> 01:00:29,960
можно подложить свой, а Ctore — это как бы обертка.

903
01:00:31,880 --> 01:00:37,920
Поэтому можно создать Ctore-HTTP-клайнт, используя под капотом OKHTTP.

904
01:00:39,100 --> 01:00:44,540
Здесь передача настроенного клиента в поле Preconfigured позволит

905
01:00:44,540 --> 01:00:48,980
нам продолжать пользоваться преимуществами QHTTP, которые

906
01:00:48,980 --> 01:00:53,260
мы настроили, но при этом и получить все преимущества

907
01:00:53,260 --> 01:00:54,420
к тору.

908
01:00:56,800 --> 01:01:00,660
Настраивается это довольно легко, здесь только один

909
01:01:00,660 --> 01:01:09,700
хитрый момент — поле threads count, оно внутри себя ограничивает

910
01:01:09,700 --> 01:01:14,740
максимальное количество потоков обработки результатов

911
01:01:14,740 --> 01:01:15,800
запросов.

912
01:01:17,460 --> 01:01:21,140
И тут хитрый момент, оно не должно быть равно количеству

913
01:01:21,140 --> 01:01:25,340
потоков у внутреннего диспатчера, у QHTTP, их обычно где-то 32,

914
01:01:26,460 --> 01:01:30,220
здесь их может быть поменьше за счет того, что движок

915
01:01:30,220 --> 01:01:35,220
написан на коррутинах и за счет того, что обработка

916
01:01:35,220 --> 01:01:39,660
результата требует меньше времени, чем выполнение

917
01:01:39,660 --> 01:01:41,160
самого запроса.

918
01:01:42,980 --> 01:01:45,760
Внутри там ограничения именно на количество активных

919
01:01:45,760 --> 01:01:49,800
только рутин и спящие, прерванные, не учитываются.

920
01:01:52,680 --> 01:01:55,880
Сетевые запросы в Ktor относительно легко описываются.

921
01:01:56,20 --> 01:02:00,80
Мы выбираем метод, конструируем URL и через передачу нужного

922
01:02:00,80 --> 01:02:05,760
типа в метод body получаем наш класс, это reified тип.

923
01:02:08,240 --> 01:02:13,00
Под капотом после такого вызова будет выполнен непосредственно

924
01:02:13,00 --> 01:02:16,800
сетевой запрос, из него вычитается ответ, ответ

925
01:02:16,800 --> 01:02:20,620
десериализуется из, скажем, JSON в объект.

926
01:02:21,940 --> 01:02:26,320
А если бы наши данные передавались не в JSON формате, а в каком-то

927
01:02:26,320 --> 01:02:31,940
другом, вдруг XML или Protobuf, то нам было бы достаточно

928
01:02:31,940 --> 01:02:36,380
просто поменять блок content negotiation с прошлого слайда

929
01:02:36,770 --> 01:02:38,620
и в принципе все бы заработало.

930
01:02:38,620 --> 01:02:43,700
Если у нас код Linux Serialization, то там такая тонкая грань,

931
01:02:44,180 --> 01:02:51,400
но в целом система такая, так что сам код запросов

932
01:02:51,400 --> 01:02:55,340
от формата передачи здесь не особо зависит.

933
01:03:00,440 --> 01:03:04,640
Если вы человек достаточно отважный, то вы можете попробовать

934
01:03:04,640 --> 01:03:08,140
в качестве сетевого движка для Tor штуку под названием

935
01:03:08,140 --> 01:03:12,540
Cronet — это сетевой движок от Chrome браузера, который

936
01:03:12,540 --> 01:03:13,740
вынесли в библиотеку.

937
01:03:14,700 --> 01:03:17,620
Google говорит, что им на Андроиде пользуются буквально все

938
01:03:17,620 --> 01:03:21,460
его приложения, включая таких гигантов, как YouTube,

939
01:03:21,760 --> 01:03:23,640
Google и прочих.

940
01:03:24,240 --> 01:03:26,120
То есть вещь должна быть серьезная.

941
01:03:28,100 --> 01:03:32,220
Cronet поддерживает все самые новые функции, включая

942
01:03:32,220 --> 01:03:38,200
http3, включая quick и доставляет программный свежий транспортный

943
01:03:38,200 --> 01:03:39,900
уровень на старые устройства.

944
01:03:41,500 --> 01:03:44,280
В нем очень много поддержанных функций по сравнению с

945
01:03:44,280 --> 01:03:44,980
http.

946
01:03:45,860 --> 01:03:50,960
Этот движок вшит в Android 14 и далее, и вот это интересно.

947
01:03:51,860 --> 01:03:57,00
Под названием, правда, не кронета, а http engine, я предполагаю,

948
01:03:57,260 --> 01:04:00,860
информация не точная, что это шажок в сторону того,

949
01:04:00,860 --> 01:04:04,540
как сделанного IOS, а у них хороший сетевой движок

950
01:04:04,540 --> 01:04:09,960
вшит в систему, а «лишние настройки» скрыты.

951
01:04:13,840 --> 01:04:19,700
Кронет имеет нативную и быструю реализацию, видимо

952
01:04:19,700 --> 01:04:21,60
быстрее, чем накотлина.

953
01:04:22,840 --> 01:04:26,600
Еще из интересного, он может писать восхитительный

954
01:04:26,600 --> 01:04:27,160
лог.

955
01:04:27,160 --> 01:04:30,600
То есть через него удобно посмотреть буквально на

956
01:04:30,600 --> 01:04:34,400
все, что касается сетевого взаимодействия, от деталей

957
01:04:34,400 --> 01:04:39,300
согласования протокола, LPN или еще что, до джейсонов

958
01:04:39,300 --> 01:04:39,860
ответов.

959
01:04:40,160 --> 01:04:43,120
Это делается через хром-браузер, через специальное средство

960
01:04:43,120 --> 01:04:44,600
просмотра лога.

961
01:04:46,400 --> 01:04:49,200
Но если он такой крутой, то почему мало кто о нем

962
01:04:49,200 --> 01:04:49,700
слышал.

963
01:04:55,660 --> 01:04:58,680
Наверное, где-то во внутренней документации Google про него

964
01:04:59,680 --> 01:05:02,760
есть информация, но в интернете ее мало.

965
01:05:04,280 --> 01:05:06,920
Документация, которую дает Google, очень скудная.

966
01:05:08,60 --> 01:05:10,820
По сути, то, что написано в джава-доках, в исходниках,

967
01:05:11,40 --> 01:05:12,180
это лучшее, что есть.

968
01:05:13,120 --> 01:05:15,980
Хотя бы исходники открыты, это, конечно, хорошо.

969
01:05:16,740 --> 01:05:19,720
Но от Гугла есть только пару небольших страничек

970
01:05:19,720 --> 01:05:24,660
на девелопер с Android, где мало чего рассказано.

971
01:05:26,400 --> 01:05:29,60
Местами этот кронет не так гибко настраивается,

972
01:05:29,240 --> 01:05:33,640
как и QHTTP, но местами, наоборот, даже более гибко.

973
01:05:34,740 --> 01:05:37,440
Не сказать, что это проигрыш.

974
01:05:38,820 --> 01:05:41,100
Проигрыш у него в том, что он много весит.

975
01:05:42,00 --> 01:05:46,940
К весу АПК добавляется сразу мегабайт 5-6, но это

976
01:05:46,940 --> 01:05:49,200
только если нет гугл-сервисов на устройство.

977
01:05:50,380 --> 01:05:52,920
Если они есть, то можно привязаться к ним, и тогда

978
01:05:52,920 --> 01:05:55,440
дополнительного веса там вообще не будет, пару килобайт.

979
01:05:57,300 --> 01:06:01,680
Такой подход усложняет разработку, вносит какую-то

980
01:06:01,680 --> 01:06:02,640
неопределенность.

981
01:06:03,400 --> 01:06:06,360
Нам нужно под разные магазины приложений распространять

982
01:06:06,360 --> 01:06:10,940
разные версии приложения, с разными сетевыми клиентами.

983
01:06:10,940 --> 01:06:18,620
А еще со встроенной версией есть небольшой нюанс, она

984
01:06:18,620 --> 01:06:21,260
может быть старовата.

985
01:06:22,730 --> 01:06:25,520
Гугл-сервисы не обновлялись какое-то время, и кронет

986
01:06:25,520 --> 01:06:26,500
в них устарел.

987
01:06:27,120 --> 01:06:30,760
И тогда там доступных функций меньше, чем в новой версии,

988
01:06:32,200 --> 01:06:36,260
и преимущества кронета частично теряются.

989
01:06:36,260 --> 01:06:40,620
Представьте, вы захотели использовать cronet, а он http3

990
01:06:40,620 --> 01:06:41,360
не поддерживает.

991
01:06:46,920 --> 01:06:51,300
Здесь есть хороший выход, можно использовать fallback

992
01:06:51,300 --> 01:06:55,240
на okhttp, когда встроенный cronet недоступен.

993
01:06:57,00 --> 01:07:00,300
Так можно не делать разные сборки, и это, на мой взгляд,

994
01:07:00,560 --> 01:07:04,200
весьма валидная схема, особенно в сочетании с

995
01:07:04,200 --> 01:07:08,780
СКТОР, в котором мы можем спокойно заменять сетевые

996
01:07:08,780 --> 01:07:09,220
движки.

997
01:07:10,720 --> 01:07:12,560
Этот подход в документации продвигают.

998
01:07:14,480 --> 01:07:20,00
Я говорю особенно в сочетании СКТОР, а у CRONET до сих пор

999
01:07:20,00 --> 01:07:25,640
нет официальной интеграции СКТОР, поэтому в конце презентации

1000
01:07:25,640 --> 01:07:29,800
я дам ссылочку на написанную мной интеграцию, с которой

1001
01:07:29,800 --> 01:07:30,620
можно поиграться.

1002
01:07:30,620 --> 01:07:33,300
Она вроде умеет делать запросы, в том числе почтить

1003
01:07:33,300 --> 01:07:33,660
в Питере.

1004
01:07:35,240 --> 01:07:37,920
Но за стабильность и правильность я не отвечаю, что-то там

1005
01:07:37,920 --> 01:07:38,560
точно не так.

1006
01:07:40,920 --> 01:07:44,480
В общем, вариантов много, и настроили мы все круто,

1007
01:07:44,860 --> 01:07:48,240
но начали запускать наше приложение, данные полетели,

1008
01:07:48,680 --> 01:07:51,920
а мы не знаем, от кого они нам полетели, потому что

1009
01:07:51,920 --> 01:07:54,160
пользователи отличать друг от друга не умеем.

1010
01:07:55,500 --> 01:07:59,340
И сейчас я покажу, как можно эту проблему решить.

1011
01:07:59,340 --> 01:08:05,860
Для небольших проектов нужны аутентификация и

1012
01:08:05,860 --> 01:08:06,560
авторизация.

1013
01:08:07,160 --> 01:08:10,480
Аутентификация позволяет подтвердить, что пользователь

1014
01:08:10,940 --> 01:08:12,680
тот, за кого себя выдает.

1015
01:08:12,900 --> 01:08:18,440
Авторизация говорит, какие этому пользователю доступны

1016
01:08:18,440 --> 01:08:18,980
действия.

1017
01:08:21,300 --> 01:08:26,220
Обычно эти вещи идут в паре, но вопросами раздачи доступов

1018
01:08:26,220 --> 01:08:30,640
Мобильные разработчики обычно не занимаются, а

1019
01:08:30,640 --> 01:08:35,220
если занимаются, то надо срочно чинить, потому что

1020
01:08:35,220 --> 01:08:37,360
приложение на мобильном устройстве находится в

1021
01:08:37,360 --> 01:08:43,40
недоверенной среде и никакими доступами со своей стороны

1022
01:08:43,40 --> 01:08:45,60
управлять не может.

1023
01:08:45,940 --> 01:08:49,480
Злоумышленник может пересобрать приложение, убрать оттуда

1024
01:08:49,480 --> 01:08:54,160
Ивчик, который закрывал секретные функции и все

1025
01:08:54,160 --> 01:08:56,120
эти функции более несекретные.

1026
01:08:57,360 --> 01:09:00,160
С сервером злоумышленник такое провернуть не может,

1027
01:09:00,300 --> 01:09:04,800
потому что сервер в безопасности физический и дверь к нему

1028
01:09:04,800 --> 01:09:05,320
закрыта.

1029
01:09:08,880 --> 01:09:11,960
Есть вообще разные способы аутентификации и самый

1030
01:09:11,960 --> 01:09:17,80
простой, он называется Basic, заключается в передаче

1031
01:09:17,80 --> 01:09:19,920
в заголовке авторизейшн закодированные способом

1032
01:09:19,920 --> 01:09:21,180
base64 строки.

1033
01:09:22,820 --> 01:09:28,220
Эту строку любой, кто знаком с base64, может раскодировать

1034
01:09:28,220 --> 01:09:31,560
обратно в логин и пароль, если доберется до этой

1035
01:09:31,560 --> 01:09:31,940
строки.

1036
01:09:34,580 --> 01:09:38,280
Если мы делаем запросы по HTTPS и у нас активно свежая

1037
01:09:38,280 --> 01:09:44,840
версия TLS, то кто-то со стороны, наверное, не сможет добраться

1038
01:09:44,840 --> 01:09:49,20
до наших сокровенных данных, но что, если вдруг доберется,

1039
01:09:50,240 --> 01:09:51,740
что если мы чего-то не учтем.

1040
01:09:53,400 --> 01:09:56,200
Поэтому в иллюстрационных целях или в контролируемой

1041
01:09:56,200 --> 01:09:58,360
среде такой подход окей.

1042
01:09:59,880 --> 01:10:03,260
То есть, если я пишу приложение для себя, я могу себе это

1043
01:10:03,260 --> 01:10:06,900
позволить, я осознаю риски, но в реальном промышленном

1044
01:10:06,900 --> 01:10:09,180
масштабе риск передавать логин и пароль в открытом

1045
01:10:09,180 --> 01:10:11,620
виде слишком высок, так нельзя делать.

1046
01:10:11,620 --> 01:10:16,860
У большинства людей во всех сервисах один и тот же пароль,

1047
01:10:17,160 --> 01:10:20,700
например, и его утечка просто недопустима.

1048
01:10:21,220 --> 01:10:23,680
Это только одна из причин, самая поверхностная.

1049
01:10:24,780 --> 01:10:27,880
На самом деле в этом заголовке, в авторизейшн, можно передавать

1050
01:10:27,880 --> 01:10:31,960
что угодно, что позволит вам понять, кто посылает

1051
01:10:31,960 --> 01:10:34,360
запрос и какие ему доступны действия.

1052
01:10:34,500 --> 01:10:36,340
Это вы уже будете решать на бэкэнделе.

1053
01:10:37,740 --> 01:10:42,460
Может быть, вы сгенерировали километровый токен, отдали

1054
01:10:42,460 --> 01:10:45,700
его другу на флешке, лично в руки, и вот когда он к

1055
01:10:45,700 --> 01:10:48,760
вам с этим токеном придет на быконт, вы скажете, ну,

1056
01:10:48,860 --> 01:10:51,640
я его знаю, понятно, кто пришел, понятно, что ему

1057
01:10:51,640 --> 01:10:52,340
можно делать.

1058
01:10:53,80 --> 01:10:54,600
Ну, конечно, если он не потерял флешку.

1059
01:10:55,380 --> 01:10:58,960
Суть такая, главное понять, кто и что может делать.

1060
01:11:01,120 --> 01:11:04,580
Чтобы логин и пароль в открытом виде не передавать, существуют

1061
01:11:04,580 --> 01:11:09,720
более продвинутые протоколы, и они еще поддерживаются

1062
01:11:09,720 --> 01:11:13,900
всякими двухфакторными аутентификациями, чтобы

1063
01:11:14,800 --> 01:11:15,500
понадежнее быть.

1064
01:11:16,320 --> 01:11:19,700
Встречается на Android не так много вариантов, я бы сказал

1065
01:11:19,700 --> 01:11:20,80
мало.

1066
01:11:20,600 --> 01:11:23,740
Относительно Basic есть более безопасный и продвинутый

1067
01:11:23,740 --> 01:11:27,660
способ под названием Digest, но у него есть ряд недостатков

1068
01:11:27,660 --> 01:11:29,880
и получается ни рыба, ни мясо.

1069
01:11:31,840 --> 01:11:39,580
Самый распространенный и продвинутый способ авторизации

1070
01:11:39,580 --> 01:11:40,680
это ОАУС-2.0.

1071
01:11:41,920 --> 01:11:45,720
Как обычно бывает с продвинутыми вещами, их сложно реализовать

1072
01:11:46,750 --> 01:11:51,40
и сложно настроить, и в этом, наверное, главный минус,

1073
01:11:51,300 --> 01:11:52,940
а иначе все бы ими пользовались.

1074
01:11:56,190 --> 01:11:58,940
Мы подошли к последнему содержательному слайду

1075
01:11:58,940 --> 01:12:01,120
лекции, я подсвечу куда смотреть по поводу еще

1076
01:12:01,120 --> 01:12:03,600
пары важных моментов в качестве напутствия.

1077
01:12:04,760 --> 01:12:08,60
Значительно снизить количество запросов на ваш бэкэнд

1078
01:12:08,60 --> 01:12:09,520
помогает кэширование.

1079
01:12:10,200 --> 01:12:14,20
Оно доступно вам, когда ресурсы продолжительное

1080
01:12:14,20 --> 01:12:15,220
время не изменяются.

1081
01:12:16,280 --> 01:12:19,180
То есть был вопрос, если у вас реально на каждый

1082
01:12:19,180 --> 01:12:25,660
запуск нужно понять текущее состояние в данную секунду,

1083
01:12:25,740 --> 01:12:28,300
в данный час, тогда кэширование — это не ваш вариант.

1084
01:12:28,300 --> 01:12:32,600
А если ресурс живет, скажем, сутки, тогда это ваш вариант.

1085
01:12:33,380 --> 01:12:39,120
Настрой с кэшированием можно через okhttpclientbuilder.Cache или

1086
01:12:39,120 --> 01:12:42,540
через ctore.Install.Httpcache.

1087
01:12:46,200 --> 01:12:49,680
Повторюсь, старайтесь держать один экземпляр сетевого

1088
01:12:49,680 --> 01:12:51,320
клиента на все приложение.

1089
01:12:52,620 --> 01:12:56,660
Здесь довольно хитро себя ведут библиотеки загрузки

1090
01:12:56,660 --> 01:12:57,340
картинок.

1091
01:12:57,980 --> 01:13:00,320
Если в нее не передать клиента, она себе заведет

1092
01:13:00,320 --> 01:13:06,80
свой вообще с нуля, а это неэффективно и ведет к пустой

1093
01:13:06,80 --> 01:13:08,120
потере ресурсов, причем значительных.

1094
01:13:09,840 --> 01:13:10,780
Вот и все.

1095
01:13:11,300 --> 01:13:13,940
Спасибо большое, что посмотрели эту лекцию до конца.

1096
01:13:14,560 --> 01:13:18,100
Она была непростой, наверное, но зато теперь у вас есть

1097
01:13:18,100 --> 01:13:20,300
информация, и я уверен, что вы сможете сделать

1098
01:13:20,300 --> 01:13:27,240
крутые и качественные проекты. Домашние задания и полезные ссылки я выложил по QR-коду,

1099
01:13:28,80 --> 01:13:36,500
а сейчас задавайте вопросы на хаслайт, я постараюсь на них ответить. Если у вас вдруг возникнут

1100
01:13:36,500 --> 01:13:42,200
вопросы потом, например завтра, а не сейчас, то не стесняйтесь написать мне в телегу,

1101
01:13:42,200 --> 01:13:43,860
я по мере сил постараюсь ответить.

1102
01:13:46,460 --> 01:13:47,300
Пошел читать.

1103
01:14:02,670 --> 01:14:07,450
Так, начну с такого, какие протоколы используются

1104
01:14:07,450 --> 01:14:11,10
в Яндекс.Музыке, используются ли для проигрывания музыки

1105
01:14:11,10 --> 01:14:12,370
подкастов UDP?

1106
01:14:14,370 --> 01:14:23,50
У нас в музыке несколько сетевых клиентов, но это

1107
01:14:23,950 --> 01:14:24,830
оправдано.

1108
01:14:26,190 --> 01:14:31,790
У нас есть сетевой клиент, который выполняет обычные

1109
01:14:31,790 --> 01:14:36,490
запросы, какие-то обычные, данные экрана, лайки, дизлайки,

1110
01:14:38,390 --> 01:14:41,370
получение информации о том, какие треки нужно

1111
01:14:41,370 --> 01:14:45,290
будет играть следующим, и есть еще клиент, который

1112
01:14:45,290 --> 01:14:50,110
занимается непосредственно загрузкой этого файла с

1113
01:14:50,110 --> 01:14:50,570
треком.

1114
01:14:51,490 --> 01:14:53,530
Там уже накручено очень много всего.

1115
01:14:57,110 --> 01:14:58,370
Какие протоколы?

1116
01:14:59,610 --> 01:15:05,650
Протокол там HTTP, не UDP, ничего такого.

1117
01:15:05,650 --> 01:15:12,110
Но для основных запросов у нас http2, а для скачивания

1118
01:15:12,110 --> 01:15:17,450
файлов, по-моему, до сих пор http1.1, потому что файлы

1119
01:15:17,450 --> 01:15:21,630
являются обособленной вещью.

1120
01:15:24,210 --> 01:15:28,250
К ним нужен специфичный подход, они долго скачиваются,

1121
01:15:28,250 --> 01:15:32,90
им не нужно мультиплексирование, нужно скачать файл один.

1122
01:15:32,90 --> 01:15:35,990
Поэтому не парились с поднятием версии.

1123
01:15:38,730 --> 01:15:45,810
Картинки загружаются по HTTP2 в основном, на HTTP3 пока

1124
01:15:45,810 --> 01:15:49,730
перейти не можем, слишком много в инфраструктуре

1125
01:15:49,730 --> 01:15:52,110
завязано на TCP и HTTP2.

1126
01:15:55,970 --> 01:15:59,310
Как часто в Яндекс.Музыке используется ProtoBuf?

1127
01:16:02,930 --> 01:16:05,750
У нас есть такая вещь, когда можно с телефона управлять

1128
01:16:05,750 --> 01:16:08,950
телевизором или другим телефоном, когда вы в один

1129
01:16:08,950 --> 01:16:09,670
аккаунт вошли.

1130
01:16:10,630 --> 01:16:13,390
Там используется gRPC и ProtoBuf.

1131
01:16:13,390 --> 01:16:19,930
Есть у нас подсистема, в которой используется стриминг

1132
01:16:19,930 --> 01:16:20,670
из gRPC.

1133
01:16:22,670 --> 01:16:24,910
Там гоняются данные в формате спиртомаффины.

1134
01:16:31,450 --> 01:16:34,750
В чем разница между REST и RESTful?

1135
01:16:35,690 --> 01:16:39,790
Хороший вопрос, если бы я знал на него точный ответ.

1136
01:16:40,730 --> 01:16:48,210
Иногда бытует мнение, что REST — это технология, протокол,

1137
01:16:48,450 --> 01:16:49,250
подход.

1138
01:16:49,630 --> 01:16:59,250
А RESTful — это то, что ваша API конкретно является REST-овой,

1139
01:16:59,970 --> 01:17:04,570
то есть RESTful — API, но REST — подход, может быть так,

1140
01:17:04,770 --> 01:17:05,870
но могу и соврать.

1141
01:17:05,870 --> 01:17:12,290
Вообще эти понятия очень взаимозаменяемы.

1142
01:17:16,670 --> 01:17:19,890
Ретрофит экземпляра лучше переиспользовать или не

1143
01:17:19,890 --> 01:17:20,730
переиспользовать.

1144
01:17:22,270 --> 01:17:26,530
Там и настроить тайм-аут, протоколы и так далее, как

1145
01:17:26,530 --> 01:17:27,770
у KHTTP.

1146
01:17:32,510 --> 01:17:37,190
Я не уверен, насколько можно в ретрофите настроить протоколы,

1147
01:17:40,150 --> 01:17:45,50
но лучше переиспользовать объекты ретрофита, если

1148
01:17:45,50 --> 01:17:52,450
у вас базовый URL в приложении один, потому что объект

1149
01:17:52,450 --> 01:18:02,110
ретрофита зависит от базового URL. Переиспользовать один объект для разных URL вы не сможете,

1150
01:18:02,530 --> 01:18:09,570
а для одного лучше переиспользовать. Настраивать я бы стал QHTTP. В Retrofit передать

1151
01:18:09,570 --> 01:18:15,370
есть по минимуму URL-конверторы, если у вас есть кастомные

1152
01:18:15,370 --> 01:18:15,890
парсеры.

1153
01:18:21,510 --> 01:18:29,410
В Protobuf есть проблема с присваиванием NULL полям, как семантически

1154
01:18:29,410 --> 01:18:30,950
и практически это решать.

1155
01:18:33,570 --> 01:18:40,90
Присваивание null полям в протобафе не особо возможно,

1156
01:18:40,530 --> 01:18:44,610
только message можно присвоить null, если у поля тип message.

1157
01:18:46,210 --> 01:18:49,590
Примитивным типом null присвоить нельзя, то есть если написать

1158
01:18:49,590 --> 01:18:56,390
например int32 или int64 какой-то поля, то null в него нельзя

1159
01:18:56,390 --> 01:18:59,270
присвоить, но у него есть дефолтное значение равное

1160
01:18:59,270 --> 01:18:59,550
нулю.

1161
01:19:01,530 --> 01:19:05,810
В этом и заключается сложность прото-бафа.

1162
01:19:08,330 --> 01:19:12,170
Может, проблема с NULL'ами — это из версии синтаксиса

1163
01:19:12,170 --> 01:19:14,610
2, а там сейчас версия синтаксиса 3.

1164
01:19:18,70 --> 01:19:22,770
Если есть NULL, то надо проверять на NULL, по-другому, как решить,

1165
01:19:22,930 --> 01:19:23,510
не знаю.

1166
01:19:27,770 --> 01:19:31,790
Как реализована мультиплатформенность в КТОР?

1167
01:19:35,530 --> 01:19:44,170
За счет того, что КТОР — это обертка над движком, плюс

1168
01:19:44,170 --> 01:19:51,950
плагины, плюс экологика, это обертка, за счет этого

1169
01:19:51,950 --> 01:19:54,790
она написана на чистом код-лине и у нее нет проблем

1170
01:19:54,790 --> 01:19:55,770
с мультиплатформой.

1171
01:19:59,310 --> 01:20:04,290
А все, что у платформы зависимо, подставляется в него на

1172
01:20:04,290 --> 01:20:06,150
стороне платформенного сурсета.

1173
01:20:11,850 --> 01:20:15,770
Старые API до 10-го андроида и новые по-разному реагируют

1174
01:20:15,770 --> 01:20:16,570
на сертификаты.

1175
01:20:19,50 --> 01:20:22,270
Новые API позволяют работать с ними, а старые нет.

1176
01:20:22,290 --> 01:20:23,610
Сталкивались ли вы с таким?

1177
01:20:24,450 --> 01:20:26,590
Я лично не сталкивался.

1178
01:20:27,230 --> 01:20:31,10
Здесь скорее всего дело в том, какие корневые сертификаты

1179
01:20:31,10 --> 01:20:32,270
зашиты на устройство.

1180
01:20:36,370 --> 01:20:41,10
Это относится к слайду про телоспиннинг, про корневые

1181
01:20:41,10 --> 01:20:41,750
сертификаты.

1182
01:20:44,650 --> 01:20:48,570
Вполне возможно, что в мире появляются новые доверенные

1183
01:20:49,570 --> 01:20:56,410
надежные центры корневые сертификации, и такие новые

1184
01:20:56,410 --> 01:20:59,410
центры на старые андроиды, скорее всего, не попадают.

1185
01:20:59,410 --> 01:21:12,950
Как это чинить, даже не знаю, либо просить всех пользователей

1186
01:21:12,950 --> 01:21:18,350
устанавливать сертификат, либо все-таки менять провайдера

1187
01:21:19,90 --> 01:21:19,870
сертификатов.

1188
01:21:31,510 --> 01:21:34,710
Какие есть рекомендации от самого Гугла по использованию

1189
01:21:34,710 --> 01:21:36,810
протоколов, движков, реймворков и прочего?

1190
01:21:42,90 --> 01:21:44,490
Я бы не сказал, что очень много рекомендаций.

1191
01:21:44,490 --> 01:21:50,10
Он всегда рекомендовал со звездочкой в QHTTP.

1192
01:21:53,230 --> 01:21:57,770
На страничке CRONET написано, что это крутой сетевой

1193
01:21:57,770 --> 01:22:01,370
движок, который берите, используйте, он вообще

1194
01:22:01,370 --> 01:22:02,110
все умеет.

1195
01:22:03,870 --> 01:22:06,90
Считается ли это рекомендацией?

1196
01:22:06,190 --> 01:22:06,570
Да.

1197
01:22:06,570 --> 01:22:14,110
В принципе, конкретных рекомендаций по технологии

1198
01:22:14,280 --> 01:22:17,350
по конкретной библиотеке у Гугла, наверное, все-таки

1199
01:22:17,350 --> 01:22:17,750
нет.

1200
01:22:27,950 --> 01:22:32,370
У Гугла есть множество рекомендаций по тому, как

1201
01:22:32,370 --> 01:22:38,250
их выстроить архитектуру, чтобы она эффективно соотносилась

1202
01:22:38,250 --> 01:22:41,430
с клиент-серверной природой приложения.

1203
01:22:57,970 --> 01:23:02,770
Как работает кэш в запросах и как проверяется валидность

1204
01:23:02,770 --> 01:23:03,290
кэша.

1205
01:23:07,710 --> 01:23:11,430
На словах я не смогу, конечно, показать, какие там заголовки

1206
01:23:11,430 --> 01:23:15,470
нужно передавать, но в целом работает это так.

1207
01:23:15,690 --> 01:23:19,10
Клиент делает на сервер запрос, кэшируются обычно

1208
01:23:19,710 --> 01:23:20,730
гет-запросы.

1209
01:23:22,370 --> 01:23:25,170
Клиент делает запрос, хочет получить список треков,

1210
01:23:26,270 --> 01:23:28,10
и сервер ему их возвращает.

1211
01:23:28,10 --> 01:23:34,10
Но сервер в ответ добавляет заголовок, что вот этот

1212
01:23:34,10 --> 01:23:38,170
ответ можно не переспрашивать в течение двух дней.

1213
01:23:38,710 --> 01:23:42,890
Сервер говорит, сколько времени его можно не переспрашивать,

1214
01:23:44,150 --> 01:23:44,590
и все.

1215
01:23:44,930 --> 01:23:48,170
А далее клиент уже на своей стороне смотрит, если заголовок

1216
01:23:48,170 --> 01:23:54,890
есть, то окей, я складываю этот ответ в файлик, потом

1217
01:23:54,890 --> 01:24:00,610
из файлика читаю, но не дольше двух дней, вот такая логика.

1218
01:24:00,890 --> 01:24:04,610
Эта логика находится внутри Okhttp, либо плагина для Ktor.

1219
01:24:07,170 --> 01:24:15,90
Проверяется ли там валидность, я не до конца понимаю, что

1220
01:24:15,90 --> 01:24:20,730
за валидность, но если вы поменяли свои модели или

1221
01:24:20,730 --> 01:24:26,50
поменяли апишку, то сохраненный ответ этого не учитывает,

1222
01:24:26,250 --> 01:24:30,410
он не знает, что у вас что-то поменялось, он будет лежать

1223
01:24:30,410 --> 01:24:30,870
дальше.

1224
01:24:36,830 --> 01:24:42,90
И связанный вопрос, сохраняется ли полноценный объект при

1225
01:24:42,90 --> 01:24:45,370
использовании кэширования и куда сохраняются данные

1226
01:24:45,370 --> 01:24:48,710
под капотом библиотеки при кэшировании.

1227
01:24:50,670 --> 01:24:57,510
Это зависит от библиотеки, например, KHTTP, насколько

1228
01:24:57,510 --> 01:25:02,450
я знаю, создает бинарные файлы с содержимым ответа,

1229
01:25:04,10 --> 01:25:11,370
то есть это не DTO, DTO не кэшируется, кэшируется бинарное содержимое

1230
01:25:11,370 --> 01:25:12,690
ответа и потом достается.

1231
01:25:14,410 --> 01:25:17,910
Как это работает в Ктор, я, честно говоря, не смотрел,

1232
01:25:19,770 --> 01:25:24,630
а Кронет тоже пишет файлы, говоришь ему, куда писать

1233
01:25:24,630 --> 01:25:26,670
файлы, он их пишет, тоже бинарные.

1234
01:25:28,550 --> 01:25:32,230
Надеюсь, что ответил и надеюсь, что правильно.

1235
01:25:47,830 --> 01:25:51,230
Переформулирую чуть-чуть вопрос, какой базовый движок

1236
01:25:51,230 --> 01:25:55,890
у Tor Client, есть будто бы какой-то движок под названием Android,

1237
01:25:56,650 --> 01:25:59,430
можно вообще не указывать движок и что тогда будет.

1238
01:26:00,890 --> 01:26:07,50
В документации КТОР есть ответ, что движок Android — это

1239
01:26:07,50 --> 01:26:17,230
не Cronet, для Cronet нет реализации адаптера из КТОР в Cronet официального.

1240
01:26:20,150 --> 01:26:27,530
Скорее всего, по умолчанию КТОР использует стандартные

1241
01:26:27,530 --> 01:26:34,950
штуки из андроид-фреймворка под названием url-request, стандартные

1242
01:26:34,950 --> 01:26:36,310
библиотечные методы.

1243
01:26:36,890 --> 01:26:40,530
Там речи не идет ни о каком переиспользовании соединений,

1244
01:26:41,290 --> 01:26:46,10
настройки довольно скудные, я бы не стал использовать

1245
01:26:47,990 --> 01:26:49,950
стандартный либо андроидовский движок.

1246
01:26:49,950 --> 01:26:55,830
Еще есть движок CIO, но он тоже не суперэффективный.

1247
01:26:55,970 --> 01:27:01,430
OKHCTP лучше всего, либо CRONET, в принципе, всего две опции

1248
01:27:01,430 --> 01:27:02,210
есть адекватных.

1249
01:27:06,30 --> 01:27:09,870
В видео по оптимизации трат батареи от Google сказано,

1250
01:27:10,30 --> 01:27:14,890
что нужно стаковать запросы в интернет, чтобы радиочип

1251
01:27:14,890 --> 01:27:15,950
меньшее время работал.

1252
01:27:25,250 --> 01:27:28,30
Действительно, антенна на телефоне жрет очень много

1253
01:27:28,30 --> 01:27:32,130
энергии, и у нее есть разные состояния.

1254
01:27:32,730 --> 01:27:35,730
Она может находиться в режиме ожидания и потреблять

1255
01:27:35,730 --> 01:27:39,430
мало энергии, а может выполнять запросы и потреблять много

1256
01:27:39,430 --> 01:27:39,930
энергии.

1257
01:27:42,550 --> 01:27:44,970
Кто стакует эти запросы?

1258
01:27:45,930 --> 01:27:46,710
Только мы.

1259
01:27:47,970 --> 01:27:51,790
Если наши приложения сейчас в руках у телефона, то это

1260
01:27:51,790 --> 01:27:54,750
наша ответственность, и фактически никто их не

1261
01:27:54,750 --> 01:27:55,210
стакует.

1262
01:27:56,990 --> 01:28:01,490
Если говорить о фоновых приложениях, то там включается

1263
01:28:01,490 --> 01:28:06,490
фича под названием Dose Mode, которая разрешает приложениям

1264
01:28:06,490 --> 01:28:08,910
делать запросы только в строго отведенные промежутки

1265
01:28:08,910 --> 01:28:11,610
времени, и там за это отвечает система.

1266
01:28:21,390 --> 01:28:26,250
Когда имеет смысл создавать несколько QHTTP-клайентов

1267
01:28:26,250 --> 01:28:27,110
на приложении?

1268
01:28:32,370 --> 01:28:35,190
В довольно узких случаях.

1269
01:28:37,450 --> 01:28:41,690
Например, бывает сценарий, что вы загружаете картинки

1270
01:28:41,690 --> 01:28:48,630
с какого-нибудь статического S3-сервера, у которого очень

1271
01:28:48,630 --> 01:29:02,70
много субдоменов, и эти субдомены будут забивать

1272
01:29:02,70 --> 01:29:07,470
коннекшен пулл в QHTTP, вы загрузите пять картинок, у вас откроются

1273
01:29:07,470 --> 01:29:09,970
пять коннекшенов, и весь пулл забьется.

1274
01:29:11,370 --> 01:29:16,870
А ваше API приложение, которое один домен, которое все

1275
01:29:16,870 --> 01:29:21,530
хорошо, оно возьмет и вылетит из пулла, и это не круто.

1276
01:29:22,530 --> 01:29:26,570
В такой ситуации для загрузчика картинок можно выделить

1277
01:29:26,570 --> 01:29:27,470
отдельный клиент.

1278
01:29:28,810 --> 01:29:36,930
Но можно даже здесь пойти немножко дальше и выделить

1279
01:29:36,930 --> 01:29:41,450
этот клиент не полностью новый, а с переиспользованием

1280
01:29:41,970 --> 01:29:47,510
всего, всех составляющих основного HTTP-клиента, но

1281
01:29:47,510 --> 01:29:51,610
с новым connection pool, с теми же диспатчерами, с теми

1282
01:29:51,610 --> 01:29:59,590
же интерсепторами, с теми же SSL socket factory и прочими

1283
01:29:59,590 --> 01:30:06,790
штуками, но с другим connection pool, если много разных доменов.

1284
01:30:09,610 --> 01:30:12,390
Еще нюанс может быть с версией протокола.

1285
01:30:14,990 --> 01:30:19,450
Это то, что у нас происходит, если основная API работает

1286
01:30:19,450 --> 01:30:28,410
на Http2, а мы хотим какие-то запросы выполнять по Http1 и

1287
01:30:28,410 --> 01:30:28,610
1.

1288
01:30:30,670 --> 01:30:37,790
Если мы передадим оба протокола в списке при запросе на

1289
01:30:37,790 --> 01:30:47,410
сервер, я поддерживаю Http1, Http2, сервер может сам выбрать

1290
01:30:47,410 --> 01:30:52,170
какой протокол он захочет, какой он считает более хорошим.

1291
01:30:54,70 --> 01:30:56,530
Поэтому если вы, например, какие-то запросы хотите

1292
01:30:56,530 --> 01:31:02,70
конкретно провести по HTTP 1.1, то тоже, может быть,

1293
01:31:02,450 --> 01:31:04,630
придется завести отдельный HTTP-клиент.

1294
01:31:09,390 --> 01:31:13,690
И последний вопрос, который я вижу, чем CTOR отличается

1295
01:31:13,690 --> 01:31:21,810
от CtorFit, насколько я слышал, я, честно говоря, про CtorFit

1296
01:31:21,810 --> 01:31:22,590
очень мало знаю.

1297
01:31:23,150 --> 01:31:26,330
Насколько я слышал, ну CtorFit это просто какое-то упрощение

1298
01:31:27,110 --> 01:31:31,390
для миграции с Retrofit в мультиплатформу, то есть вот та проблема,

1299
01:31:31,390 --> 01:31:34,130
о которой я говорил, что на Retrofit запросы нельзя

1300
01:31:34,130 --> 01:31:37,310
перетащить в мультиплатформу, вроде бы там выступает

1301
01:31:37,310 --> 01:31:40,190
CtorFit, но, честно говоря, могу обмануть, я прям про

1302
01:31:40,190 --> 01:31:41,410
эту библиотеку мало знаю.

1303
01:32:03,10 --> 01:32:09,410
Ну ладно, наверное, я на все ответил. Всем хорошего вечера, спасибо еще раз, что пришли