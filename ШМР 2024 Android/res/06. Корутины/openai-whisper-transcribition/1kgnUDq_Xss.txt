Редактор субтитров А.Синецкая Корректор А.Егорова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
в этой функции наша крутина может быть остановлена.
Вот и все.
После того, как данная функция будет скомпилирована окончательно,
она немножечко трансформируется в не совсем читаемый для нас вид,
но как раз компилятор сделает вывод из того, что функция является suspend
и сделает определенные доработки нашего кода,
которые позволят нам в определенный момент останавливать крутину,
а потом ее возобновлять, то есть доставать из недр наш стек вызовов
всех функций и начинать дальнейшую обработку кода с того места, где мы закончили.
Вот это, наверное, главная мысль, которую нужно вытащить из этого слайда.
Идем дальше.
Какие основные фишки крутин? Почему мы вообще их сегодня рассматриваем,
помимо того, что только что обсудили?
Они соблюдают принцип structure concurrent. Что это значит?
Это значит, что у нас есть возможность выстроить взаимосвязь
между родительскими крутинами и дочерними.
В примере из пятницы я вам показывал, как можно из одного потока создать другие потоки
и запустить их дальше. Вот они живут там у себя и вычисляют что-то,
но мы их особо не контролируем.
Но вот в крутинах есть возможность из родительской крутины достать несколько дочерних,
и у нас будет явная взаимосвязь между ними.
То есть мы в любой момент из родительской крутины сможем узнать, какие у нее есть дочерние,
их там, например, отменить, узнать какой-то дополнительный статус и так далее.
Опять же, чуть позже сегодня в рамках лекции мы увидим примеры.
И вот такая взаимосвязь позволяет нам грамотно устроить, точнее,
выстроить такую каскадную модель отмены всех крутин или обработку ошибок.
Опять же, чуть позже в рамках лекции мы посмотрим, как это делается.
Что еще из плюсов для нас, как для Android разработчиков?
У нас есть отличная полноценная поддержка в Android Jetpack.
То есть практически любая библиотека из Jetpackа от Google уже имеет поддержку крутины,
и мы можем этим пользоваться уже довольно давно, мне кажется пару лет точно.
Идем дальше.
Вот до этого мы просто обсудили, что такое крутины, узнали, как они,
точнее, где они могут выполняться в наших suspend функциях.
Но получается так, что есть suspend функции, эти suspend функции могут вызывать другие suspend функции,
но с чего-то же все это должно начинаться, правильно?
Вот. И все это начинается с двух ключевых элементов.
Первое это крутин-билдеры, по названию можно догадаться, что это такие элементы нашего
аппи из крутин, позволяющие создать новые крутины.
Вот. Но особенность в том, что просто так их создать нельзя,
для этого им нужен крутин-скоп.
И давайте как раз с этими двумя элементами мы познакомимся поближе.
Начнем с билдеров. Здесь я перечисляю, наверное,
сам на из них, причем, мне кажется, главный из них это launch и async, run blocking мы
обсудим немножечко всего лишь. Давайте немного посмотрим на примеры.
Начнем с launch. Launch концептуально очень похоже на поток.
Если посмотрите на слайд, увидите, что мы здесь пытаемся запустить две крутины
с помощью launch. Одна крутина у нас делается на секунду и печатает строчку,
вторая делается на две секунды и тоже печатает строчку.
Вот здесь мы в рамках suspend функции main создали две новых крутины, две дочерних крутины.
Вот. И если я здесь поменяю launch на thread, концептуально реально будет одно и то же.
То есть мы что-то запустили, отправили свободное плавание, там что-то выполним,
но нам не важен результат. Вот это вот такая концепция.
Запустили какую-то крутину, не возвращающую нам результат, а что-то делающее у себя полезное.
Вот. Async же, в свою очередь, это скорее крутина, которая возвращает нам результат,
какой-то результат в будущем, отложенный результат.
Вот. Аналогию можно привести с executor и функции submit,
которые мы рассматривали на предыдущей лекции по многопоточности.
Это функция, я имею в виду функция async, она возвращает defret,
который как раз и является таким результатом отложенной операции.
И здесь мы делаем ровно то же самое, что в предыдущем слайде,
только не печатаем строчку, а возвращаем ее после дилея.
И в самой последней строчке мы дожидаемся ответа от двух наших крутин.
Вот. Но главная особенность в отличие от потоков и executor сервиса,
через который мы могли бы ссабмитить задачку, здесь мы крутины приостанавливаем.
То есть мы можем всю эту функцию даже вызвать на Main-потоке и не особо беспокоиться о том,
что мы как-то сильно заблочим основной поток и не дадим возможность ему отрисовывать наш UI.
Потому что сначала мы довольно практически моментально создадим две новых крутины.
Эти крутины могут выполняться на Main-потоке, здесь нам это особо не важно.
Дилей, кстати, это тоже одна из со спин функций, которая не блокирует поток текущий.
Она приостанавливает выполнение текущим потоком и потом возвращает в активное действие текущий
поток спустя то время, которое было передано в функции дилей.
А с самой последней строчкой мы также приостанавливаем наших крутины, дожидаемся ответа
и сама вся функция Main вернет нам результат.
Run blocking – это такой особенный вид крутин билдера. Его отличие в том, что он блокирует основной,
ну или вообще тот поток, на котором был запущен, до тех пор, пока все, что находится внутри его
action кода, то есть внутри лямбдочки, который мы ему передаем, до тех пор он будет заблокирован,
если ждет выполнения той или иной suspend функции или крутины.
В чем еще важная особенность, которую я не назвал, но буквально сейчас это обсудим.
На примере с и Async и с Launch я самой первой строчкой вызываю функцию крутин scope. Почему?
Повторюсь, при создании крутин есть два важных элемента, которые стоит рассмотреть.
Это крутин билдеры, а второе это крутин scope. Так вот, билдеры типа Async и Launch требуют
крутин scope для запуска. По факту они вообще являются extension функциями крутин scope,
и это неспроста. Как раз таки крутин scope нам нужен для того, чтобы быть некой входной точкой в
крутины и явно обозначать ограничительный какой-то момент, ограничительный фактор того,
где наши крутины могут работать и сколько по времени, грубо говоря. То есть мы явно
контролируем жизненный цикл наших крутин с помощью крутин scope. И вот в самих extension
функциях у нас есть довольно много полезных параметров, которые мы точно будем использовать
как на протяжении лекции, так и дальше уже в ходе нашей практики. Первое это крутин контекст.
Довольно важная штука, позволяющая нам из одной крутины передавать данные другой дочерней крутина.
Так как это крутин билдеры, у нас есть возможность от родительской крутины передать всю необходимую
информацию дальше дочерним крутином. Ровно для этого и нужен крутин контекст. Дальше есть параметр
start, крутин start. Он позволяет нам регулировать способ запуска. То есть мы можем крутину создать
не сразу, а лениво. Например, запланировать какую-то задачку в будущем и затем ее в какой-то
момент запустить. Опять же в теме по многопоточности я приводил пример, как я это делал с помощью
concurrent hash map и туда клал наши отложенные задачки. И только потом в какой-то момент запускал.
Ну и конечно же третьим параметром мы передаем саму функцию блок, в которой и будем выполнять
все то, что нужно выполнить текущей крутине. Важно тут подметить, что она является suspend.
Благодаря этому мы сможем внутри блок функции вызывать другие suspend функции и приостанавливать
наши крутины. В завершение по этой теме важно усвоить то, что крутин scope является входной точкой в
крутина. То есть не имея крутин scope у вас практически не получится создать нормальные крутины в самом начале.
То есть выйти из этого нашего обычного мира с обычными функциями в мир крутин. Так что мы
сегодня увидим много примеров, где то тут, то там мы достаем наш крутин scope, либо создаем его
сами вручную и на основе этого крутин scope создаем наши первые крутины. Вообще крутин scope
довольно важная вещь и такая фундаментальная, с нее все и начинается. Что дальше? Дальше то, что наш
крутин scope знает про остальные крутины. Из него информацию можно вытащить через крутин контекст и
как-то косвенно повлиять на другие крутины, либо вытащить мета информацию. В общем сценариев
использованы довольно много. И конечно же у крутин scope есть возможность отменить все дочерние крутины,
которые были созданы в рамках него. Сам интерфейс крутин scope довольно минимален, в общем у него
есть только возможность вытащить крутин контекст, но поверьте нам этого будет достаточно, как раз из
крутин контекста можно вытащить много полезной информации. Давайте попробуем его создать.
Создадим наш первый крутин scope сами вручную. Делается это довольно просто, также как и любой
другой объект. Мы можем создать его с помощью конструктора, передать ему либо пустой крутин
контекст, либо вообще ничего. Из-под коробки как раз и будет создан mt-cruitint-context. А на основе
него дальше мы запускаем, ну во-первых создаем, а потом мы запускаем наши крутины. Ровно это я и
сделал на слайде. Создал scope, на основе scope создал нашу первую крутину. Вот там может быть что-то
полезное сделал, а сама функция launch возвращает нам job. Давайте поймем, что такое job. Job это
абстракция над жизненным циклом крутины. У нее есть возможность отслеживать то, в каком сейчас
состояние она находится и опять же косвенно как-то на нее влиять с помощью API, которая
предоставляет интерфейс job. Тут пишу, что как раз job имеет функцию отмены, это мы будем использовать
дальше в примерах. И что еще интересно, job является элементом крутин контекста. Как помните,
при создании крутин мы передаем крутин контекст, и вот job является одним из элементов крутин контекста,
то есть он является ее частью. Вот как раз явно здесь это и показано. Мы видим, что есть объявлен
интерфейс job, он наследуется от крутин контекст.element, соответственно, является элементом крутин контекста,
и есть полезное API для нас. Первые три свойства — это возможность вытащить информацию о том,
в каком состоянии сейчас находится job и соответственно сама крутина, которой он относится. А также есть
функция start, позволяющая нам запустить крутину до этого созданного лениво, и функцию cancel,
которая позволит нам отменить текущую крутину и все ее дочерние крутины, как мы поймем дальше.
Также есть функция join, это практически аналогия тому, что есть у потоков, когда мы у объекта
потока можем вызывать join и дождаться выполнения текущего потока ровно то же самое крутиной. Мы
можем, имея ссылку на job, заджойниться к ней и дождаться завершения той или иной крутины.
Окей, давайте попробуем подробно рассмотреть, в каких состояниях может быть наша крутина. Первое,
просто разберем все стейты, которые тут есть. Это new, когда мы крутину только создали, active,
когда она уже в активной фазе действия, completing и completed, соответственно, когда она пытается
завершиться или уже завершена, и то же самое с отменой. То есть мы либо в процессе отмены,
либо уже полностью все отменили и крутина уже не активна. И вот информацию о стейтах мы просто
так сами не вытащим, но понимание того, в каком состоянии мы сейчас находимся, мы можем вытащить
с помощью наших properties, с помощью наших свойств. Из active, из cancelled, из completed. Попробую
продемонстрировать как раз на примере. То есть вот допустим, мы только создали нашу крутину,
она сейчас находится в статусе new, соответственно, все флажочки будут возвращать false. Если же мы
перешли в активную фазу действия, то наша крутина выйдет в состояние active, а флажочек из active
будет возвращать true. Итак, по аналогии, на самом деле мы можем разобрать все стейты в момент
завершения, ну попытки завершения, потом в момент непосредственного завершения, дальше в момент
отмены крутин, и после того, как крутина полностью завершилась, мы увидим, что и cancelled true,
и completed true, потому что мы ее попытались отменить и успешно это сделали. Так что с помощью
флажочков можно косвенно понять, что сейчас происходит с крутиной и выполнить какую-то бизнес
логику вокруг этого. Давайте попробуем рассмотреть, как работает JDOB на примерах. Опять же, вернемся
к нашему примеру из предыдущего слайда, где мы просто запускаем наши две крутины. Здесь мы добавляем,
как мы теперь знаем, launch возвращает job, поэтому можем присвоить job1 и job2 к нашим крутинам,
после чего мы дождемся выполнения этих двух их обеих крутин и напечатаем значение, свойств
из наших job. Соответственно, в конце мы увидим и строчки, которые были напечатаны в крутинах,
и статусы каждой из крутин. Из active false, потому что мы крутину уже дождались, и она полностью
выполнила все, что нужно, а из completed true, по яным признакам, крутина завершилась, и из completed
тоже должен быть true. Дальше мы рассмотрим, как еще можно JDOB использовать в коде. Главная его
особенность в том, что есть возможность трека, текущее состояние крутины, ее жизненный цикл. Как я
уже сказал ранее, job является элементом крутин контекста, а что там есть еще? Опять же, мы
поняли, что в крутин скопе есть крутин контекст, и job является крутин контекстом, а что еще? Что
еще там может находиться? Давайте вообще рассмотрим сам интерфейс крутин контекста. Сам по себе
контекст — это такой универсальный способ группировать элементы между собой. Что главное,
стоит выяснить, что крутин контекст передается от родителя к дочерним крутинам, и концептуально
он очень похож на map или set, то есть мы можем обратиться к крутин контексту и вытащить из
него элементы по ключу, а ключом будет являться как раз один из интерфейсов, который наследуется от
крутин контекста точка элемент. То есть мы можем передать какой-то элемент и вытащить текущее
значение по ключу. Крутин контекст определяет поведение крутин, то есть из него мы вытащим
информацию, на каком потоке, например, нужно выполнять ту или иную крутину, какое у нее название,
как мы будем обрабатывать исключения и так далее. То есть это важная контекстная информация,
которая передается от одной крутини к другой. Соответственно, он содержит набор элементов,
которые мы можем вытащить внутри крутин и как-то с ними работать, и есть возможность
переопределять элементы, если нам это потребуется. Сам фреймворк крутин, он это делает на регулярной
основе, каждый раз, когда вы создаете новую крутину, он передает контекст от родительских
дочерней и переопределяет некоторые крутины элементы внутри, например, как раз таки джоб,
мы это посмотрим чуть позже. Из базовых элементов я бы выделил как раз джоб, крутин name, который нам
часто будет необходим просто для дебаг информации или просто если мы хотим вытащить информацию о том,
где мы сейчас находимся, в какой крутине, вот это можно сделать через крутин name. Есть крутин
dispatcher, сегодня его рассмотрим, он необходим для переключения потоков. Есть крутин exception
handler, который необходим нам для обработки исключений, тоже его сегодня обсудим. Как я уже
сказал ранее, есть элемент, который является крутин контекстом, мы в принципе не ограничены тем,
что есть в библиотеке изначально, мы можем объявить свой элемент крутин контекста и его
затащить в текущий крутин контекст в целом. Здесь особо этого делать не будем, это нужно только в
конкретных случаях, просто знайте, что у вас есть такая возможность по аналогии с крутин name,
крутин dispatcher, вы можете создать свой необходимый вам для работы крутин. А здесь же смотрите,
попробую продемонстрировать такой пример. Так как у нас крутин name является элементом крутин
контекста, я попробую это сделать, сработать с крутин name как с элементом крутин контекста,
а потом вытащить из этого крутин контекста по ключу нужное мне значение. То есть первой строчкой я
создаю крутин name, потом к этому же крутин name я обращаюсь к контексту и пытаюсь вытащить
значение имени по ключу. И дальше вытаскиваю как раз имя, а если бы я хотел вытащить какой-то
другой крутин элемент, например job, которого я еще туда не передавал, то логично, что я получу
null. Вот собственно так и происходит. Что дальше? Контексты, как я уже сказал ранее, можно объединять
либо как-то видоизменять. Это и происходит в момент создания крутин. Мы пытаемся получить
текущую мапу этих элементов, потом с ними выполняем определенную логику с помощью функций
fault или дополнительных функций, которые заложены внутри имплементации создания крутин. Мы же можем
это использовать у себя в какой-то бизнес логике, например, захотели на основе текущего крутин контекста
получить копию, но с измененными элементами внутри. Мы это можем сделать ровно так же, как мы это
обычно делаем с мапой. По ключу обращаемся, переименовываем, точнее, переназначаем какой-то
элемент по ключу и идем дальше. Вот ключевой момент, что в билдерах в момент создания наших
крутин происходит ровно то, что я описал. Берется из родительской крутины текущий крутин-контекст,
он используется практически полностью для создания новой дочерней крутины, только еще
создается новый job. Мы это рассмотрим буквально на следующих слайдах. Давайте глянем, как это
выглядит. Смотрите, сначала я пытаюсь создать крутин name и новый крутин элемент job. Их связку,
то есть как раз через плюсик я создаю новый крутин-контекст. Я пытаюсь передать эти данные
в мою новую только что созданную крутину через крутин билдер лаунч. А дальше пытаюсь понять,
а что же у меня с элементами текущего крутин-контекста. Так как я нахожусь внутри
скопа, у меня есть возможность вытащить крутин-контекст и дальше как мапе обратиться и по ключу вытащить нужное
мне значение. Так вот, мы видим, что крутин name в моем случае будет печатать то имя, которое я
изначально заложил. Я получу true. Но в случае, если я захочу получить job, соответствия не будет.
Почему? Потому что при создании новой крутины берется весь крутин-контекст текущий, создается
новый job и присваивается по ключу интерфейса job вот в этот новый крутий-контекст. Главное,
что нужно запомнить, что при вызове и лаунч и ассинк сама система, то есть сам фреймворк,
будет за вас создавать job и делать его наследником всех новых крутин внутри только что созданной.
Получается последней строчкой, я пытаюсь вытащить список детей у текущей крутины,
и первый же элемент будет равен тому job, который я создал ранее. Как раз-таки это сигнализирует о том,
что я вижу то, что есть job, который был создан за меня, а есть job, который создал я сам,
и он будет являться только дочерним, точнее, родительским элементом для только что созданного
job. Этот пример еще разберем чуть дальше, позже, когда будем обсуждать тему отмены крутин и
обработки ошибок, потому что там создание job вместо нас играет ключевую роль и поймем почему.
Итого, у нас крутин-билдеры создают новый job на основе родительского и из крутин-контекста,
а в верхнем уровне вся наша картина выглядит следующим образом. У нас сначала должен быть
крутин-скоп, на этом крутин-скопе у нас есть возможность создать с помощью крутин-билдеров
наши крутины. В лекции и вообще в практике мы будем часто использовать либо launch, либо async.
Дальше внутри этих крутин-билдеров у нас есть возможность работать со suspend функцией,
в рамках которой мы можем вызывать другие suspend функции. Тут уже начался такой
мир suspend функций, в котором мы можем выполнять всю нашу бизнес логику.
А крутин-функции могут вызывать другие части из библиотеки крутин, например,
крутин-скоп-билдеры, как крутин-скоп или vis-контекст, опять же их примеры мы посмотрим чуть
позже, но по факту они являются также suspend функциями, которые и можно вызывать только
внутри контекста других suspend функций. Так что в верхнем уровне, наверное, картина выглядит так.
И, наверное, с фундаментальной частью пока что на этом все. Дальше коснемся темы отмены,
а сейчас попробуем отвечать на вопросы, которые уже, наверное, скопились.
Первый вопрос. Часто ли сейчас используется RectJava? Давайте я отвечу так. Я, по-моему,
уже немного отвечал и раскрывал этот вопрос на предыдущей лекции. На мой взгляд, RectJava
все меньше и меньше используется на практике, где-то в бою в каких-то
продакшн-приложениях готовых. Почему? Потому что фреймворк крутин и фреймворк flow и stateflow,
которые мы сегодня немного рассмотрим, он практически полностью закрывает те возможности,
которые нам давал RectJava. В принципе, нет сейчас никакого смысла изучать целый отдельный фреймворк и
тащить огромный объем DexCount для того, чтобы решать те задачи, которые мы уже можем решать с помощью
крутин и flow. Так что мой ответ сейчас все реже и реже. И, наверное, такой совет всем начинающим
разработчикам все же подробно изучить именно тему крутин и flow, а в случае необходимости,
при хорошем погружении в тему flow вы сможете понять, как устроен RectJava, как второй, так и третий.
В общем, здесь проблем не будет. Но я бы сфокусировался все же на крутинах на текущий момент.
Как работает крутина под капотом, на каких трессах они выполняются? Все зависит от того, на каком
диспатчере и какой шедулер используется во время исполнения. Наверное, ключевая мысль,
возможно, которую я не очень хорошо донес в рамках первой части, есть потоки, есть крутины.
Крутины будут исполняться на каком-то потоке или на каком-то пулле потоков. Это зависит от диспатчера.
Они не блокируют поток, они только лишь позволяют эффективно использовать текущие потоки и давать им
возможность заниматься чем-то другим, пока наша крутина бездействует, она приостановлена.
Соответственно, вкратце, как работают крутины под капотом, я сегодня рассказывать не буду. Я
специально привел пару... Я, по-моему, привел в конце ролик от хорошего автора, который объясняет то,
как устроена крутина под капотом, во что они трансформируются, во что трансформируются
вообще с аспент-функцией, которые мы с вами написали. Там вся происходит магия с continuation,
там происходит вся магия с таким набором действий, где мы можем в любой момент, в точке
остановки приостановиться, запомнить то, в каком моменте мы остановились, закэшировать,
сохранить весь стэк функции и затем его прихранить, а после чего, как, знаете,
как какую-то дискету или как какое-то сохранение вытащить и возобновить именно в том месте,
где мы представились в прошлый раз. Эта вся концепция хорошо объясняется, по-моему,
в полторачасовом докладе, так что я решил, что в рамках текущей сегодняшней встречи объяснять
это особо не буду. Но ссылочку обязательно прикреплю. Вообще, в целом, есть набор хороших
роликов от Романа Елизарова, который является одним из авторов крутин. Он объяснял также
в своих докладах то, как устроена крутина под капотом и во что они трансформируются с помощью
компилятора. Точнее, во что трансформируется с аспент-функцией с помощью компилятора.
Так, что такое крутина? В рассказе лекции говорили вот крутина активна или нет,
а на слайде Job Lifecycle. Так что значит создать, запустить крутину? Это выполняемый код внутри
скопа? Да, то есть концептуально это то, что очень похоже, в общем, на поток. Это набор каких-то
вычислений, которые проводит текущий поток. То есть, вот мы строчка за строчкой что-то
выполняем, но особенность крутин в том, что вот на определенной строчке мы можем приостановить
свое выполнение и возобновить ее в какой-то определенный момент в будущем. Вот это и главная
особенность. А Job это такая абстракция над этой крутиной, то есть Job просто нам сигнализирует о
том, в каком статусе находится вот этот вот набор вычисляемых инструкций вот сейчас в рантайме.
Вот всего лишь так. И запустить крутину, это значит начать выполнять набор данных,
набор кода, который мы сами прописали у себя в программе. Аналогия очень похожа на поток,
только это скажем так под часть потока набор кода, который выполняется внутри определенного потока.
Так, тут есть вопросы конкретно по слайдам. Я боюсь, что я не буду сейчас прям возвращаться,
то там анимация и так далее мы довольно долго будем ждать. Пропущу вопросы, где мы прям явно
к какому-то слайду переходим. Дальше следующий вопрос. Ключ контекста типа класса извлекается?
Да, что типа того? То есть мы там, кстати, это прикольный подход, связанный с обращением к маппи,
к крутин-контексту. У нас есть возможность, в принципе, я вам рекомендую посмотреть на то,
как устроены интерфейсы крутин-контекст-элементов. Мы действительно по названию интерфейса сможем
типа название интерфейса использовать как ключ к маппи крутин-контексту. Мне кажется,
такой поход вообще довольно редко используется где-либо, я вот его видел только в библиотеке крутин.
Можно еще раз объяснить, пожалуйста, что мы складываем при создании крутин-контекста. Они
складываются как что? Как строки? У них же разный класс, нет? Еще раз, мы складываем... Смотрите,
в Kotlin есть возможность переопределить оператор плюсика, то есть переопределить
логику, которая дает вот этот вот плюсик. Соответственно, там логика следующая. У нас есть
крутин-контекст-элемент и есть другой крутин-контекст-элемент. И переопределена функция
оператор сложения двух крутин-контекст-элементов. Они вместе с собой формируют новый крутин-контекст
сам по себе. Грубо говоря, у нас есть маппы из одного элемента, мы ее складываем с маппой из другого
элемента и по итогу получаем маппу из двух элементов. Грубо говоря, то, что происходит при
сложении двух элементов, как у меня было на слайде. То есть, по сути, крутин-это не замена потока,
а удобный эффективный инструмент для работы с потоками. Что-то типа того. На мой взгляд,
так можно выразиться. Да, то есть у нас есть концепция потоков, которые никуда не уходят,
а есть крутины, которые живут в рамках определенных потоков, и вот эти крутины мы можем в любой момент
остановить. В любой момент, который мы явно задекларируем. Давайте это я явно сам буду
и подсвечивать в рамках лекции. То есть не в любой рандомный момент мы можем взять и приостановиться,
а скорее в определенных точках, которые мы явно сами задекларируем в коде. А так, да, есть потоки,
они никуда не делись, с ними также надо уметь работать, и поэтому у нас была целая лекция,
посвященная потокам. А дальше нужно понимать то, что есть крутины, которые дают нам очень много
преимуществ. То есть мы используем крутины как раз, чтобы упростить себе жизнь и дать
определенные гарантии по работе с отменной действий, с обработкой исключений, может быть,
с эффективным использованием тех же самых потоков. В общем, это такой удобный инструмент для нашей
поседневной работы. Так, вроде бы вопросы кончились, давайте пойдем дальше. Перейдем к теме отмены
крутин. Что тут? Я уже сказал ранее, что у крутин скопа есть возможность отменить все дочерние
крутины. Делается это довольно просто. Вот у нас есть интерфейс крутин скопа, на нем мы вызываем
функцию cancel. Также мы здесь можем передать причину cancellation exception, но обычно даже это
не передается, просто по дефолту вызывает функцию cancel. У самого интерфейса job также есть возможность
вызвать cancel. То есть это вот наверное два самых простых способа отменить нашу крутину. Давайте
посмотрим, как это выглядит на практике. Вот я создал свой крутин скоп и дальше на основе
этого крутин скопа создал три крутины. А дальше их всех вместе я отменяю с помощью нашего скопа.
На диаграмме, на самой схемке выглядит вот так, что есть крутин скоп, на его основе я создал три
крутины. Потом крутин скопу передал намерение все это дело отменить, он каскадно прошелся по всем
своим дочерним крутинам и попросил их сделать ровно то же самое. После чего они уже перешли в
состояние cancel. Получается, что отмена крутин скопа отменяет все дочерние крутины, это стоит
запомнить. Что дальше? Дальше у нас есть возможность отменять с помощью интерфейса job определенную
крутину. Здесь я сделал ровно то же самое, только теперь не на скопе отменяю все крутины, а только на
конкретно из них. И возвращаясь к схемке, я именно крутину два пытаюсь отменить. Она отменяется,
но никак не влияет на другие крутины, которые были созданы рядом с ней. Они также продолжают
работу как ни чем не бывало. Давайте рассмотрим схемку поглубже, по детальнее, если у нас уже
вот такая есть довольно большое дерево крутин. Я пытаюсь дочернюю крутину отменить. Она на самом
деле никак не влияет на свою родительскую крутину. Соответственно и самой родительской крутины все
будет хорошо, и с дочерними крутинами также будет все хорошо. Но особенность в том, что после отмены
крутины вот этот интерфейс job он уже не может быть использован для создания новых крутин. То есть
на его основе мы не можем создать новые крутины. Как могли бы без отмены изначальной. Повторюсь,
при отмене крутин у нас отменяются все дочерние крутины. Сам родитель может не отменяться,
если пришел ивент отмены от одного из его дочерних крутин. И после отмены job не может
быть использован для создания новых крутин. Что дальше? Попробуем рассмотреть уже какое-то
более-менее нормальный пример, где мы выполняем какую-то логику, а потом захотели в параллеле
где-то отменить нашу текущую крутину. Мы здесь создаем нашу крутину, где пытаемся в цикле пройтись
и напечатать какой-то текущий индекс после определенной задержки. Здесь я 10 раз пытаюсь в цикле
пройтись, делаюсь на 100 мс и печатаю индекс. А в основной крутине, в родительской крутине я
делаюсь на 320 мс. Даю возможность моей дочерни к крутине поработать 3-4 цикла и что-то напечатать
в консоль. А потом ее отменяю, причем еще и join-усь. Параллельно с помощью функции cancel on join она
прям явно и говорит то, что происходит внутри ее имплеметации. Мы первой строчкой cancel job,
а второй пытаемся зажониться к ней и дождаться, когда же она полностью завершит свою работу. После
чего печатаем строчку cancel. Здесь опять же никакой магии не произойдет. То есть мы сначала
напечатали 3 индекса, так как как раз и ждали в родительской крутине 320 мс ровно на 3 итерации,
и затем напечатали строчку cancel, а сама дочерняя крутина приостановила свою работу. Вообще вся
магия по отмене крутин происходит с помощью cancelation exception. У этого интерфейса, точнее вообще
у этого исключения есть специальные скажем флажочки внутри имплементации. То есть сам
фреймворк крутин знает про cancelation exception и по отдельному, ну знаете так, он явно понимает,
что это cancelation exception и выполняет определенную отдельную логику по работе с конкретно с ней.
Либо с его наследниками. Сознанно это для различия между отменой и ошибкой, то есть если мы получили
какую-то ошибку, кинули исключение, то скорее всего это исключение будет отлично от cancelation
exception и мы по-другому обработаем это исключение. Пройдем по другой ветке. Вот я как раз это имел
в виду, вот как раз привел пример из реализации крутин, где мы первые строчки проверяем на
instance cancelation exception, а потом уже, если понимаем, что это не cancelation exception, потом отдаем
обработчику в другую ветку. Вот по-другому работаем в общем с исключением. Что еще важно,
вот до этого в некоторых примерах, как как например delay, это стандартная функция из библиотеки
крутин, есть возможность поддержки отмены. Помните в лекции по многопоточности я рассказывал,
что можно поток приостановить на определенное время и если мы попытаемся завершить поток во
время той же функции slip, то мы кинем interrupted exception. Вот здесь происходит примерно то же
самое, то есть есть стандартный набор функций из крутин библиотеки и вот в каждой из этой
функции в момент саспенда у нас есть возможность кинуть cancelation exception. Вот, как-то так. Этим
можно пользоваться, покажу на примерах как именно. Но главная особенность, так же как и в потоках,
отмена должна быть кооперативной, то есть если у нас карутина выполняет довольно большую сложную
логику и у нее нету так называемых вот этих вот точек приостановок, то есть нет возможности
приостановить текущую карутину, она просто довольно долго выполняет что-то сложное. Вот здесь на слайде
привожу пример, что мы в цикле опять же делаем что-то сложное, вычисляем, печатаем какие-то строчки,
но нигде не приостанавливаем карутину. Так вот, в нашей родительской карутине или в принципе
вообще в какой-то другой карутине не будет возможности по нормальному нашу рабочую карутину
приостановить. То есть здесь мы по итогу дождемся выполнения всех всех итераций и увидим печать
всех наших индексов. Ровно то же самое происходит и с потоками, как помните, мы делали примерно то
же самое, приводили, например, ровно такой же участок кода, только связанный с потоками. Соответственно,
опять же должен быть какой-то механизм, позволяющий нам трекать, а хотят ли нас кто-то, есть ли потребитель
или какая-то сторонняя карутина, которая хочет нас приостановить. Это делается как раз таки с
помощью флажочков мы можем узнать, является ли карутина сейчас активна или нет. В случае, если
такого не является и нас кто-то уже явно попросил приостановиться и сработали внутреннее,
сработала внутренняя реализация по отмене карутины, то вот наш флажочек, означающий то, что карутина сейчас
в активной стадии или нет, будет явно об этом сигнализировать. Вот нас захотел кто-то приостановить,
наш флажочек перешел в статус false, из актив флажочек перешел статус false и мы можем, в данном случае,
очистить ресурсы и завершить всю работу в цикле. Есть более удобный, на мой взгляд, способ, такой
более декларативный что ли. Есть функция ensureActive, то есть она делает примерно то же самое, только у
себя под капотом проверяет статус этого флажочка и мы можем, и причем она еще явно выбросит
conciliation exception, если это не так и это нам позволяет не дробить логику на несколько ветвей типа if false,
а скорее явно хорошо дезакларировать, что у нас в момент, в определенный момент мы проверяем
действительно ли мы сейчас активны, если нет, полностью сворачиваем всю работу, завершаем ее и выходим
из цикла, выходим вообще из функции. Вот бывает, что мы используем ровно ее для вот такой цели,
быстро выйти из функции и завершить свою работу. Вот как раз-таки здесь я и привел в пример то,
как вообще этот интерфейс выглядит. У интерфейса job можно вызвать функцию ensureActive и мы там
проверяем статус флажочка и в случае, если этот флажочек дает false, мы кидаем conciliation exception.
Есть другой способ, это одна из suspend функций под названием yield, которая просит текущей
диспатчер перейти на новый цикл, ну короче, зашедулить какое-то новое вычисление, не выполнять
текущую курутину, а переключиться на что-то другое в рамках потока. Вот, и эта функция yield приходит
нам в стандартной библиотеке и соответственно она также имеет возможность кинуть conciliation exception,
если это уже, ну если нас кто-то до этого попросил полностью завершить работу и отменить текущую
курутину. В общем, главное, что стоит вынести отсюда, это то, что есть стандартный набор функций из
библиотеки крутин и практически у всех из них по дефолту есть вот такая возможность, ну вообще есть
поддержка conciliation exception и отмена крутин. Вот, мы можем ими пользоваться, если захотим, ну либо
явно сами проверять с помощью стейтов у job, который является абстракцией к текущей курутине.
Окей, что еще? Здесь мы рассмотрели то, как мы работаем с лаунчами, то есть с
курутинами, которые мы когда-то запустили и пошли дальше, а что делать со сингком,
который возвращает результат. Здесь, на самом деле, примерно то же самое, только есть особенности при
вызове await, да, так как await нам возвращает результат, соответственно не всегда мы получим то, что хотим,
в случае отмены. Вот, здесь я пытаюсь как раз в рамках моей крутины подождать и потом вернуть
результат в виде стренги async result, а в основной родительской крутини я пытаюсь заделается на
секунду, потом дождаться результата и отменить. Да, здесь, возможно, надо было с ручками поменять
местами. Да, вот я как раз это и сделал, забыл про слайд следующий. В общем, здесь я просто дожидаюсь
крутины и отменяю. Здесь в этом, на самом деле, не так много смысла. Я просто дождался, а потом ее
попросил отмениться, но она и так уже в завершенном состоянии, здесь ничего не произойдет. А в случае,
если я поменяю строчку местами, то есть сначала попрошу отмениться, а потом дождаться результата,
то я славлю job consolation exception, вот, потому что результата как такового у меня на руках нет.
По теме крутины, это все. Главное, что стоит вынести, что есть consolation exception,
он по отдельному обрабатывается внутри фармворка крутин, мы с ним можем, в принципе,
работать сами, мы можем даже наследовать свои exception от данного и как-то явно у себя в логике
уметь его обрабатывать. Я, если честно, особо таким никогда не занимался, но, в принципе,
у вас такая возможность есть, опять же, welcome, вдруг найдете ему применение. Что дальше? Дальше,
на мой взгляд, одна из самых сложных, особенно для первой лекции, где мы погружаемся в тему
крутин, вот, тема с отменой крутин, мне кажется, дается всегда тяжелее всего. Почему? На мой взгляд,
просто потому что сам API крутин и сам фреймворк, который у нас есть на руках, позволяет нам,
как разработчикам, слишком много всего и часть кода, которую мы можем в теории написать и
часто делаем так, не приводит к ожидаемому результату. Опять же, чуть позже на слайдах я попробую
привести примеры, почему так. И, возможно, из-за этого, из-за того, что мы, как разработчики,
можем написать много всего, которое, по нашему мнению, может или должно работать, не является,
если работать не так, как задумано нами, вот, и приводит к ошибкам, приводит к каким-то проблемам
на проде, в общем, приводит к какому-то полному непониманию у разработчиков, как же это вообще
вся тема работает и как ее грамотно обработать у себя в коде, обработку ошибок, имею ввиду. Что
тут важно знать? Непойманная ошибка в крутине отменяет как родители, так и у всех дочерних
элементов. Что это значит? Вот, возьмем наше дерево крутин, возьмем нашу дочернюю крутину,
которая кинула исключение, причем не consolation exception, а какой-то другой. Например, у нас реально
ошибка в коде, либо какой-нибудь checked exception мы не обработали у себя внутри, нормально. Что
происходит дальше? Это исключение доходит до родительской крутины. Родительская крутина,
в первую очередь, отменяет все остальные дочерние крутины, вот, свои, вот. Соответственно, тут она
отойдет до крутин 5 и крутин 7, отменит их и потом отменит сама себя. Дальше, если внутри нее мы уже
не смогли обработать никак это исключение, она прокинет это исключение дальше, выше, к своей
родительской крутине. Здесь произойдет ровно то же самое. И получается, что мы вот это исключение
прокинули в самый верх, до нашего корневого, до нашей корневой крутины. Ну и в принципе,
вообще до своего скопа так может быть. Возвращаясь к предыдущему слайду, как раз вот мы берем наш
throwable. Получается, что наш throwable не является наследником cancellation exception, и получается,
мы его пытаемся обработать как обычное исключение. И прокидываем выше через вот эту взаимосвязь
всех крутин между собой. То есть, так как у меня есть возможность в крутин-контексте получить
доступ к родительской крутине и к, через дочерней крутины, у меня есть возможность информацию об
исключении кинуть вверх до родителя. Вот это как раз таки есть structured concurrency, про которое
я говорил в самом начале. Вот получается, что мы, да, я тоже имплементацию привел вот на T-Fi
canceling. Мы как раз сначала пытаемся отменить всех наших детей, а потом пытаемся отменить уже себя.
Получается, что вот так вот мы дошли до самого верха, до родительской крутины и, в принципе,
до всего крутин-скопа. И если исключение дойдет до крутин-скопа, она его, соответственно,
полностью и отменит. И он будет отменен, и на основе него мы уже не сможем создавать новые крутины.
И все дочерние крутины также будут отменены. Это для нас не сказать, что прям классные новости,
почему. Ну, типа, если мы так шумудрились и не словили где-то какое-то исключение,
то оно действительно прям дойдет до самой верхушки, до корневых элементов и вообще,
в принципе, отменит все, что там было. Нам все же нужно как-то уметь с этим работать. Для этого у
нас есть Supervisor Job. Он частично решает нашу проблему, я покажу как, но им надо уметь
пользоваться, нужно понимать для чего и для каких целей он может быть применен. Это отдельный,
скажем так, подтип нашей Job с определенными свойствами подкапот. Если мы используем Supervisor Job,
у себя в коде, покажу как, ошибка или отмена дочерней крутины не приводит к отмене нашей
родительской крутины и не влияет на его наследников, я имею ввиду наследников нашего
родительского Job. Давайте посмотрим, как это выглядит. Представим, что у нас есть крутин Scope,
который был создан на основе Supervisor Job. И если мы попытаемся получить какую-то ошибку внутри
дочерней крутины, она передаст эту информацию дальше выше, внутри самого Scope или какой-то
родительской крутины. Но особенность того, что у нас есть Supervisor Job позволяет нам не отменять
наши другие, наши дочерние крутины, как в принципе и сам Croutine Scope. Но вот эта особенность,
мне кажется, про эту особенность редко кто пишет, редко кто про это говорит, но сам Exception
никто не обработал. То есть мы через взаимосвязь между Job, между нашими крутинами, передали
информацию о том, что Exception случился, и мы не дали возможность родительской крутини полностью
отмениться, но сама информация дальше через Job пропихивается наверх. Она распространяется выше
через родителя. И получается, что в теории, даже если мы где-то на начальной стадии использовали
Supervisor Job, который позволил нам не заканцелить все дочерние крутины внутри своего поддерева,
это не значит, что дальше эта информация будет обработана выше по стеку, ну или там по связи
между Job и не дойдет до обычного Job или обычного Croutine Scope, который увидит от Exception, его сильно
испугается и отменит все, что было ниже его по дереву, все его дочерние крутины. Важно получается
то, что Supervisor Job работает только в том случае, если он является прямым родителем для дочерних
крутин, и по-хорошему он должен являться что-то типа, скажем так, рутовым элементом, ключевым
элементом в момент создания крутин Scope. Вот я бы так выразился, потому что в других случаях,
скорее всего, пользы будет от него не так много. Давайте рассмотрим это на примере. Вот здесь я
пытаюсь создать мою крутину, ну вообще новую крутину, и передаю ей Supervisor Job в качестве
параметра, надеясь на то, что он сможет обработать исключение из моих дочерних крутин. Вот внутри,
дальше я пытаюсь создать две новых крутины. В первой также жду секунду и кидаю Exception,
который мы никак не отловили внутри крутины, а во втором случае, во второй крутине я жду две
секунды и пытаюсь напечатать строчку Will not be printed. Наверное, несложно догадаться,
что произойдет с этой крутиной. А в родительской крутине дальше я пытаюсь заджониться по
всему тому, что я создал с помощью Supervisor Job. Если я попытаюсь просто диаграммами, ну или там
так вот обвести участки кода и показать, что одна крутина относится к одному Job, другая крутина
ко второму интерфейсу Job, поймем, что две наши крутины соответствуют своим элементам Job. Здесь
вроде бы пока все понятно. Но что дальше? А дальше происходит то, что в одной из моих дочерних
крутин происходит ошибка, но обрабатывает эти две крутины только что созданной самим фреймворком Job.
Помните, я в самом начале рассказывал по теме с крутин-билдерами, что крутин-билдер и фреймворк
вообще создает сам свой Job и передает его как такой базовый элемент для всех дочерних крутин. Так вот,
то, что мы передали Supervisor Job, особо-то ни на что не влияет, потому что он будет родительским
элементом по отношению к Job, созданным внутри крутин-билдера. И получается, что сначала мой
обычный Job пытается обработать ошибку внутри дочерней крутины, он зафейлится благополучно,
потому что он не является Supervisor Job и не умеет игнорировать такие исключения. Соответственно,
он сам отменится и отменит все свои дочерние крутины. Вот этот ключевой момент, я надеюсь,
стал чуть более понятен. Если нет, постараюсь в конце лекции или в серии вопросов еще раз
раскрыть этот вопрос, раскрыть этот момент и объяснить получше. Но вот, грубо говоря,
у нас есть возможность передать Supervisor Job и сам компилятор даст нам такую возможность,
ничего не будет подсвечивать. И если просто почитать документацию, может сложиться впечатление,
что мы можем так сделать и передать Supervisor Job внутри крутин-билдера. Но по факту польза от
этого практически не будет. Все из-за того, что под капотом внутри крутин-билдера создается
свой собственный Instance Job, на основе которого и дальше могут создаваться другие дочерние крутины.
Вот. Этот момент, кстати, хорошо обсуждается в одном из докладов на Kotlin Conf. Опять же,
ссылочку я приведу в конце. Окей, как мы могли бы в теории использовать Supervisor Job? Но,
опять же, про спойлер особо так не рекомендую, просто пытаюсь объяснить механику работы Supervisor
Job. В данном примере я создаю его сам, явно, потом передаю его в одну крутину в лаунч и потом
явно передаю в другую крутину. Здесь получается уже кейс немножко другой. То есть у нас каждая
крутина также под капотом, точнее крутин-билдер, также под капотом создает Job, который может быть
зафейлен, но он дальше передаст эту информацию о проблеме в Supervisor Job, который не отменит все
другие дочерние крутины. Но особенность, точнее так, нюанс этого примера в том, что мы немного
ломаем саму систему structured concurrency. Почему? Потому что мы явно сами начинаем руками создавать
Job, Supervisor Job, что в моей практике лучше не делать, а лучше использовать либо обычные крутин-билдеры,
либо крутин-скоп функций, которые мы рассмотрим чуть позже, типа крутин-скопа. Кстати, да, даже я
его на слайде использую в самом начале. Я вызываю функцию suspend main и первой строчкой пишу крутин-скоп.
Вот именно про них речь. То есть нужно использовать тот готовый арсенал из функций, который уже есть в
стандартной библиотеке, а не городить самим, явно не создавать вот такие Job, чтобы потом их и явно
самим как-то стараться заменеджить. Потому что здесь мне приходится явно самому прописывать в самом
конце Job1.Join, Job2.Join, просто потому что теперь сам механизм работы крутины structured concurrency
не работает, мне приходится явно дожидаться самостоятельно завершения крутин. Но здесь
я пытался просто привести пример, что можно использовать Job для определенных кейсов, и он будет
работать, но лучше так не делать. А как нужно? Можно использовать крутин-скоп функцию. По аналогии
с крутин-скоп есть супервизор-скоп, в рамках которого мы можем запускать свои дочерние крутины.
Он позволяет вам выполнить то, что по факту и хотелось бы в самом начале, когда мы начали
разбирать тему, точнее не с отменой крутин, а с обработкой исключений в крутинах. Здесь мы увидим
как раз нашу строчку will be printed, просто потому что одна из крутин зафейлится, но супервизор-скоп
позволит нам проигнорировать это исключение конкретно в этом куске кода и дождаться выполнения
крутины, которая ждет 2 секунды и печатает строчку. Важно подсвечиваю, что наше исключение
не проглатывается нигде, про него мы не забываем, оно дальше передастся всем родительским крутином,
если мы поддерживаем принцип structure concurrency и сами явно Job не создаем, эта информация
передастся дальше и нужно, чтобы ее кто-то обработал. Повторюсь, исключения распространяются выше
по иерархии Job. Вот мы имеем scope, мы создаем дальше крутины, дальше из родительских крутин мы
создаем дочерние и вот информация о том, кто кому является родителем и так далее, как раз и
содержится внутри крутин контекста и внутри наших интерфейсов Job и исключения передаются ровно по
этой схеме, по этой взаимосвязи и если мы не смогли обработать исключение в какой-то из дочерних крутин,
оно обязательно передастся выше и это касается и обычного Job и супервизор Job, я надеюсь это я смог
донести, но да и особенно супервизор Job, что он имеет отличие работы с дочерними крутинами, как раз на
слайдах мы это увидели, что он не отменяет сходу все свои дочерние крутины. Но как же тогда ловить
исключения, вот если у нас была бы возможность так сделать? Во-первых, не допускать ситуации,
что мы что-то не отловили и дальше это исключение вверх пошло по иерархии. В первую очередь, конечно
же стараемся, как и в обычном коде, работать через try-catch, либо через run-catching, который нам вернет
результат, посмотрим как это выглядит, либо на кроняк используем крутин exception handler, но опять же
с ним есть нюансы. Cruitian exception handler это еще один элемент крутин контекста, напомню.
С try-catch как мы это можем сделать? Ну вот допустим у нас есть функция, которая кидает исключение и мы
в теории можем предположить, что она может кинуть исключение. Что это за примеры такие? Ну представим,
что мы работаем с каким-то внешним фреймворком, который мы не контролируем или с какой-то
библиотекой, которую мы не контролируем. Мы не знаем, может ли она в теории что-то вернуть плохое или
нет. По-хорошему нам бы стоило такой вызов обернуть в try-catch, не полагаться на то, что это исключение
потом кем-то там будет обработано, а явно на месте это сделать и обработать результат в случае получения
exception. Получается мы здесь делаем это через try. Пример, конечно же, очень такой синтетический и
особо пользовать него нет, но представим, что мы обращаемся к какой-то опишке или библиотеке и
дальше ловим какое-то исключение и как-то с ним работаем. Но особенность-то какая? Вот если,
в теории мы можем так сделать, я видел примеры кода, когда разработчики пытались обернуть в
try-catch сам вызов launch. Так вот это вообще ни к чему не приведет. Повторюсь, исключение,
которое было кинуто внутри лаунч функции, то есть внутри блока для лаунч-крутинбилдера,
оно не прокинется как обычное исключение и не отдастся просто вот в функцию main. А вот эта
информация о исключении передастся через интерфейсы job. Соответственно, пользы в try-catch
здесь нет никакой, мы никогда не отловим exception вот таким вот образом. Информация об исключении
передастся дальше в job, к routine-scope, который я вызвал в самой первой строчке. Вот, пожалуйста,
вот мне кажется здесь надо обратить внимание явно и может быть еще раз вернуться к этой теме,
ну понять как это работает. Может быть даже попрактиковаться самим, понаписать просто
примеры кода, покидать исключения и посмотреть в какой момент вы можете их поймать. Есть,
повторюсь, кроме try-catch и run-catching, его полезное свойство в том, что он возвращает result.
Довольно полезная API, это такая оберточка над результатом, которая может нам сказать о том,
успешен ли вызов или нет внутри функции. То есть мы через run-catching слоим exception,
получается вернем результат, точка там, фейлур. Выглядит это вот следующим образом. Мы вызываем
run-catching, возвращаем результат типа result и дальше можем с этим результатом работать. У нас даже
в Яндексе есть прям целые проекты, которые работают через этот result API и местами даже довольно
полезно, на мой взгляд, вот этот API довольно полезно и может быть применимо, но с ним тоже
есть нюансы. Какие? Например, мы через run-catching слоим вообще практически все exception, в том числе
и cancellation exception. Про это не забываем. То есть если у нас внутри нашей, точнее, внутри нашей
крутины и внутри какой-то suspend функции есть точка приостановки и из нее вытащился cancellation
exception, то мы сломим его как в try-catch, так и в run-catching. И нам по-хорошему бы этот cancellation
exception заново отправить дальше в другие крутины, либо явно это обработать и понять, что окей,
нас кто-то решил здесь приостановить, давайте попробуем очистить ресурсы. В общем, этот API
полезный, удобный, но также с ним нужно уметь работать. И вот как в завершение того, что мы можем
использовать сами в коде без каких-то собственных костылей, это крутин exception handler. Повторюсь,
это элемент крутин контекста, он является его частью. Он обрабатывает неперехваченные исключения,
но опять же не всегда и не везде. Его нужно в нужное место, точнее так, его нужно вставить в
определенные места и тогда он будет работать. Опять же, на мой взгляд, такой некий недостаток
всего API-крутин. API нам позволяет делать слишком много всего, что не приносит нам должного профита,
или должного результата. Здесь я пишу, что если не указан в крутин scope, исключение передается
on code exception handler. Это такой handler, который у нас есть в Android, в том числе и вообще в любой
GVM. В случае с Android, этот handler просто-напросто крашнет приложение. Возможно, вы знаете,
что если мы в каком-то из потоков нашего основного процесса не отловим исключения и наш поток
полностью крашнется, то и все приложение может быть крашнуто. Нам бы не хотелось такого допускать,
поэтому лучше все же для нашего какого-то корневого крутин scope указать крутин exception
handler, который обработает вот такие неперехваченные исключения. Создать его довольно просто,
также как любой другой объект. Создаем, передаем ему финальную имплементацию того,
что делать с тем или иным исключением. Здесь в данном случае я просто печатаю текущий exception
в консоли. Как можно его использовать? И это, наверное, такой способ, который я могу хотя бы
порекомендовать, хотя бы рекомендовать к рассмотрению. Мы создаем handler, дальше мы создаем scope. Это
может быть какой-то ваш основной app scope внутри приложения, либо scope, привязанный к определенному
экрану вью модели, неважно. Дальше этому scope мы передаем supervisor job, позволяющий не отменять
наш дочерник крутины в случае чего, а также сам handler, который обработает неперехваченные
исключения. И вот если мы в такой концепции будем жить, в такой парадигме, у нас появляется
возможность на основе scope создать наш дочерник крутины, в них даже кинуть какие-то исключения,
как я это делаю в примере, кидаю runtime exception, а во второй крутине просто печатаю результат.
И здесь я получу ожидаемый результат. Я никем не обработал исключения, и оно дошло до конца,
дошло до верхушки цепочки job, дошла до крутины exception handler, и я его напечатал у себя в консоли.
А потом во второй крутине, так как благодаря нашему supervisor job, я смог не отменить ее и
благополучно напечатать в консоли результат. И это чуть ли не единственный вариант использования,
на мой взгляд, где мы и нормально используем supervisor job и handler, крутин exception handler.
В других случаях, так проспольерю, когда вы начнете чуть-чуть практиковаться, вы поймете,
что мы чуть ли не в любой крутин builder можем передать как supervisor job, так и handler,
но пользы от них будет не так много. Лучше рассмотреть и начать использование как supervisor job,
так и handler внутри крутин scope. Это будет ваш самый ротовый элемент во всей цепочке.
Вы от него, от крутин scope начнете создавать крутины и его специальным образом настроите.
Вот и тогда и крутин exception handler и supervisor job будут иметь всю свою мощь, всю свою силу внутри него.
Вот повторюсь, действительно для первой лекции, где мы погружаемся в тему крутин, отмена крутин
и обработка ошибок это чуть ли не самые сложные вещи, на мой взгляд. Их сложно понять сходу,
и нужно чуть-чуть практиковаться, может быть даже посмотреть не один доклад с объяснением и
почитать хорошо документацию. Надеюсь хотя бы какую-то базу сегодня я смог рассказать и
стало чуточку понятнее. Вот это наверное моя главная задача на сегодня. Ну что еще есть? Есть
dispatcher. Мы не раз, ну и я не раз упоминал его. Он нужен для, он тоже является крутин контекст
элементов, он необходим для переключения потоков. Его особенность в том, что мы его, вот его-то мы
можем практически везде передавать, и он действительно будет влиять практически всегда на поведение
крутин. Мы его можем передавать при создании крутин или с помощью крутин скоп функций, как vis
context, покажу на примере. Там мы также можем передать dispatcher и явно сказать в текущей
сопрограмме, в текущей крутине на каком пуле потоков, либо на конкретном потоке нужно исполняться.
Вот в данном примере я создаю с помощью крутин скопа свою новую крутину. Там я пытаюсь тысячу раз
запустить новые крутины, причем в каждой крутине делаю возможность запуститься на dispatcher с IO. То
есть я и явно говорю вот крутина создайся пожалуйста и выполняйся в определенном пуле потоков,
которые соответствуют dispatcher с IO. Это просто такое явное обозначение, что крутина, у меня есть
пул потоков из dispatcher с IO, используй его. Здесь я использую те инструменты, которые мы с вами
рассматривали на предыдущей лекции, вытаскиваю ими текущего потока, ну и соответственно могу
увидеть, что там top worker 1, top worker 4, top worker 3 печатаются. То есть мы наши тысячи крутин
запустили на пуле потоков и дальше печатаем текущее имя потока внутри них. А крутин скоп функцию,
которую я упинул ранее, viscontext, это можно также использовать для переключения потоков. Очень
полезная функция используется не только для dispatchers, но часто вы можете увидеть ее использование
только вот в таких вот конкретных сценариях. Здесь я уже внутри текущей крутины сначала печатаю имя
потока, а потом с помощью viscontext меняю dispatcher на IO и печатаю уже поток, имя потока внутри новой
свежесозданной крутины. Здесь я получаю сначала first main, потому что я на основном потоке запустил
мою родительскую крутину, а потом свежесозданную я уже запускаю на dispatcher с IO и получаю default
dispatcher. Здесь, к слову, можно заметить, что у нас есть определенный пул потоков для IO,
для dispatchers default и они может быть даже местами будут переиспользоваться, такое тоже возможно.
Более того, вы можете указать свой dispatcher, создать его и передавать внутри функции, и это супер
полезное свойство, так нужно делать. Обычно мы абстрагируем передачу dispatchers с помощью
определенных интерфейсов для чего? Чтобы потом при тестировании их подменять. Обычно сами мы
никогда не вызываем статичные функции dispatcher с IO, dispatcher default или dispatcher с main, а передаем
свою абстракцию над ними свой какой-то интерфейс, предоставляющий нужные конкретные реализации
наших плов. Опять же, для того чтобы подменить в тестах и передать нужную реализацию дальше.
Как бы мы могли работать с main потоком? Помните, у нас одна из основных проблем была в том,
в предыдущей лекции, что мы сначала выполняем что-то в background в потоке, а потом хотим вернуться на
основной поток. Это делается, например, так. Мы вызываем функцию visContext и передаем dispatcher.main.
В Android реализации, то есть вот крутины, они могут использоваться не только в Android, но и на
обычных GVM. И вот dispatcher с main там будет разный. В случае с Android мы будем использовать
нативный Android поток, вот main thread, который мы разбирали на прошлой лекции. И здесь мы явно
декларируем, что нашу функцию showUser всегда надо вызывать на dispatcher с main, и все содержимое
внутри visContext будет выполнено на main потоке до тех пор, пока мы явно сами не переключим этот
dispatcher на другой. Но что стоит помнить? Практически я это еще сегодня не упоминал. Это работа
со разделяемыми ресурсами. Помните, опять же, в предыдущей лекции это была чуть ли не главная
проблема по работе с потоками. Нам нужно уметь правильно читать и записывать в разделяемый
ресурс. В случае с крутинами большинство проблем решено за нас. Вот если бы мы создавали какие-то
функции внутри suspend функции и работали с локальными переменами, то вся магия по видимости наших
элементов, по атомарности изменений решалась самим фреймворком крутин и компилятором. Но в случае
если мы работаем явно с каким-то разделяемым ресурсом вне текущих крутин, как на слайде,
где у меня просто где-то в стране объявлен каунтер, просто какой-то разделяемый ресурс, и дальше мы
внутри своих крутин, своих дочерних крутин пытаемся с этим разделяемым ресурсом начать
работать, то у нас могут возникнуть проблемы ровно такие же, как при работе с потоками. То есть,
представьте, что наши крутины работают на каком-то пыле потоков, соответственно, этих потоков может
быть не один, а несколько, и нам нужно уметь заменеджить состояние нашего разделяемого
ресурса между этими потоками. Здесь на слайде я что делаю. Есть функция Massive Run, где я вызываю
какой-то action довольно много раз, тысячу раз я создаю крутин, и внутри каждой крутины тысячу
раз прогоняю этот action, переданной мне в Massive Run. А в самом Massive Run я пытаюсь инкриментировать
мою переменную, мой разделяемый ресурс, текущий свойство Counter. То есть, это такой счетчик,
который я хочу заинкриментить кучу раз в тысяче крутин по тысяче раз. И если я такое вызову,
причем на DispatchersDefault, то есть на пыле потоков, состоящем из не одного потока, а из нескольких,
я получу не то число, которое ожидаю. Ровно по тем же причинам, что у меня нет возможности никак
синхронизировать данные. В текущем коде нет явных признаков о том, что я хочу синхронизировать
доступ к Counter. И мне нужно использовать те инструменты, которые мы с вами разбирали. Это
Atomiki из Util Concurrent. Это Thread Confirmant, это определение, что мы работу с разделяемым ресурсом
выделяем в отдельный один поток, в котором нам уже не нужно переживать о том, что там есть
проблемы с видимостью, есть проблемы с атомарностью изменений и так далее. Ну есть Karoutine Mutics,
который очень похож на то, что мы использовали на предыдущей лекции с локами. Давайте рассмотрим
его чуть отдельно. У нас есть возможность его создать, у нас есть возможность также вызвать его
и выполнить какую-то логику, как вот с синхроной секцией, также и тут. Мы у Mutics вызываем VizLog
и выполняем какую-то функцию внутри него, какую-то логику внутри него. Главная особенность,
главное отличие обычно вот этого Mutics из Karoutine по сравнению с Mutics или с локом из обычных
потоков в том, что он не является reentrant. Помните такое свойство лока, позволяющее нам заходить в ту
же критическую секцию под тем же локом, точнее так заходить в критическую секцию под тем же локом,
который мы уже и так держим. Вот здесь на примере у меня есть функция Do Some Operation,
которая под локом вызывает функцию Do Some Other Operation, которая также под этим же локом пытается
что-то сделать. Так вот в случае использования Mutics из Karoutine у нас так сделать не получится,
мы засаспендимся навсегда при вызове Do Some Other Operation, потому что у нас нет возможности
заново зайти в ту же критическую секцию под тем же локом. Тут это стоит учитывать,
ну и в принципе, наверное, не проектировать IP так, чтобы у вас была потребность несколько раз
обращаться к одному и тому же Mutics внутри критических секций. И здесь мы словим определенный
deadlock. Опять же, здесь, наверное, я бы приостановился, мы обсудили с вами довольно много важных тем,
как отмена Karoutine, так и работа с включениями. Дальше нам предстоит чуть-чуть ознакомиться с
поддержкой Jetpack и рассмотреть немножко Flow и Channels. Грубо говоря, там две части мы уже с
вами довольно хорошо обсудили, давайте попробуем поотвечать на вопросы. Они, наверное, уже скопились.
Что заставляет Karoutine запуститься после отработавшего delay? Она же не может запустить
сама себя. Да, как раз прошу вас посмотреть, даже, наверное, доклады по ссылке, которую я приложил,
вы увидите в конце лекции. Там это объясняется. Как раз-таки компилятор за нас придумает и
реализует такую схему, позволяющую с помощью обьекта класса continuation заново вызвать нас и
восстановить тот стэк методов, который мы до этого прихранили. Сейчас это, мне кажется, я довольно
долго буду объяснять всю концепцию, пожалуйста, лучше посмотрите целый доклад про это. Но действительно,
сама по себе Karoutine себя заново не запустит. Это точно так. То есть мы с помощью компилятора
создаем такую магию и с помощью обьекта класса continuation позволяем нам возобновить работу.
Как выглядит место в коде, где происходит приостановка и переход к другому коду,
например, к отрисовке UI? Используются какие-то возможности, которые уже были в лекции рассказаны?
Как выглядит место в коде, где происходит приостановка? Может быть тоже такой нюанс и
особенность работы Karoutine, что если вы смотрите на код, может быть, на GitHub, на GitLab или еще где-то,
на pull request, где нет нормальной подсветки синтаксиса, то просто посмотрев на функцию,
у вас практически не будет возможности понять, что мы там находимся с suspend, кроме того,
что вы посмотрите на сигнатуру метода и увидите suspend модификатор в названии. Либо какие-то
ключевые функции типа delay, yield или еще что-то, которые явно говорят о том, что мы сейчас находимся
внутри suspend функций. В наших средах разработки типа Android Studio, типа IntelliJ IDE, там есть явное
обозначение, что есть suspend функция, и она слева напротив строчки кода будет обозначать,
что у нас здесь Karoutine может быть приостановлено. Что это значит? Представим, что у нас есть большая
suspend функция, и внутри нее мы видим такой значочек, типа вот api.fetchstudent, и там напротив нее
есть значочек приостановки. Это не значит, что мы прям при вызове fetchstudent приостановимся,
это скорее говорит о том, что внутри fetchstudent мы дойдем до места, где Karoutine полностью остановится,
и дальше вот мы вот это состояние прихраним, где-то захешируем, где-то положим на полочку,
а потом возобновим работу ровно в том месте. И так вот по цепочке, по стеку вызовов мы вернем
результат обратно к нашему клиенту, клиентской части, там где мы вызываем fetchstudent у api.
Вот подход примерно такой. Вся магия с тем, что мы стек вызовов прихраниваем с помощью
continuation, возобновляем работу, и там вообще используется стейт-машина с флажочками,
со стейтами, и мы в коде поймем, на каком этапе мы приостановились, и как в стейт-машине перейдем
на нужный индекс, на нужный этап работы нашей функции. То есть как бы наша функция и каждая
suspend точка, она будет помечаться для стейт-машины, которую создаст сам компилятор. Опять же вот
эту механику, если вам это интересно, можете отдельно подробно изучить, я приложил ссылку на доклад.
Вот, к примеру, мы берем какие-либо данные из базы данных по типу activity. Так, что будет
лучше передавать контекст к рутине? Сейчас, секунду, вопрос довольно сложно сформулирован,
я не могу сходу понять, о чем речь. Что будет лучше передавать контекст? Вкратце, ладно,
там вопрос про то, как мы будем использовать крутины в связке с репозиториями, с view-моделями
и так далее. Чуть позже на слайдах я покажу пример того, как бы я хотел, например, видеть
обычный дефолтный репозиторий, view-модель и так далее в контексте работы с крутиными. Надеюсь,
я смогу ответить на ваши вопросы именно там. Если использовать In-Chore Active, то где проводить
очистку ресурсов? Здесь, наверное, предполагается, что нам очищать-то ничего особо не надо. То есть,
если In-Chore Active мы называем, то мы ожидаем, что мы кинем исключение в случае вызова этой функции и
одновременно отмены данной крутины. Может быть, также через strike edge словить, но я бы так,
наверное, даже не делал. Может быть, просто вызову тогда флажочек, проверил, что из In-Chore Active и
погнали дальше. In-Chore Active это скорее прокейс, когда мы хотим явно сразу оборвать всю работу,
и быстро дойти через исключение, пробросить исключение выше по стеку вызовов и закончить
работу тут. И не писается бесконечный флс. Может быть, даже для читаемости это будет лучше.
Если в текущем потоке запустить через лаунж две крутины подряд сложными вычислениями непрестанавливаемыми,
то они будут последовательно выполняться. It depends зависит от того, как крутины настроены,
но по факту да. Если вы сделаете так, что эти крутины будут выполняться на одном потоке,
то никакой магии не произойдет. У вас поток всегда будет загружен какими-то вычислениями в одной
крутине, и это может повлиять на работу крутины номер два. Если все же у вас шарится какой-то
пул потоков и есть возможность распараллелить работу в этих двух крутинах, то как будто они
могут жить и рядом вместе. Если на одном потоке, то как будто бы да. У вас работа одной крутины
может повлиять на другую. Если так, это я прочитал, супервизор Job имеет смысл использовать только при
малой вложенности крутин. Скорее его нужно, на мой взгляд, уже так по практике, его нужно декларировать
как можно выше, желательно в крутинскопе, как я это указал на слайде. В общем, там нужно понимать,
что вы делаете в других кейсах, и я их специально не приводил сейчас здесь на слайде, как будто бы
только усложнил понимание того, как устроен супервизор Job. На мой взгляд, это непростая штука,
и нужно еще отдельно про него почитать и с ним попрактиковаться. А вот супербазовый пример,
тот пример, в котором я уверен, я привел на слайде. Немножко запутался MainThread и UITread.
UITread – это ведь одно и то же, но в моем контексте точно да. Есть MainThread, его еще называют UITread
на Android. Те примеры, которые я запускаю и привожу на слайдах, это скорее какие-то консольные программы,
они не привязаны к какому-то Android, и тут я имею в виду, что есть вот MainThread обычный из консольной
программы. Но если бы я запускал те же самые крутины внутри MainThread, то это был бы UITread из Android.
Так, наверное, ответил на все, что мне пришло. Давайте продолжим и закончим с нашей темы по
крутинам. На сегодня быстренько пройдемся по Jetpack поддержке и по Flow. Думаю, и так сегодня
довольно много информации прозвучало. Как я уже говорил ранее, не один раз в Jetpack есть поддержка,
крутин. Это очень круто. Это нам как разработчикам позволяет не сильно париться насчет
реализации своих каких-то концепций, как, например, нам бы пришлось делать Executor
Service. Даже мы понимаем, что такое Executor Service, умеем им пользоваться, но чтобы сделать это грамотно,
правильно, в контексте Android и обработать всевозможные проблемы с отменой, с переворотом
экрана, с сменой всего контекста внутри Activity. В общем, как будто бы много кейсов, которые нам
стоит учитывать и хорошо организовать работу Executor Service, не так уж и просто. А тут за нас уже
продумали многие вещи, добавили поддержку ViewModels, добавили поддержку Lifecycle Scope. Давайте попробуем
рассмотреть, что у нас есть уже из коробки при использовании обычного Android X пакета и набора
библиотека TUDO. У нас есть возможность использовать ViewModel. Я вообще, наверное, у вас еще не было
лекций по архитектуре и так далее. Наверное, еще до конца обсуждали те возможности, которые
есть JPEG. Но так вот на скидку скажу, что ViewModel довольно прикольная штука, позволяет вам хранить
внутри нее много информации о текущем экране, вообще хранить сам стейт экрана и дает возможность
переживать жизненный цикл Activity либо фрагмента, который сейчас находится непосредственно на самом
экране. И вот у нас есть поддержка, у текущей ViewModel поддержка крутин, имею ввиду. И у каждой
ViewModel можно дернуть ViewModel Scope, который, мне кажется, по факту чуть ли не всю реализацию тут сейчас приведу
на слайде, делает примерно то же самое, что мы с вами писали чуть ранее. Сам создает крутин Scope явно,
привязывает его к текущему инстанцию ViewModel и к его жизненному циклу ViewModel. И у нас есть
возможность в рамках ViewModel Scope, а соответственно и в рамках жизни ViewModel запускать крутины. И из
коробки у нас уже появится возможность отмены крутин. В том случае, когда ViewModel полностью
уничтожится и вызовется метод onClear at у ViewModel, мы отменим текущий ViewModel Scope и отменим все
эти чернику-рутины, которые еще не завершили свою работу, что очень удобно. И только благодаря
этому уже можно пользоваться default ViewModel Scope из коробки из Android Jetpack. Как бы это могло
выглядеть на каком-то нашем примере? Вот я здесь создал Yandex ViewModel, передаю ему опишку, с которой
наша ViewModel работает. Дальше внутри своей функции, в данном случае это Face Student, я на ViewModel Scope
запускаю свою новую крутину и хожу в API. Причем дальше там могу вызвать UpdateState,
поработать со стейтом экрана, неважно. Но главная фишка, главная идея, это то, что я использую
ViewModel Scope для создания крутины. И в случае, если моя ViewModel, в данном случае Yandex ViewModel,
уничтожится и захочет очистить ресурсы, моя дочерняя крутина с походом в API отменится сама,
вот что прикольно. Мы можем сами создать свой Scope в случае, если мы, ну знаете, это привожу
пример для каких-то кастомных классов, похожих на ViewModel. У нас в Yandex такой используется,
поэтому приведу пример и такого варианта. Здесь мы явно сами ручками создаем крутин Scope,
передаем ему DispatchersMain, чтобы мы по дефолту запускали задачи на Main потоке. Здесь ничего
страшного в принципе нет. Благодаря тому, что наши крутины не блокируют поток, а приостанавливают
свое выполнение и дают возможность потоку выполнять что-то еще, не сильно аффектит Main
поток. И мы многие, особенно какие-то базовые операции типа там, обнови переменную, обработай
какое-то действие пользователя, обнови стейт, можем спокойно вызывать на Main потоке, это не
блокировка на несколько сотен миллисекунд в ожидании ответа от API. Такого не произойдет,
и благодаря этому мы в принципе часто можем безопасно работать с данными внутри Main потока
с использованием Dispatchers.main. И тут я еще передаю Supervisor Job явно для того, чтобы не отменять
какие-то свои дочерние крутины в случае, если мы получили ошибку в одной из них. В OnCreate я
запускаю задачку, что-то там пытаюсь получить, а в OnClear это как раз из библиотеки функция callback,
которая будет дергаться, когда наша viewmodel уничтожается. Я беру текущий скоп, беру крутин
контекст из него и отменяю все дочерние крутины. Вот примерно то же самое происходит и во view
модели, которая приходит из коробки из Android Jetpack. Можете даже в этом убедиться, сами
посмотрите. Но повторюсь, используйте пожалуйста viewmodel, хороший класс замена
всевозможным презентером из MVP-архитектуры, каким-то своим кастомным классом, который могут
пережить жизненный цикл всей активе телефрагмента. Мне кажется, довольно удобный класс, дающий много
преимуществ, плюс еще из коробки у нас есть возможность использовать крутины, что тоже классно.
Есть еще lifecycle scope, у самих классов типа Activity фрагмента они являются lifecycle
owner, у них можно вытащить на основе lifecycle owner lifecycle scope. Этот lifecycle scope я бы
использовал для каких-то UI-ных крутин. В случае, если мы хотим обработать какое-то действие на
экране и запланировать какую-то задачу на самом UI, мы можем использовать lifecycle scope для этого.
Либо, что мне кажется самый частый кейс, это использовать lifecycle scope для запуска и для
дальнейшей подписки на изменение стейта lifecycle и подписки на стейт экрана. Сейчас довольно
популярный подход в Android разработке, где во view модели у нас хранится стейт экрана в виде
state flow. Чуть позже мы посмотрим, как это может выглядеть. Наш UI в виде Activity или фрагмента только
в определенные нужные моменты, когда этот UI активен доступен, подписывается на этот стейт из
view модели. Выглядит это всегда примерно так, как я показал на слайде. То есть, мы вызываем специальную
функцию repeat life cycle started у самого lifecycle. Перед этим все это дело вызываем, так как это
suspend функция. Все это дело перед этим вызываем с помощью новой свежесозданной корутины на основе
lifecycle scope из Activity или фрагмента. А внутри корутины мы подписываемся на state flow, то есть на стейт
нашего экрана и пытаемся реагировать на все обновления текущего стейта и как-то по-другому
отрисовывать UI. Будь то compose UI, либо обычные вьюшки, там уже не важно, в принципе. Этот механизм
позволяет работать и с тем и с тем. Резюмируя, в общем, из Android Jetpack, view модели и работа с
lifecycle scope, это чуть ли не самый маскет, который у нас есть. Есть куча библиотек, бесконечное
количество библиотек на самом деле у сейчас у гугла. Мне кажется, что 15 последнее время только
использовал. Практически у каждой из них есть поддержка корутин и вообще, как бы корутин,
это чуть ли не номер один инструмент работы в такой много поточной среде с точки зрения гугла и
Android разработки. Так что, кажется, вы не ошибетесь, если начнете изучать подробно корутины и начнете
пользоваться библиотеками из Android Jetpack. В заключение, я понимаю, что уже довольно
долго и довольно долго с вами тут сидим и изучаем корутины. Немножко пробежимся по channels
and flow. Повторюсь, главная задача текущей лекции вам в основном рассказать про корутины. Channels
and flow, на мой взгляд, это не такая сложная тема и их можно узнать самостоятельно, просто чуть-чуть
попрактиковавшись. Важно просто понимать всю концепцию корутин, работы со spin функциями и
работа там с jobs, с их lifecycle и так далее. А остальное, это дело наживное, вы сможете сами спокойно
разобраться в этой теме, хорошо поняв предварительную фундаментальную часть в виде корутин. Но все же,
все равно в рамках лекции мы чуть-чуть пробежимся по основным интерфейсам, поймем, как с ними
работать. У нас есть интерфейс channels. Вообще channels, как каналы, это возможность в виде, знаете,
это очень похоже на какой-то blocking queue, где вы имеете потребителя и имеете производителя каких-то
элементов общаться между собой. То есть у вас есть канал передачи, есть канал получения. И channels
реализуют оба таких входа, выходных точек. То есть есть send channel, позволяющий вам отправлять
что-либо, и receive channel, позволяющий вам получать что-либо. Отдельно здесь останавливаться не буду,
здесь все более-менее понятно. Есть функция send, которая отправляет значения, есть функция receive,
которая эти значения получает. И заметьте, что они являются suspend. Вот я сказал, что channel очень
похож на blocking queue, но вот blocking queue, судя по своему названию, блокируется. То есть мы, если мы
являемся потребителем и пытаемся получить новый элемент, которого нет еще, мы заблокируемся. Если
же мы являемся поставщиком элементов и на текущий момент нету потребителя, готова обработать наш
новый элемент, мы также заблокируемся. Так вот, в случае с channel-ами все примерно то же самое,
только мы не блокируемся, а приостанавливаемся, как и везде. Вот поэтому эти функции являются suspend.
Пример использования давайте рассмотрим. Здесь я явно сам создаю channel, использую этот channel для
того, чтобы отправить сообщение через, ну с помощью одной крутины. Вот и здесь я явно пометил, что это
у меня sender. Вот я создал крутину, здесь я 5 раз что-то пытаюсь в цикле пройтись и напечатать какую-то
строчку. Вот потом этот channel закрываю. А есть еще receiver, это какая-то соседняя крутина, которая,
причем видите здесь можно использовать обычный for each loop, то есть пройтись по всем элементам
channel-а, как в цикле и обработать эти сообщения. Вот и это будет нашим receiver. К слову, вот даже
в нашем проекте в Yandex.P мы используем вообще концепцию channel-ов и умеем обрабатывать вот
такие сообщения примерно так же, как я показал на слайде. То есть у нас есть поставщик каких-то
событий, есть получатель. И вот получатель также в for each цикле ожидает новые значения и их потом
как-то обрабатывает. Ключевой момент в том, что channel является горячим источником данных. Что это
значит? Что этому каналу особо-то не важно, есть ли у него сейчас какие-то потребители и он будет
производить, ну в случае, если мы просто создаем его через функцию produce, как на слайде, он будет
производить элементы и ему там не особо-то и важно, есть ли сейчас какие-то потребители, он может
там закашировать какие-то значения, если мы буфер изначально передали. Ну и какие-то элементы может
потом пропустить, если буфер не позволяет хранить все. Вот. И это важно, почему я вообще начал
говорить про горячий источник данных в том, что flow, который мы рассмотрим буквально на следующем
слайде, является изначально вот сам интерфейс с холодным источником данных. Вот. Горячий
получается, что он активно генерирует данные, даже если никто не принимает эти данные и не слушает
сейчас в моменте. И при подписке на горячий источник данных мы начнем получать данные, вот только
те актуальные, которые у него есть сейчас на данный момент или те данные, которые он закашировал
у себя в буфере. Вот. А flow он генерирует, обычный flow, который мы сейчас посмотрим, как создавать,
он будет генерирует, генерирует элементы только при запросе. И каждый подписчик начнет получать
свою, свою копию, свою серию данных, начиная сначала, ну начиная сначала создание элементов
внутри flow. Вот. Получается, что flow у нас холодный источник данных. И сейчас я не говорю про
state flow и про shared flow, а именно про обычный интерфейс flow, в котором мы также можем работать.
Вот. Flow сам по себе можно как-то перевести как поток, но пожалуйста не путайте его с тредами,
которые мы рассмотрели раньше. Просто это какой-то некий поток значений или поток данных,
который мы можем обработать, цепочка событий. Вот. Эти данные там могут работать и вычисляться
синхронно. И мы начнем получать данные только в момент непосредственно самой подписки. Сам интерфейс flow,
он выглядит полностью, я его полностью уже указал на слайде, то есть у него есть только одна функция
collect. Этот flow можно самим реализовать, но мы посмотрим на его там такие основные реализации
чуть позже. Вот. В flow есть два интерфейса основных, это непосредственно сам flow и flow collector,
который он принимает в своей функции collect. Использовать сам flow можно вот таким образом.
Мы вызываем фабричную функцию flow, в которой начинаем производить элементы. В примере со
students flow я что делаю? Я пытаюсь три раза после дилея заимитить юзера с текущим индексом. Но вот
вся особенность в том, что если я просто вызову students flow, который вернет мне flow моих
юзеров, не приведет к самому вычислению данных юзеров. Они начнут вычисляться и начнут приходить
мне как подписчику только в момент подписки. Вот я suspend функции main вызываю функцию collect,
и это является триггером для сбора элементов, для начала сбора элементов, для начала их создания.
И дальше уже в collect я начинаю этих подписчиков этих студентов обрабатывать. Получается,
что здесь отличие от channel в том, что produce моментально начнет производить элементы,
как только я их создам, а во flow мне нужно подписаться. И только после этого,
то есть должен быть какой-то терминальный оператор, терминальная функция, которая затриггерит запуск
имита, запуск отправки и создание новых элементов. Сама структура flow указана на слайде,
то есть у нас сначала есть flow builder, это обычно вот такая фабричная функция типа flow, где мы
внутри экшена пытаемся по особому алгоритму, как мы захотим, начать имитить значения. Дальше
обычно идет серия операторов. Что это такое? Intermediate операторы, я их тут так назвал,
это промежуточные операторы, которые как-то видоизменяют наш поток, нашу цепочку данных.
Вот здесь я привел в пример, что есть on itch, on start, on completion, catch. Ну вот для примера,
on itch возьмет текущий элемент и может с ним что-то сделать по ходу дела, как сайд эффект какой-то.
В данном случае я просто печатаю текущее значение, которое пришло в on itch на экран. Есть
on start, on completion. Это такие стартовые кулбеки, когда я только подписываюсь на новый flow,
или когда этот flow полностью завершается. Catch позволяет мне, как подписчику на flow,
обработать определенные исключения и заметить новые значения. В общем, на самом деле вот этих
операторов целая тьма, мы часть из них сейчас рассмотрим дальше на слайдах. А есть терминальная
операция, терминал operator как collect. Их на самом деле несколько бывает, но вот collect,
наверное, основной. Только он затриггерит запуск нашего flow. Как это происходит? Вот представьте,
что есть flow builder, он вернул нам какой-то объект. Это просто напросто какой-то действительно объект,
который ничего сейчас не делает. Дальше мы к нему применяем серию intermediate операторов,
которые также ничего не делают, они просто декларируют, что произойдет с элементами,
когда они начнут приходить. А есть терминальный оператор, который всю эту движуху запускает.
Он вот как по цепочке, вот как здесь по коду, начинает снизу вверх идти и просить дать ему
элементы. То есть функция collect затриггерит тот flow, который был передан после функции catch,
отдай мне, пожалуйста, элементы. Тут в свою очередь пойдет в он completion, тот вон start,
тот вон itch и так дойдет до, все дело дойдет до flow builder, который начнет иметь значение. Вот
это вот такая вот особенность в том, что есть терминальный оператор, который начинает
триггерить получение элементов, работает как в нашем flow в крутинах, так и в том же rig.java.
Поэтому, вот возвращаясь к теме с rigs, если вы сначала хорошо поймете крутины, потом на их
основе поймете, как работает flow, вы довольно легко справитесь с концепцией rig.java, потому что там
происходит примерно то же самое, что я вам рассказываю здесь. Есть исключения, есть отличия,
но концепция очень похожа. Есть колонны источник данных, мы на него подписываемся, точнее мы к нему
прикручиваем набор операторов, а потом с помощью терминального оператора пытаемся затриггерить
все создание данных внутри flow. И вот когда вы пишете какие-то участки кода, вы спокойно можете
формировать ваш flow, накручивать на него кучу операторов, но не беспокоиться о том, что он,
то есть вы уже что-то начинаете создавать. Запуск непосредственно начнется только в момент коллекта
каким-то образом. Надеюсь, здесь немножко концепцию объяснил. Что насчет промежуточных операторов?
Назову парочку из них довольно интересных и полезных. Есть мэп, который, соответственно, из
одних значений конвертит во что-то другое, причем отличие мэп от его аналогов из той же rigs java в том,
что этот мэп является suspend, и мы можем даже здесь приостановиться, дождаться какого-то
результата и после чего возобновить работу. Что я здесь делаю? Я, во-первых, создаю набор
чисел от 1 до 5 и превращаю их во flow. То есть если я начну коллектить мой flow из чисел,
то я начну по итративно по цепочке получать значение от 1 до 5. Дальше я использую промежуточный
оператор в виде мэп и пытаюсь текущее значение возвести в квадрат. Дальше уже с помощью коллект,
с помощью терминальной функции я запускаю генерацию моих элементов, начиная сначала с цепочки
создания numbers flow и после того как я замапил значения возвелых квадрат, я их печатаю в
консоли и получаю заветные 1,4,9,16,25. Все числа возвелых квадратов. И вообще мэп супер полезная
штука, она используется практически везде для разных целей. Здесь привел такой банальный пример
с маппингом одного числа в другое. Есть фильтр, который будет отфильтровывать набор данных. В данном
случае я пытаюсь проверить четное число или нет. Если да, то пропускаю дальше. Если нет, то не беру
с собой. В общем я их пропускаю и не отдаю остальным промежуточным операторам после оператора фильтра
в данном случае. То есть вот у меня есть 1,2,3,4,5 числа, потом я применяю к нему промежуточный оператор
в виде фильтра и фильтрую только те числа, которые являются четными и получается на выходе из фильтра
у меня уже будет только 2,4. И остальные операторы, промежуточные операторы будут работать с 2,4,
а 1,3,5 даже не увидят. Вот это как бы особенность оператора фильтра. С take, мне кажется, можете
догадаться и сами, то есть мы ему передаем число и он будет брать только определенный набор чисел
по счету. Вот здесь я вызываю take, не передаю 3, соответственно я возьму только первые 3 числа.
Я говорю числа, первых 3 элемента в данном случае это числа. Это 1 до 5 и получается первые 3 числа
1,2,3. Есть еще zip, который связывает набор данных. Вот представьте, что у нас есть два flow. Первый
возвращает числа, второй возвращает символы. В данном случае abcd, e. И я пытаюсь zip как цепочку
на молнии, я пытаюсь склеить один flow с другим и у меня будут сформированы пары значений. Вот,
то есть я получается вызвал numbersflow.zip и передал ему второй flow и дальше он будет склеивать
значения из этих flow, он будет склеивать между собой и формировать новое значение. Вот обычно
такие операторы используются для того, чтобы склеить походы в разные опишки, которые возвращают
свои flow и мы пытаемся на основе нескольких опишек получить финальный результат. Вот здесь опять же
такой пример синтетический простой, но поверьте в продакшн коде zip тоже используется как раз для
склеивания данных из разных опишек, из разных сервисов, чтобы потом получить какой-то единый
результат. Вот. И таких примеров, таких операторов уйма, я не хочу тратить ваше время, чтобы просто
объяснять каждый из них по отдельности. Кажется проще просто пройти по документации и почитать
про них. И я хотел именно объяснить концепцию того, что вот есть промежуточные операторы,
которые как-то видоизменяют наши элементы по ходу дела. Что насчет shared flow, state flow? Вот они
как раз являются горячими источниками данных, то есть они в отличие от обычного flow позволяют
нам генерить какие-то элементы по ходу дела и не зависит от того, есть ли у них сейчас подписчик или
нет. Вот. Shared flow как видите наследуется от flow, у него есть reply cache, который как раз нужен для
хранения элементов внутри себя. У него есть возможность, точнее так, есть shared flow как
red-only коллекция по аналогии с листами и mutable листами в Kotlin. У него есть свой аналог в виде mutable
shared flow, который позволяет изменять значения внутри flow, то есть имитить новые значения внутри него.
Вот. Как это обычно работает? Представим, что есть flow как поток данных, мы с помощью mutable
shared flow можем этот поток данных видоизменять с помощью внешнего интерфейса, с помощью функции try
emit, ну или просто emit. Как мы это делаем? Вот я здесь создаю shared flow, делаю mutable shared flow и
создаю две крутины, которые начинают коллектить мой shared flow. Делаюсь на секунду, а после чего
имитчу message1 и message2 вот в мой flow. То есть есть внешний контракт у самого mutable shared flow,
если возможно, заимитить значения, я это делаю, а в других крутинах пытаюсь подписаться и получить
результаты. Так как я подписался заранее, грубо говоря, и делай в одну секунду мне точно хватит на
то, чтобы создать крутины и подписаться, я получу ровно то, что ожидается. В каждой из крутин я
получу и первое сообщение, и второе. В случае, если бы я создал эти крутины сильно позже, после того,
сколько я бы заимитил, тут уже зависит от того, как реализован shared flow и какие гарантии он дает по
поводу хранения данных, заимиченных ранее до того, как кто-то подписался на этот shared flow.
Что такое shared flow? Это его аналог, это расширение концепции shared flow, он работает аналогично,
только его особенность в том, что reply cache, вот этот внутренний cache по хранению данных,
которые никому еще не были переданы, оно связано к одному, то есть state flow хранит в себе всегда
только одно конкретное значение. Для нас это супер важно в контексте работы с тем же стейтом
экрана. Почему? Нам не хочется хранить стейты экрана, какие-то предыдущие стейты экрана, а нам
всегда хочется иметь актуальное, единственное значение, которое ему соответствует. И вот state
flow это идеальный кандидат, для этого покажу каким образом. Получается в state flow у нас
есть всегда в единый момент времени текущее значение, его можно вытащить через value,
а есть в контракте mutable state flow возможность, причем атомарно, изменить текущее значение
внутри state flow. Это как раз делается примерно через те же концепции compare and set, которые я
объяснял на предыдущей лекции по многопоточности. Примерно та же концепция, как в атомиках. И функции
примерно также называются compare and set, update and get, в общем, очень похоже. Давайте покажу,
как это выглядит. Вот я создаю mutable state flow, опять же в какой-то курантине я на этот state
подписываюсь, дальше после задержки я во-первых, а какая еще особенность, я забыл про это сказать,
для state flow нужен initial value, то есть начальное значение. Мы его обязательно должны передать,
в данном случае я просто передаю буквку A. Дальше я в курантине пытаюсь подписаться на этот
state, печатаю значение, которое из этого state могут прийти, и после дилея я пытаюсь из текущего
стейта взять значение и его переназначить на буквку B. И это поможет, это будет работать,
я реально в state flow получу другое значение. И дальше после дилея я пытаюсь подписаться на этот
стейт еще раз и получу ровно буквку B, которую изменил ранее. Что тут важно? Во-первых, именно
state.value я бы так особо не делал. Почему? Хочется, чтобы вы явно создавали проблему работы с
разделяемым ресурсом, и что явно обращаться к переменной просто вот так и менять у нее значение
не стоит. Это можно делать только если вы явно знаете, что сейчас находитесь в usl, в main потоке,
в одном единственном потоке, и безопасно менять значение вот так вот на ходу. Что я вам предлагаю?
Работать примерно по такой концепции. Вот у вас есть view-модель. Туда вы передаете какие-то
репозиторы, интеракторы, use-кейсы, не важно что, это те классы, которые отвечают либо за работу с
датаслоем, с каким-то данными, либо за работу в domain-слое, то есть вашу бизнес-логику непосредственно.
Дальше есть UI-state, которая отвечает за state-экрана. Это может быть описание того, каких состояний
экран находится, какие кнопки нужно показать, какие скрыть, как реагировать на нажатие
пользователя, какую анимацию запустить, и так далее. В общем, этот UI-state должен описывать то, как
выглядит ваш экран. И обычно это происходит так, что вы в mutable-state-flow храните, причем с нижним
подчеркиванием для чего, чтобы явно разделить интерфейсы read-only-flow и mutable-flow. В общем,
вы в mutable-state-flow храните state-вашего экрана, а внутри функции, типа вот как у меня onCreate,
вы получаете определенные данные, а потом автомарно, например, через функцию update,
которая есть в mutable-state-flow, вы обновляете ваш state-экран. И это происходит, повторюсь,
автомарно и безопасно для работы в многопоточной среде. Вот такой концепции я бы ожидал от вас в
ваших работах и в ваших проектах. То есть есть state-flow, который олицетворяет вообще ваш state-экран,
и вы его автомарно меняете с помощью функции update в разных точках, либо вообще в определенном
каком-то месте, где, может быть, у вас есть, не знаю, switch или van по всем состояниям экрана или
там бизнес-логики, и вы явно говорите, что только вот в этой функции вы можете менять state-экрана
через функцию update в state-flow. В общем, вот что-то такое я бы в первую очередь начал делать в
проектах, так использовать state-flow. В общем, наверное, ключевая мысль. Повторюсь, здесь явно вынес
надельный слайд. Вот обновлять state стоит вот так. Не нужно обращаться к переменной точке value у
state-flow и что-то у нее менять, потому что тем самым вы можете для себя же в будущем поломать логику
работы, если вы из того не сего начнете работать со state в нескольких потоках. Лучше явно сразу
обезопаситься и работать автомарно со значениями внутри него. И напоследок я приведу пример того,
как у нас работают некоторые репезитории в проектах. В случае, если мы хотим, чтобы репезитории
работали по такой концепции, что в in-memory кэше, например, они хранили данные, и эти данные могли
меняться только автомарно, вот мы обычно делаем примерно следующее. То же самое, как в view-модели.
У нас есть state-flow, который хранит данные, и мы через него обновляем само состояние внутри. А
есть flow, который вытащен наружу для чтения. Все наши подписчики наших репезиторий будут
подписываться на state-flow и получать актуальное значение оттуда. И причем давайте, наверное,
еще ни разу не объяснял, и вот как раз завершающая мысль будет, почему есть такое разделение на
mutable state-flow и на обычный state-flow. Mutable state-flow нужен только для внутреннего использования
внутри класса, и он позволяет видоизменять на state-flow. А наружу мы вытаскиваем интерфейс
state-flow, не позволяющий нам никак влиять на state-flow и менять значение внутри него. Благодаря
этому у нас есть возможность вытащить наружу только red-only вариант. И на этом на самом деле
сегодня все. Я, мне кажется, прошелся по основным концепциям, которые, на мой взгляд, важны,
которые вам стоит использовать у себя в коде. Давайте еще раз напомню, какие темы мы с вами
обсудили. Мы узнали, что такое крутина, хотя бы, надеюсь, на базовом уровне. Мы узнали, что такое
крутин-билдеры, узнали, как работать с estate наших крутин, немножко окунулись в тему отмены крутин,
работать с исключениями и немножко познакомились с state-flow и с shared-flow. Надеюсь, сегодня было
довольно полезно хотя бы для такой вводной встречки. На что стоит посмотреть. Каждый год
рекомендую примерно одно и то же. Здесь немножко поменял ссылки, мне кажется. В общем, на самом деле
можете приходить ко мне еще в личку, порекомендую еще такой же большой список. Здесь основное,
что точно стоит прочитать и узнать. Официальный гайд по крутинам, пройдитесь, пожалуйста, там довольно
много ключевой информации изложено. Каждый раз привожу ссылку Scott Linkon, где объясняю эту
концепцию, работа с исключениями. Там как раз один из примеров, которые я указывал на слайде.
Всегда топлю за статьи Романа Лизарова, прочитал, мне кажется, все его статьи на медиуме. Вот тоже
прошу вас глянуть. Как раз это один из основных авторов крутин. Особенно в начале работы над
крутинами и проектированием крутин в 18-19 годах он очень много писал статей на медиуме и объяснял
причины того, почему крутина работает так, как они сейчас устроены и что служило доводом для
этого. Плюс объясняет некоторые концепции, как, например, работа с разделяемыми ресурсами,
объясняет, что такое как раз таки холодный поток и горячий поток, ну и много всего другого
полезного, так что прошу посмотрите. Вот. А насчет того, как устроены крутины, есть много докладов.
От того же Романа Лизарова несколько докладов, причем на разных конференциях. Есть вот Мартсен
Маскала, который автор нескольких книг про котлин, в том числе по крутины, и вот в ролике,
который ссылку, которые прикладываю здесь, он объясняет то, как крутина устроена под
капотом и во что превращаются наши suspend функции после работы компилятора. Мне кажется, как раз этот
доклад сможет вам помочь в освоении крутин и в понимании того, как крутины устроены под капотом.
Вот. На этом все. Давайте попробуем ответить на вопросы, на последнюю часть, и сегодня закончим.
Можно ли вручную задать размер пул потоков для диспатчера? Да. Вы можете передать свой
кастомный диспатчер и сформировать его так, как хотите. Можете создать пул потоков из одного
потока всего, то есть сделать его таким однопоточным и использовать для своих нужд, например,
для упрощенной работы с многопоточным кодом со со разделяемым ресурсом. Можете указать даже
пул потоков из тех же экзекьюторов, почему нет? Ну, тех же пул потоков, которые используются в
экзекьюторах у вас с другой частью кода. Подписка в UI на Stateflow из VM выглядит избыточно, особенно если
стейтов много. Есть ли смысл в Core модуль выносить логику подписки? Не уверен, что это выглядит
избыточно. Есть ли смысл в Core модуль выносить логику подписки? Мне кажется, сложно мне ответить
на такой вопрос, потому что я не до конца его понимаю, что мы хотим вынести в Core модуль. Ну,
я бы сказал так. Для начала точно стоит отталкиваться от концепции, что у нас есть
view модель, которая хранит какой-то стейт, а в UI мы не храним сами по себе никакой стейт,
мы только лишь подписываемся на что-то, что имеет жизненный цикл больше, чем у вьюшки,
у нашего активити, у нашего фрагмента или там у каких-то компус-функций, и мы получаем данные
из той же view модели, точнее подписываемся на эти данные тогда, когда нам удобно, когда мы можем
что-то отрисовать и реагируем на изменения. Вот эту концепцию я бы точно использовал практически
везде, на всех экранах, и она уже доказала свою состоятельность и может быть по праву
использована практически везде. Вопрос стоит, нужно ли использовать крутины? Так, при наблюдении
за flow или live data можно еще пару предложений об этом. Тоже не совсем понял вопрос, но услышал
ключевое слово live data. На мой взгляд, ее особо не стоит использовать уже. Это избыточный фреймворк,
который вам по факту-то не нужен. Я бы все же рекомендовал везде использовать flow и обычные
крутины и live data практически нигде не использовать. Мне кажется, потом будет вам сложнее от нее уйти,
в случае, если будете по-прежнему ее использовать. На мой взгляд, это история временная и скоро live
data практически не будет. Я не вижу предпосылок, чтобы она имела популярность и смогла закрыть
какие-то определенные кейсы из state flow или из обычного flow. Можешь привести примеры
использования Channel именно в Android? К сожалению, я думал о том, чтобы показать пример того,
как у нас в проекте используется Channel. Давайте просто на словах объясним. У нас используется
Channel. Мы его используем для отправки... Давайте так. Есть концепция MVI. Это один из таких
архитектурных паттернов для presentation слоя. Он может быть по-разному использован. Есть библиотека
Orbit. Можете прогуглить, что это такое. Там есть механизм отправки интентов. У нас в проекте
аналогично используется отправка интентов. Мы отправляем интенты путем сэнда в Channel событий
на этот интент, на обработку какого-либо действия. А дальше наш обработчик и обрабатывает все интенты
и как-то их менеджит у себя внутри. Там мы как раз используем концепцию Channel. Все extension
коллекциям будут работать с Flow. Что ни вопрос, я пока не очень понимаю, как на них отвечать. Все
extension с коллекциями будут работать с Flow. Смотрите, если имеется в виду, что я создал набор чисел и
потом их превратил в Flow, вообще, можно практически любую коллекцию завернуть во Flow и начать имитить
значения оттуда. Наверное, да. То есть вы можете даже сами вручную такое сделать, создать свой
factory method Flow и начать имитить значения оттуда, просто притерировавшись по коллекции. Почему нет?
Зачем повторно подписываться на Slateflow, разве данные не должны изменяться динамически? Слайд
139. Так, а я на каком сейчас слайде? Давайте, ладно, тут всего пару слайдов, я дойду до конца.
Дело в том, что здесь уже создана другая крутина, то есть я в двух крутинах подписываюсь на одно и
тоже. Просто привожу пример, что подписчиков может быть несколько и каждый из подписчиков будет
получать свои значения. То есть я в каждой крутине получу значение актуальное. Как-то так.
Почему немутабельный UIStateSharedFlow, а не StateFlow? Так, опять же, наверное, это в контексте какого-то
слайда, пожалуйста, если прям интересно, можете написать мне отдельно с указанием слайда,
я постараюсь ответить. И давайте последний вопрос, вижу он как раз мне пришел, и на этом
закончим. А почему для public StateFlow не использовать Getter Value? На слайде было явное создание через
присвоение. Не, вообще, на самом деле, это можно по-разному реализовать эту концепцию. Главная идея
того, что мы скрываем интерфейс, который видоизменяет наш StateFlow, и наружу выставляем
только Redon-ли часть. Это можно сделать реально по-разному. Можно через Getter и закрыть приватную
Setter. Можно сделать, как я указал, мы используем приватный полис с mutable StateFlow, а наружу вытаскиваем
публично только Redon-ли часть. В общем, я здесь не утверждаю, что это единственный верный путь,
то как я указал на слайде, скорее хотел передать главную идею того, что мы делаем. Мы не отдаем
подписчикам возможность видоизменять на StateFlow, а делаем это только внутри, то есть мы именно
скрываем внутреннюю реализацию. Наверное, на этом все. Довольно много вопросов было, я надеюсь,
на большинство из них ответил и, в принципе, сегодня было полезно. По остальным вопросам,
прошу, можете писать мне в личку, в телеграмме, постараюсь ответить, как будет время. А на сегодня
все. Всем спасибо за внимание и до новых встреч.
С вами был Игорь Негода.
С вами был Игорь Негода.
