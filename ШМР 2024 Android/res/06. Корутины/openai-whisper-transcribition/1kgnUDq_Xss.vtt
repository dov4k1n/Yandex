WEBVTT

00:00.000 --> 00:04.000
Редактор субтитров А.Синецкая Корректор А.Егорова

00:30.000 --> 00:33.000
Корректор А.Кулакова

01:00.000 --> 01:03.000
Корректор А.Кулакова

01:30.000 --> 01:33.000
Корректор А.Кулакова

02:00.000 --> 02:03.000
Корректор А.Кулакова

02:30.000 --> 02:33.000
Корректор А.Кулакова

03:00.000 --> 03:03.000
Корректор А.Кулакова

03:30.000 --> 03:33.000
Корректор А.Кулакова

04:00.000 --> 04:03.000
Корректор А.Кулакова

04:30.000 --> 04:33.000
Корректор А.Кулакова

05:00.000 --> 05:03.000
Корректор А.Кулакова

05:30.000 --> 05:33.000
Корректор А.Кулакова

06:00.000 --> 06:03.000
Корректор А.Кулакова

06:30.000 --> 06:33.000
Корректор А.Кулакова

07:00.000 --> 07:03.000
Корректор А.Кулакова

07:30.000 --> 07:33.000
Корректор А.Кулакова

08:00.000 --> 08:03.000
Корректор А.Кулакова

08:30.000 --> 08:33.000
Корректор А.Кулакова

09:00.000 --> 09:03.000
Корректор А.Кулакова

09:30.000 --> 09:33.000
Корректор А.Кулакова

10:00.000 --> 10:03.000
Корректор А.Кулакова

10:30.000 --> 10:33.000
Корректор А.Кулакова

11:00.000 --> 11:03.000
Корректор А.Кулакова

11:30.000 --> 11:33.000
Корректор А.Кулакова

12:00.000 --> 12:03.000
Корректор А.Кулакова

12:30.000 --> 12:33.000
Корректор А.Кулакова

13:00.000 --> 13:03.440
в этой функции наша крутина может быть остановлена.

13:03.440 --> 13:04.440
Вот и все.

13:04.440 --> 13:07.960
После того, как данная функция будет скомпилирована окончательно,

13:07.960 --> 13:13.160
она немножечко трансформируется в не совсем читаемый для нас вид,

13:13.160 --> 13:17.760
но как раз компилятор сделает вывод из того, что функция является suspend

13:17.760 --> 13:21.840
и сделает определенные доработки нашего кода,

13:21.840 --> 13:25.280
которые позволят нам в определенный момент останавливать крутину,

13:25.280 --> 13:29.440
а потом ее возобновлять, то есть доставать из недр наш стек вызовов

13:29.440 --> 13:37.320
всех функций и начинать дальнейшую обработку кода с того места, где мы закончили.

13:37.320 --> 13:42.400
Вот это, наверное, главная мысль, которую нужно вытащить из этого слайда.

13:42.400 --> 13:43.400
Идем дальше.

13:43.400 --> 13:47.400
Какие основные фишки крутин? Почему мы вообще их сегодня рассматриваем,

13:47.400 --> 13:48.960
помимо того, что только что обсудили?

13:48.960 --> 13:53.000
Они соблюдают принцип structure concurrent. Что это значит?

13:53.000 --> 13:58.480
Это значит, что у нас есть возможность выстроить взаимосвязь

13:58.480 --> 14:00.840
между родительскими крутинами и дочерними.

14:00.840 --> 14:07.400
В примере из пятницы я вам показывал, как можно из одного потока создать другие потоки

14:07.400 --> 14:12.040
и запустить их дальше. Вот они живут там у себя и вычисляют что-то,

14:12.040 --> 14:13.680
но мы их особо не контролируем.

14:13.680 --> 14:22.840
Но вот в крутинах есть возможность из родительской крутины достать несколько дочерних,

14:22.840 --> 14:25.400
и у нас будет явная взаимосвязь между ними.

14:25.760 --> 14:31.080
То есть мы в любой момент из родительской крутины сможем узнать, какие у нее есть дочерние,

14:31.080 --> 14:35.000
их там, например, отменить, узнать какой-то дополнительный статус и так далее.

14:35.000 --> 14:38.320
Опять же, чуть позже сегодня в рамках лекции мы увидим примеры.

14:38.320 --> 14:43.880
И вот такая взаимосвязь позволяет нам грамотно устроить, точнее,

14:43.880 --> 14:48.680
выстроить такую каскадную модель отмены всех крутин или обработку ошибок.

14:48.680 --> 14:52.160
Опять же, чуть позже в рамках лекции мы посмотрим, как это делается.

14:52.880 --> 14:55.760
Что еще из плюсов для нас, как для Android разработчиков?

14:55.760 --> 14:59.040
У нас есть отличная полноценная поддержка в Android Jetpack.

14:59.040 --> 15:06.800
То есть практически любая библиотека из Jetpackа от Google уже имеет поддержку крутины,

15:06.800 --> 15:10.800
и мы можем этим пользоваться уже довольно давно, мне кажется пару лет точно.

15:10.800 --> 15:12.920
Идем дальше.

15:12.920 --> 15:18.640
Вот до этого мы просто обсудили, что такое крутины, узнали, как они,

15:18.640 --> 15:21.800
точнее, где они могут выполняться в наших suspend функциях.

15:21.800 --> 15:28.560
Но получается так, что есть suspend функции, эти suspend функции могут вызывать другие suspend функции,

15:28.560 --> 15:30.920
но с чего-то же все это должно начинаться, правильно?

15:30.920 --> 15:35.240
Вот. И все это начинается с двух ключевых элементов.

15:35.240 --> 15:42.440
Первое это крутин-билдеры, по названию можно догадаться, что это такие элементы нашего

15:42.440 --> 15:45.880
аппи из крутин, позволяющие создать новые крутины.

15:45.880 --> 15:50.040
Вот. Но особенность в том, что просто так их создать нельзя,

15:50.040 --> 15:52.360
для этого им нужен крутин-скоп.

15:52.360 --> 15:56.160
И давайте как раз с этими двумя элементами мы познакомимся поближе.

15:56.160 --> 15:59.800
Начнем с билдеров. Здесь я перечисляю, наверное,

15:59.800 --> 16:04.600
сам на из них, причем, мне кажется, главный из них это launch и async, run blocking мы

16:04.600 --> 16:08.880
обсудим немножечко всего лишь. Давайте немного посмотрим на примеры.

16:08.880 --> 16:12.800
Начнем с launch. Launch концептуально очень похоже на поток.

16:12.800 --> 16:19.640
Если посмотрите на слайд, увидите, что мы здесь пытаемся запустить две крутины

16:19.640 --> 16:25.640
с помощью launch. Одна крутина у нас делается на секунду и печатает строчку,

16:25.640 --> 16:28.200
вторая делается на две секунды и тоже печатает строчку.

16:28.200 --> 16:36.520
Вот здесь мы в рамках suspend функции main создали две новых крутины, две дочерних крутины.

16:36.520 --> 16:43.080
Вот. И если я здесь поменяю launch на thread, концептуально реально будет одно и то же.

16:43.080 --> 16:48.120
То есть мы что-то запустили, отправили свободное плавание, там что-то выполним,

16:48.120 --> 16:50.120
но нам не важен результат. Вот это вот такая концепция.

16:50.120 --> 16:56.040
Запустили какую-то крутину, не возвращающую нам результат, а что-то делающее у себя полезное.

16:56.040 --> 17:04.160
Вот. Async же, в свою очередь, это скорее крутина, которая возвращает нам результат,

17:04.160 --> 17:07.480
какой-то результат в будущем, отложенный результат.

17:07.480 --> 17:11.560
Вот. Аналогию можно привести с executor и функции submit,

17:11.560 --> 17:14.600
которые мы рассматривали на предыдущей лекции по многопоточности.

17:15.480 --> 17:19.880
Это функция, я имею в виду функция async, она возвращает defret,

17:19.880 --> 17:24.240
который как раз и является таким результатом отложенной операции.

17:24.240 --> 17:27.840
И здесь мы делаем ровно то же самое, что в предыдущем слайде,

17:27.840 --> 17:30.680
только не печатаем строчку, а возвращаем ее после дилея.

17:30.680 --> 17:36.400
И в самой последней строчке мы дожидаемся ответа от двух наших крутин.

17:36.400 --> 17:42.920
Вот. Но главная особенность в отличие от потоков и executor сервиса,

17:42.920 --> 17:48.480
через который мы могли бы ссабмитить задачку, здесь мы крутины приостанавливаем.

17:48.480 --> 17:53.560
То есть мы можем всю эту функцию даже вызвать на Main-потоке и не особо беспокоиться о том,

17:53.560 --> 17:58.440
что мы как-то сильно заблочим основной поток и не дадим возможность ему отрисовывать наш UI.

17:58.440 --> 18:04.280
Потому что сначала мы довольно практически моментально создадим две новых крутины.

18:04.280 --> 18:08.560
Эти крутины могут выполняться на Main-потоке, здесь нам это особо не важно.

18:08.560 --> 18:18.240
Дилей, кстати, это тоже одна из со спин функций, которая не блокирует поток текущий.

18:18.240 --> 18:28.720
Она приостанавливает выполнение текущим потоком и потом возвращает в активное действие текущий

18:28.720 --> 18:33.000
поток спустя то время, которое было передано в функции дилей.

18:33.000 --> 18:37.840
А с самой последней строчкой мы также приостанавливаем наших крутины, дожидаемся ответа

18:37.840 --> 18:41.720
и сама вся функция Main вернет нам результат.

18:41.720 --> 18:50.680
Run blocking – это такой особенный вид крутин билдера. Его отличие в том, что он блокирует основной,

18:50.680 --> 18:56.320
ну или вообще тот поток, на котором был запущен, до тех пор, пока все, что находится внутри его

18:56.320 --> 19:03.360
action кода, то есть внутри лямбдочки, который мы ему передаем, до тех пор он будет заблокирован,

19:03.360 --> 19:07.080
если ждет выполнения той или иной suspend функции или крутины.

19:07.080 --> 19:14.280
В чем еще важная особенность, которую я не назвал, но буквально сейчас это обсудим.

19:14.280 --> 19:22.920
На примере с и Async и с Launch я самой первой строчкой вызываю функцию крутин scope. Почему?

19:22.920 --> 19:29.240
Повторюсь, при создании крутин есть два важных элемента, которые стоит рассмотреть.

19:29.240 --> 19:36.520
Это крутин билдеры, а второе это крутин scope. Так вот, билдеры типа Async и Launch требуют

19:36.520 --> 19:42.600
крутин scope для запуска. По факту они вообще являются extension функциями крутин scope,

19:42.600 --> 19:51.040
и это неспроста. Как раз таки крутин scope нам нужен для того, чтобы быть некой входной точкой в

19:51.040 --> 19:57.000
крутины и явно обозначать ограничительный какой-то момент, ограничительный фактор того,

19:57.000 --> 20:03.480
где наши крутины могут работать и сколько по времени, грубо говоря. То есть мы явно

20:03.480 --> 20:10.320
контролируем жизненный цикл наших крутин с помощью крутин scope. И вот в самих extension

20:10.320 --> 20:14.680
функциях у нас есть довольно много полезных параметров, которые мы точно будем использовать

20:14.680 --> 20:21.440
как на протяжении лекции, так и дальше уже в ходе нашей практики. Первое это крутин контекст.

20:21.440 --> 20:29.640
Довольно важная штука, позволяющая нам из одной крутины передавать данные другой дочерней крутина.

20:30.120 --> 20:35.960
Так как это крутин билдеры, у нас есть возможность от родительской крутины передать всю необходимую

20:35.960 --> 20:43.000
информацию дальше дочерним крутином. Ровно для этого и нужен крутин контекст. Дальше есть параметр

20:43.000 --> 20:48.760
start, крутин start. Он позволяет нам регулировать способ запуска. То есть мы можем крутину создать

20:48.760 --> 20:55.080
не сразу, а лениво. Например, запланировать какую-то задачку в будущем и затем ее в какой-то

20:55.080 --> 21:00.680
момент запустить. Опять же в теме по многопоточности я приводил пример, как я это делал с помощью

21:00.680 --> 21:07.080
concurrent hash map и туда клал наши отложенные задачки. И только потом в какой-то момент запускал.

21:07.080 --> 21:13.480
Ну и конечно же третьим параметром мы передаем саму функцию блок, в которой и будем выполнять

21:13.480 --> 21:20.280
все то, что нужно выполнить текущей крутине. Важно тут подметить, что она является suspend.

21:20.280 --> 21:27.880
Благодаря этому мы сможем внутри блок функции вызывать другие suspend функции и приостанавливать

21:27.880 --> 21:36.480
наши крутины. В завершение по этой теме важно усвоить то, что крутин scope является входной точкой в

21:36.480 --> 21:43.000
крутина. То есть не имея крутин scope у вас практически не получится создать нормальные крутины в самом начале.

21:43.000 --> 21:50.000
То есть выйти из этого нашего обычного мира с обычными функциями в мир крутин. Так что мы

21:50.000 --> 21:55.560
сегодня увидим много примеров, где то тут, то там мы достаем наш крутин scope, либо создаем его

21:55.560 --> 22:00.720
сами вручную и на основе этого крутин scope создаем наши первые крутины. Вообще крутин scope

22:00.720 --> 22:08.400
довольно важная вещь и такая фундаментальная, с нее все и начинается. Что дальше? Дальше то, что наш

22:08.400 --> 22:14.920
крутин scope знает про остальные крутины. Из него информацию можно вытащить через крутин контекст и

22:14.920 --> 22:21.960
как-то косвенно повлиять на другие крутины, либо вытащить мета информацию. В общем сценариев

22:21.960 --> 22:28.240
использованы довольно много. И конечно же у крутин scope есть возможность отменить все дочерние крутины,

22:28.240 --> 22:35.680
которые были созданы в рамках него. Сам интерфейс крутин scope довольно минимален, в общем у него

22:35.680 --> 22:40.600
есть только возможность вытащить крутин контекст, но поверьте нам этого будет достаточно, как раз из

22:40.600 --> 22:47.040
крутин контекста можно вытащить много полезной информации. Давайте попробуем его создать.

22:47.040 --> 22:53.080
Создадим наш первый крутин scope сами вручную. Делается это довольно просто, также как и любой

22:53.080 --> 22:57.720
другой объект. Мы можем создать его с помощью конструктора, передать ему либо пустой крутин

22:57.720 --> 23:05.400
контекст, либо вообще ничего. Из-под коробки как раз и будет создан mt-cruitint-context. А на основе

23:05.400 --> 23:12.080
него дальше мы запускаем, ну во-первых создаем, а потом мы запускаем наши крутины. Ровно это я и

23:12.080 --> 23:18.960
сделал на слайде. Создал scope, на основе scope создал нашу первую крутину. Вот там может быть что-то

23:18.960 --> 23:26.600
полезное сделал, а сама функция launch возвращает нам job. Давайте поймем, что такое job. Job это

23:26.600 --> 23:32.040
абстракция над жизненным циклом крутины. У нее есть возможность отслеживать то, в каком сейчас

23:32.200 --> 23:37.480
состояние она находится и опять же косвенно как-то на нее влиять с помощью API, которая

23:37.480 --> 23:43.720
предоставляет интерфейс job. Тут пишу, что как раз job имеет функцию отмены, это мы будем использовать

23:43.720 --> 23:50.320
дальше в примерах. И что еще интересно, job является элементом крутин контекста. Как помните,

23:50.320 --> 23:57.600
при создании крутин мы передаем крутин контекст, и вот job является одним из элементов крутин контекста,

23:57.600 --> 24:03.680
то есть он является ее частью. Вот как раз явно здесь это и показано. Мы видим, что есть объявлен

24:03.680 --> 24:10.520
интерфейс job, он наследуется от крутин контекст.element, соответственно, является элементом крутин контекста,

24:10.520 --> 24:16.040
и есть полезное API для нас. Первые три свойства — это возможность вытащить информацию о том,

24:16.040 --> 24:23.960
в каком состоянии сейчас находится job и соответственно сама крутина, которой он относится. А также есть

24:23.960 --> 24:30.840
функция start, позволяющая нам запустить крутину до этого созданного лениво, и функцию cancel,

24:30.840 --> 24:35.640
которая позволит нам отменить текущую крутину и все ее дочерние крутины, как мы поймем дальше.

24:35.640 --> 24:43.160
Также есть функция join, это практически аналогия тому, что есть у потоков, когда мы у объекта

24:43.160 --> 24:49.720
потока можем вызывать join и дождаться выполнения текущего потока ровно то же самое крутиной. Мы

24:49.720 --> 24:54.920
можем, имея ссылку на job, заджойниться к ней и дождаться завершения той или иной крутины.

24:54.920 --> 25:01.360
Окей, давайте попробуем подробно рассмотреть, в каких состояниях может быть наша крутина. Первое,

25:01.360 --> 25:06.520
просто разберем все стейты, которые тут есть. Это new, когда мы крутину только создали, active,

25:06.520 --> 25:13.200
когда она уже в активной фазе действия, completing и completed, соответственно, когда она пытается

25:13.200 --> 25:17.800
завершиться или уже завершена, и то же самое с отменой. То есть мы либо в процессе отмены,

25:17.800 --> 25:25.480
либо уже полностью все отменили и крутина уже не активна. И вот информацию о стейтах мы просто

25:25.480 --> 25:33.720
так сами не вытащим, но понимание того, в каком состоянии мы сейчас находимся, мы можем вытащить

25:33.720 --> 25:38.280
с помощью наших properties, с помощью наших свойств. Из active, из cancelled, из completed. Попробую

25:38.280 --> 25:43.360
продемонстрировать как раз на примере. То есть вот допустим, мы только создали нашу крутину,

25:43.360 --> 25:48.920
она сейчас находится в статусе new, соответственно, все флажочки будут возвращать false. Если же мы

25:48.920 --> 25:56.920
перешли в активную фазу действия, то наша крутина выйдет в состояние active, а флажочек из active

25:56.920 --> 26:01.760
будет возвращать true. Итак, по аналогии, на самом деле мы можем разобрать все стейты в момент

26:01.760 --> 26:07.800
завершения, ну попытки завершения, потом в момент непосредственного завершения, дальше в момент

26:07.800 --> 26:16.800
отмены крутин, и после того, как крутина полностью завершилась, мы увидим, что и cancelled true,

26:16.800 --> 26:22.600
и completed true, потому что мы ее попытались отменить и успешно это сделали. Так что с помощью

26:22.600 --> 26:27.240
флажочков можно косвенно понять, что сейчас происходит с крутиной и выполнить какую-то бизнес

26:27.240 --> 26:37.080
логику вокруг этого. Давайте попробуем рассмотреть, как работает JDOB на примерах. Опять же, вернемся

26:37.080 --> 26:44.400
к нашему примеру из предыдущего слайда, где мы просто запускаем наши две крутины. Здесь мы добавляем,

26:44.400 --> 26:51.080
как мы теперь знаем, launch возвращает job, поэтому можем присвоить job1 и job2 к нашим крутинам,

26:51.080 --> 26:59.040
после чего мы дождемся выполнения этих двух их обеих крутин и напечатаем значение, свойств

26:59.040 --> 27:05.240
из наших job. Соответственно, в конце мы увидим и строчки, которые были напечатаны в крутинах,

27:05.240 --> 27:12.000
и статусы каждой из крутин. Из active false, потому что мы крутину уже дождались, и она полностью

27:12.000 --> 27:18.440
выполнила все, что нужно, а из completed true, по яным признакам, крутина завершилась, и из completed

27:18.440 --> 27:26.360
тоже должен быть true. Дальше мы рассмотрим, как еще можно JDOB использовать в коде. Главная его

27:26.360 --> 27:33.320
особенность в том, что есть возможность трека, текущее состояние крутины, ее жизненный цикл. Как я

27:33.320 --> 27:40.400
уже сказал ранее, job является элементом крутин контекста, а что там есть еще? Опять же, мы

27:40.400 --> 27:49.640
поняли, что в крутин скопе есть крутин контекст, и job является крутин контекстом, а что еще? Что

27:49.640 --> 27:56.240
еще там может находиться? Давайте вообще рассмотрим сам интерфейс крутин контекста. Сам по себе

27:56.240 --> 28:03.200
контекст — это такой универсальный способ группировать элементы между собой. Что главное,

28:03.200 --> 28:09.880
стоит выяснить, что крутин контекст передается от родителя к дочерним крутинам, и концептуально

28:09.880 --> 28:15.120
он очень похож на map или set, то есть мы можем обратиться к крутин контексту и вытащить из

28:15.120 --> 28:23.920
него элементы по ключу, а ключом будет являться как раз один из интерфейсов, который наследуется от

28:23.920 --> 28:28.960
крутин контекста точка элемент. То есть мы можем передать какой-то элемент и вытащить текущее

28:28.960 --> 28:35.320
значение по ключу. Крутин контекст определяет поведение крутин, то есть из него мы вытащим

28:35.320 --> 28:40.240
информацию, на каком потоке, например, нужно выполнять ту или иную крутину, какое у нее название,

28:40.240 --> 28:47.000
как мы будем обрабатывать исключения и так далее. То есть это важная контекстная информация,

28:47.000 --> 28:51.920
которая передается от одной крутини к другой. Соответственно, он содержит набор элементов,

28:51.920 --> 28:57.040
которые мы можем вытащить внутри крутин и как-то с ними работать, и есть возможность

28:57.040 --> 29:03.000
переопределять элементы, если нам это потребуется. Сам фреймворк крутин, он это делает на регулярной

29:03.000 --> 29:08.480
основе, каждый раз, когда вы создаете новую крутину, он передает контекст от родительских

29:08.480 --> 29:13.840
дочерней и переопределяет некоторые крутины элементы внутри, например, как раз таки джоб,

29:13.840 --> 29:21.280
мы это посмотрим чуть позже. Из базовых элементов я бы выделил как раз джоб, крутин name, который нам

29:21.280 --> 29:28.840
часто будет необходим просто для дебаг информации или просто если мы хотим вытащить информацию о том,

29:28.840 --> 29:34.040
где мы сейчас находимся, в какой крутине, вот это можно сделать через крутин name. Есть крутин

29:34.040 --> 29:39.080
dispatcher, сегодня его рассмотрим, он необходим для переключения потоков. Есть крутин exception

29:39.080 --> 29:46.160
handler, который необходим нам для обработки исключений, тоже его сегодня обсудим. Как я уже

29:46.160 --> 29:51.720
сказал ранее, есть элемент, который является крутин контекстом, мы в принципе не ограничены тем,

29:51.720 --> 29:59.280
что есть в библиотеке изначально, мы можем объявить свой элемент крутин контекста и его

29:59.280 --> 30:06.280
затащить в текущий крутин контекст в целом. Здесь особо этого делать не будем, это нужно только в

30:06.280 --> 30:10.680
конкретных случаях, просто знайте, что у вас есть такая возможность по аналогии с крутин name,

30:10.680 --> 30:19.240
крутин dispatcher, вы можете создать свой необходимый вам для работы крутин. А здесь же смотрите,

30:19.240 --> 30:25.000
попробую продемонстрировать такой пример. Так как у нас крутин name является элементом крутин

30:25.000 --> 30:29.800
контекста, я попробую это сделать, сработать с крутин name как с элементом крутин контекста,

30:29.800 --> 30:35.920
а потом вытащить из этого крутин контекста по ключу нужное мне значение. То есть первой строчкой я

30:35.920 --> 30:41.080
создаю крутин name, потом к этому же крутин name я обращаюсь к контексту и пытаюсь вытащить

30:41.080 --> 30:48.520
значение имени по ключу. И дальше вытаскиваю как раз имя, а если бы я хотел вытащить какой-то

30:48.520 --> 30:54.000
другой крутин элемент, например job, которого я еще туда не передавал, то логично, что я получу

30:54.000 --> 31:01.840
null. Вот собственно так и происходит. Что дальше? Контексты, как я уже сказал ранее, можно объединять

31:01.840 --> 31:09.240
либо как-то видоизменять. Это и происходит в момент создания крутин. Мы пытаемся получить

31:09.240 --> 31:14.640
текущую мапу этих элементов, потом с ними выполняем определенную логику с помощью функций

31:14.640 --> 31:21.240
fault или дополнительных функций, которые заложены внутри имплементации создания крутин. Мы же можем

31:21.240 --> 31:27.000
это использовать у себя в какой-то бизнес логике, например, захотели на основе текущего крутин контекста

31:27.000 --> 31:32.160
получить копию, но с измененными элементами внутри. Мы это можем сделать ровно так же, как мы это

31:32.160 --> 31:39.960
обычно делаем с мапой. По ключу обращаемся, переименовываем, точнее, переназначаем какой-то

31:39.960 --> 31:48.920
элемент по ключу и идем дальше. Вот ключевой момент, что в билдерах в момент создания наших

31:48.920 --> 31:56.760
крутин происходит ровно то, что я описал. Берется из родительской крутины текущий крутин-контекст,

31:56.760 --> 32:02.640
он используется практически полностью для создания новой дочерней крутины, только еще

32:02.640 --> 32:08.920
создается новый job. Мы это рассмотрим буквально на следующих слайдах. Давайте глянем, как это

32:08.920 --> 32:20.280
выглядит. Смотрите, сначала я пытаюсь создать крутин name и новый крутин элемент job. Их связку,

32:20.280 --> 32:26.560
то есть как раз через плюсик я создаю новый крутин-контекст. Я пытаюсь передать эти данные

32:26.560 --> 32:33.680
в мою новую только что созданную крутину через крутин билдер лаунч. А дальше пытаюсь понять,

32:33.680 --> 32:39.040
а что же у меня с элементами текущего крутин-контекста. Так как я нахожусь внутри

32:39.040 --> 32:44.280
скопа, у меня есть возможность вытащить крутин-контекст и дальше как мапе обратиться и по ключу вытащить нужное

32:44.280 --> 32:52.120
мне значение. Так вот, мы видим, что крутин name в моем случае будет печатать то имя, которое я

32:52.120 --> 32:58.920
изначально заложил. Я получу true. Но в случае, если я захочу получить job, соответствия не будет.

32:58.920 --> 33:07.000
Почему? Потому что при создании новой крутины берется весь крутин-контекст текущий, создается

33:07.000 --> 33:14.480
новый job и присваивается по ключу интерфейса job вот в этот новый крутий-контекст. Главное,

33:14.480 --> 33:21.000
что нужно запомнить, что при вызове и лаунч и ассинк сама система, то есть сам фреймворк,

33:21.000 --> 33:28.480
будет за вас создавать job и делать его наследником всех новых крутин внутри только что созданной.

33:28.480 --> 33:34.400
Получается последней строчкой, я пытаюсь вытащить список детей у текущей крутины,

33:34.400 --> 33:42.640
и первый же элемент будет равен тому job, который я создал ранее. Как раз-таки это сигнализирует о том,

33:42.640 --> 33:52.800
что я вижу то, что есть job, который был создан за меня, а есть job, который создал я сам,

33:52.800 --> 33:58.880
и он будет являться только дочерним, точнее, родительским элементом для только что созданного

33:58.880 --> 34:09.600
job. Этот пример еще разберем чуть дальше, позже, когда будем обсуждать тему отмены крутин и

34:09.600 --> 34:18.040
обработки ошибок, потому что там создание job вместо нас играет ключевую роль и поймем почему.

34:18.040 --> 34:25.640
Итого, у нас крутин-билдеры создают новый job на основе родительского и из крутин-контекста,

34:25.640 --> 34:31.960
а в верхнем уровне вся наша картина выглядит следующим образом. У нас сначала должен быть

34:31.960 --> 34:37.280
крутин-скоп, на этом крутин-скопе у нас есть возможность создать с помощью крутин-билдеров

34:37.280 --> 34:44.040
наши крутины. В лекции и вообще в практике мы будем часто использовать либо launch, либо async.

34:44.040 --> 34:50.480
Дальше внутри этих крутин-билдеров у нас есть возможность работать со suspend функцией,

34:50.480 --> 34:55.440
в рамках которой мы можем вызывать другие suspend функции. Тут уже начался такой

34:55.440 --> 35:01.400
мир suspend функций, в котором мы можем выполнять всю нашу бизнес логику.

35:01.400 --> 35:12.000
А крутин-функции могут вызывать другие части из библиотеки крутин, например,

35:12.000 --> 35:17.600
крутин-скоп-билдеры, как крутин-скоп или vis-контекст, опять же их примеры мы посмотрим чуть

35:17.600 --> 35:23.400
позже, но по факту они являются также suspend функциями, которые и можно вызывать только

35:23.400 --> 35:29.320
внутри контекста других suspend функций. Так что в верхнем уровне, наверное, картина выглядит так.

35:29.320 --> 35:36.720
И, наверное, с фундаментальной частью пока что на этом все. Дальше коснемся темы отмены,

35:36.720 --> 35:40.560
а сейчас попробуем отвечать на вопросы, которые уже, наверное, скопились.

35:40.560 --> 35:53.040
Первый вопрос. Часто ли сейчас используется RectJava? Давайте я отвечу так. Я, по-моему,

35:53.040 --> 35:58.640
уже немного отвечал и раскрывал этот вопрос на предыдущей лекции. На мой взгляд, RectJava

35:58.640 --> 36:04.800
все меньше и меньше используется на практике, где-то в бою в каких-то

36:04.800 --> 36:13.880
продакшн-приложениях готовых. Почему? Потому что фреймворк крутин и фреймворк flow и stateflow,

36:13.880 --> 36:18.480
которые мы сегодня немного рассмотрим, он практически полностью закрывает те возможности,

36:18.920 --> 36:25.300
которые нам давал RectJava. В принципе, нет сейчас никакого смысла изучать целый отдельный фреймворк и

36:25.300 --> 36:31.280
тащить огромный объем DexCount для того, чтобы решать те задачи, которые мы уже можем решать с помощью

36:31.280 --> 36:39.760
крутин и flow. Так что мой ответ сейчас все реже и реже. И, наверное, такой совет всем начинающим

36:39.760 --> 36:45.440
разработчикам все же подробно изучить именно тему крутин и flow, а в случае необходимости,

36:45.440 --> 36:52.840
при хорошем погружении в тему flow вы сможете понять, как устроен RectJava, как второй, так и третий.

36:52.840 --> 36:59.360
В общем, здесь проблем не будет. Но я бы сфокусировался все же на крутинах на текущий момент.

36:59.360 --> 37:04.360
Как работает крутина под капотом, на каких трессах они выполняются? Все зависит от того, на каком

37:04.360 --> 37:08.800
диспатчере и какой шедулер используется во время исполнения. Наверное, ключевая мысль,

37:08.800 --> 37:13.920
возможно, которую я не очень хорошо донес в рамках первой части, есть потоки, есть крутины.

37:14.160 --> 37:20.560
Крутины будут исполняться на каком-то потоке или на каком-то пулле потоков. Это зависит от диспатчера.

37:20.560 --> 37:28.480
Они не блокируют поток, они только лишь позволяют эффективно использовать текущие потоки и давать им

37:28.480 --> 37:33.960
возможность заниматься чем-то другим, пока наша крутина бездействует, она приостановлена.

37:33.960 --> 37:42.760
Соответственно, вкратце, как работают крутины под капотом, я сегодня рассказывать не буду. Я

37:42.760 --> 37:50.680
специально привел пару... Я, по-моему, привел в конце ролик от хорошего автора, который объясняет то,

37:50.680 --> 37:54.800
как устроена крутина под капотом, во что они трансформируются, во что трансформируются

37:54.800 --> 38:01.880
вообще с аспент-функцией, которые мы с вами написали. Там вся происходит магия с continuation,

38:01.880 --> 38:11.560
там происходит вся магия с таким набором действий, где мы можем в любой момент, в точке

38:11.560 --> 38:18.040
остановки приостановиться, запомнить то, в каком моменте мы остановились, закэшировать,

38:18.040 --> 38:23.320
сохранить весь стэк функции и затем его прихранить, а после чего, как, знаете,

38:23.320 --> 38:27.800
как какую-то дискету или как какое-то сохранение вытащить и возобновить именно в том месте,

38:27.800 --> 38:34.080
где мы представились в прошлый раз. Эта вся концепция хорошо объясняется, по-моему,

38:34.080 --> 38:39.560
в полторачасовом докладе, так что я решил, что в рамках текущей сегодняшней встречи объяснять

38:39.560 --> 38:45.920
это особо не буду. Но ссылочку обязательно прикреплю. Вообще, в целом, есть набор хороших

38:45.920 --> 38:52.240
роликов от Романа Елизарова, который является одним из авторов крутин. Он объяснял также

38:52.240 --> 38:57.720
в своих докладах то, как устроена крутина под капотом и во что они трансформируются с помощью

38:57.720 --> 39:01.640
компилятора. Точнее, во что трансформируется с аспент-функцией с помощью компилятора.

39:01.640 --> 39:09.840
Так, что такое крутина? В рассказе лекции говорили вот крутина активна или нет,

39:09.840 --> 39:14.400
а на слайде Job Lifecycle. Так что значит создать, запустить крутину? Это выполняемый код внутри

39:14.400 --> 39:23.240
скопа? Да, то есть концептуально это то, что очень похоже, в общем, на поток. Это набор каких-то

39:23.240 --> 39:30.680
вычислений, которые проводит текущий поток. То есть, вот мы строчка за строчкой что-то

39:30.680 --> 39:34.840
выполняем, но особенность крутин в том, что вот на определенной строчке мы можем приостановить

39:34.840 --> 39:40.520
свое выполнение и возобновить ее в какой-то определенный момент в будущем. Вот это и главная

39:40.520 --> 39:47.320
особенность. А Job это такая абстракция над этой крутиной, то есть Job просто нам сигнализирует о

39:47.320 --> 39:54.760
том, в каком статусе находится вот этот вот набор вычисляемых инструкций вот сейчас в рантайме.

39:54.760 --> 40:03.920
Вот всего лишь так. И запустить крутину, это значит начать выполнять набор данных,

40:03.920 --> 40:08.960
набор кода, который мы сами прописали у себя в программе. Аналогия очень похожа на поток,

40:08.960 --> 40:14.800
только это скажем так под часть потока набор кода, который выполняется внутри определенного потока.

40:14.800 --> 40:22.080
Так, тут есть вопросы конкретно по слайдам. Я боюсь, что я не буду сейчас прям возвращаться,

40:22.080 --> 40:26.960
то там анимация и так далее мы довольно долго будем ждать. Пропущу вопросы, где мы прям явно

40:26.960 --> 40:33.920
к какому-то слайду переходим. Дальше следующий вопрос. Ключ контекста типа класса извлекается?

40:33.920 --> 40:41.000
Да, что типа того? То есть мы там, кстати, это прикольный подход, связанный с обращением к маппи,

40:41.000 --> 40:45.960
к крутин-контексту. У нас есть возможность, в принципе, я вам рекомендую посмотреть на то,

40:45.960 --> 40:52.040
как устроены интерфейсы крутин-контекст-элементов. Мы действительно по названию интерфейса сможем

40:52.040 --> 40:58.200
типа название интерфейса использовать как ключ к маппи крутин-контексту. Мне кажется,

40:58.200 --> 41:04.320
такой поход вообще довольно редко используется где-либо, я вот его видел только в библиотеке крутин.

41:04.320 --> 41:10.760
Можно еще раз объяснить, пожалуйста, что мы складываем при создании крутин-контекста. Они

41:10.760 --> 41:17.000
складываются как что? Как строки? У них же разный класс, нет? Еще раз, мы складываем... Смотрите,

41:17.000 --> 41:21.800
в Kotlin есть возможность переопределить оператор плюсика, то есть переопределить

41:21.800 --> 41:27.800
логику, которая дает вот этот вот плюсик. Соответственно, там логика следующая. У нас есть

41:27.800 --> 41:32.920
крутин-контекст-элемент и есть другой крутин-контекст-элемент. И переопределена функция

41:32.920 --> 41:39.600
оператор сложения двух крутин-контекст-элементов. Они вместе с собой формируют новый крутин-контекст

41:39.600 --> 41:45.320
сам по себе. Грубо говоря, у нас есть маппы из одного элемента, мы ее складываем с маппой из другого

41:45.320 --> 41:51.320
элемента и по итогу получаем маппу из двух элементов. Грубо говоря, то, что происходит при

41:51.320 --> 41:59.840
сложении двух элементов, как у меня было на слайде. То есть, по сути, крутин-это не замена потока,

41:59.840 --> 42:03.880
а удобный эффективный инструмент для работы с потоками. Что-то типа того. На мой взгляд,

42:03.880 --> 42:08.880
так можно выразиться. Да, то есть у нас есть концепция потоков, которые никуда не уходят,

42:08.880 --> 42:13.840
а есть крутины, которые живут в рамках определенных потоков, и вот эти крутины мы можем в любой момент

42:13.840 --> 42:19.120
остановить. В любой момент, который мы явно задекларируем. Давайте это я явно сам буду

42:19.120 --> 42:23.600
и подсвечивать в рамках лекции. То есть не в любой рандомный момент мы можем взять и приостановиться,

42:23.600 --> 42:31.840
а скорее в определенных точках, которые мы явно сами задекларируем в коде. А так, да, есть потоки,

42:31.840 --> 42:36.000
они никуда не делись, с ними также надо уметь работать, и поэтому у нас была целая лекция,

42:36.000 --> 42:41.720
посвященная потокам. А дальше нужно понимать то, что есть крутины, которые дают нам очень много

42:41.800 --> 42:45.680
преимуществ. То есть мы используем крутины как раз, чтобы упростить себе жизнь и дать

42:45.680 --> 42:51.560
определенные гарантии по работе с отменной действий, с обработкой исключений, может быть,

42:51.560 --> 42:57.080
с эффективным использованием тех же самых потоков. В общем, это такой удобный инструмент для нашей

42:57.080 --> 43:06.560
поседневной работы. Так, вроде бы вопросы кончились, давайте пойдем дальше. Перейдем к теме отмены

43:06.560 --> 43:13.760
крутин. Что тут? Я уже сказал ранее, что у крутин скопа есть возможность отменить все дочерние

43:13.760 --> 43:18.720
крутины. Делается это довольно просто. Вот у нас есть интерфейс крутин скопа, на нем мы вызываем

43:18.720 --> 43:25.960
функцию cancel. Также мы здесь можем передать причину cancellation exception, но обычно даже это

43:25.960 --> 43:31.880
не передается, просто по дефолту вызывает функцию cancel. У самого интерфейса job также есть возможность

43:31.880 --> 43:39.200
вызвать cancel. То есть это вот наверное два самых простых способа отменить нашу крутину. Давайте

43:39.200 --> 43:45.080
посмотрим, как это выглядит на практике. Вот я создал свой крутин скоп и дальше на основе

43:45.080 --> 43:53.160
этого крутин скопа создал три крутины. А дальше их всех вместе я отменяю с помощью нашего скопа.

43:53.160 --> 43:59.040
На диаграмме, на самой схемке выглядит вот так, что есть крутин скоп, на его основе я создал три

43:59.040 --> 44:06.200
крутины. Потом крутин скопу передал намерение все это дело отменить, он каскадно прошелся по всем

44:06.200 --> 44:11.640
своим дочерним крутинам и попросил их сделать ровно то же самое. После чего они уже перешли в

44:11.640 --> 44:19.280
состояние cancel. Получается, что отмена крутин скопа отменяет все дочерние крутины, это стоит

44:19.280 --> 44:29.000
запомнить. Что дальше? Дальше у нас есть возможность отменять с помощью интерфейса job определенную

44:29.000 --> 44:35.040
крутину. Здесь я сделал ровно то же самое, только теперь не на скопе отменяю все крутины, а только на

44:35.040 --> 44:41.280
конкретно из них. И возвращаясь к схемке, я именно крутину два пытаюсь отменить. Она отменяется,

44:41.280 --> 44:47.040
но никак не влияет на другие крутины, которые были созданы рядом с ней. Они также продолжают

44:47.040 --> 44:55.000
работу как ни чем не бывало. Давайте рассмотрим схемку поглубже, по детальнее, если у нас уже

44:55.000 --> 45:02.440
вот такая есть довольно большое дерево крутин. Я пытаюсь дочернюю крутину отменить. Она на самом

45:02.440 --> 45:08.320
деле никак не влияет на свою родительскую крутину. Соответственно и самой родительской крутины все

45:08.320 --> 45:15.240
будет хорошо, и с дочерними крутинами также будет все хорошо. Но особенность в том, что после отмены

45:15.240 --> 45:19.920
крутины вот этот интерфейс job он уже не может быть использован для создания новых крутин. То есть

45:19.920 --> 45:29.440
на его основе мы не можем создать новые крутины. Как могли бы без отмены изначальной. Повторюсь,

45:29.440 --> 45:35.600
при отмене крутин у нас отменяются все дочерние крутины. Сам родитель может не отменяться,

45:35.600 --> 45:42.160
если пришел ивент отмены от одного из его дочерних крутин. И после отмены job не может

45:42.160 --> 45:49.640
быть использован для создания новых крутин. Что дальше? Попробуем рассмотреть уже какое-то

45:49.640 --> 45:56.160
более-менее нормальный пример, где мы выполняем какую-то логику, а потом захотели в параллеле

45:56.160 --> 46:04.800
где-то отменить нашу текущую крутину. Мы здесь создаем нашу крутину, где пытаемся в цикле пройтись

46:04.800 --> 46:11.280
и напечатать какой-то текущий индекс после определенной задержки. Здесь я 10 раз пытаюсь в цикле

46:11.280 --> 46:17.640
пройтись, делаюсь на 100 мс и печатаю индекс. А в основной крутине, в родительской крутине я

46:17.640 --> 46:26.400
делаюсь на 320 мс. Даю возможность моей дочерни к крутине поработать 3-4 цикла и что-то напечатать

46:26.400 --> 46:32.200
в консоль. А потом ее отменяю, причем еще и join-усь. Параллельно с помощью функции cancel on join она

46:32.200 --> 46:36.680
прям явно и говорит то, что происходит внутри ее имплеметации. Мы первой строчкой cancel job,

46:36.680 --> 46:42.280
а второй пытаемся зажониться к ней и дождаться, когда же она полностью завершит свою работу. После

46:42.280 --> 46:49.280
чего печатаем строчку cancel. Здесь опять же никакой магии не произойдет. То есть мы сначала

46:49.280 --> 46:56.520
напечатали 3 индекса, так как как раз и ждали в родительской крутине 320 мс ровно на 3 итерации,

46:56.520 --> 47:04.240
и затем напечатали строчку cancel, а сама дочерняя крутина приостановила свою работу. Вообще вся

47:04.240 --> 47:12.840
магия по отмене крутин происходит с помощью cancelation exception. У этого интерфейса, точнее вообще

47:12.840 --> 47:20.040
у этого исключения есть специальные скажем флажочки внутри имплементации. То есть сам

47:20.040 --> 47:28.240
фреймворк крутин знает про cancelation exception и по отдельному, ну знаете так, он явно понимает,

47:28.240 --> 47:34.160
что это cancelation exception и выполняет определенную отдельную логику по работе с конкретно с ней.

47:34.160 --> 47:39.960
Либо с его наследниками. Сознанно это для различия между отменой и ошибкой, то есть если мы получили

47:39.960 --> 47:44.480
какую-то ошибку, кинули исключение, то скорее всего это исключение будет отлично от cancelation

47:44.480 --> 47:51.040
exception и мы по-другому обработаем это исключение. Пройдем по другой ветке. Вот я как раз это имел

47:51.040 --> 47:56.680
в виду, вот как раз привел пример из реализации крутин, где мы первые строчки проверяем на

47:56.680 --> 48:02.600
instance cancelation exception, а потом уже, если понимаем, что это не cancelation exception, потом отдаем

48:02.600 --> 48:13.160
обработчику в другую ветку. Вот по-другому работаем в общем с исключением. Что еще важно,

48:13.160 --> 48:23.200
вот до этого в некоторых примерах, как как например delay, это стандартная функция из библиотеки

48:23.200 --> 48:30.280
крутин, есть возможность поддержки отмены. Помните в лекции по многопоточности я рассказывал,

48:30.280 --> 48:36.720
что можно поток приостановить на определенное время и если мы попытаемся завершить поток во

48:36.720 --> 48:43.520
время той же функции slip, то мы кинем interrupted exception. Вот здесь происходит примерно то же

48:43.520 --> 48:49.360
самое, то есть есть стандартный набор функций из крутин библиотеки и вот в каждой из этой

48:49.360 --> 48:57.880
функции в момент саспенда у нас есть возможность кинуть cancelation exception. Вот, как-то так. Этим

48:57.880 --> 49:03.440
можно пользоваться, покажу на примерах как именно. Но главная особенность, так же как и в потоках,

49:03.440 --> 49:11.160
отмена должна быть кооперативной, то есть если у нас карутина выполняет довольно большую сложную

49:11.160 --> 49:18.720
логику и у нее нету так называемых вот этих вот точек приостановок, то есть нет возможности

49:18.720 --> 49:24.480
приостановить текущую карутину, она просто довольно долго выполняет что-то сложное. Вот здесь на слайде

49:24.480 --> 49:30.560
привожу пример, что мы в цикле опять же делаем что-то сложное, вычисляем, печатаем какие-то строчки,

49:30.560 --> 49:37.320
но нигде не приостанавливаем карутину. Так вот, в нашей родительской карутине или в принципе

49:37.320 --> 49:43.240
вообще в какой-то другой карутине не будет возможности по нормальному нашу рабочую карутину

49:43.240 --> 49:51.240
приостановить. То есть здесь мы по итогу дождемся выполнения всех всех итераций и увидим печать

49:51.240 --> 49:58.240
всех наших индексов. Ровно то же самое происходит и с потоками, как помните, мы делали примерно то

49:58.240 --> 50:04.520
же самое, приводили, например, ровно такой же участок кода, только связанный с потоками. Соответственно,

50:04.520 --> 50:13.200
опять же должен быть какой-то механизм, позволяющий нам трекать, а хотят ли нас кто-то, есть ли потребитель

50:13.200 --> 50:19.400
или какая-то сторонняя карутина, которая хочет нас приостановить. Это делается как раз таки с

50:19.400 --> 50:25.560
помощью флажочков мы можем узнать, является ли карутина сейчас активна или нет. В случае, если

50:25.560 --> 50:33.240
такого не является и нас кто-то уже явно попросил приостановиться и сработали внутреннее,

50:33.240 --> 50:39.320
сработала внутренняя реализация по отмене карутины, то вот наш флажочек, означающий то, что карутина сейчас

50:39.320 --> 50:45.640
в активной стадии или нет, будет явно об этом сигнализировать. Вот нас захотел кто-то приостановить,

50:45.640 --> 50:51.640
наш флажочек перешел в статус false, из актив флажочек перешел статус false и мы можем, в данном случае,

50:51.640 --> 50:58.680
очистить ресурсы и завершить всю работу в цикле. Есть более удобный, на мой взгляд, способ, такой

50:58.680 --> 51:04.440
более декларативный что ли. Есть функция ensureActive, то есть она делает примерно то же самое, только у

51:04.440 --> 51:12.560
себя под капотом проверяет статус этого флажочка и мы можем, и причем она еще явно выбросит

51:12.560 --> 51:19.240
conciliation exception, если это не так и это нам позволяет не дробить логику на несколько ветвей типа if false,

51:19.240 --> 51:26.800
а скорее явно хорошо дезакларировать, что у нас в момент, в определенный момент мы проверяем

51:26.800 --> 51:32.080
действительно ли мы сейчас активны, если нет, полностью сворачиваем всю работу, завершаем ее и выходим

51:32.080 --> 51:38.640
из цикла, выходим вообще из функции. Вот бывает, что мы используем ровно ее для вот такой цели,

51:38.640 --> 51:46.800
быстро выйти из функции и завершить свою работу. Вот как раз-таки здесь я и привел в пример то,

51:46.800 --> 51:54.240
как вообще этот интерфейс выглядит. У интерфейса job можно вызвать функцию ensureActive и мы там

51:54.240 --> 52:01.080
проверяем статус флажочка и в случае, если этот флажочек дает false, мы кидаем conciliation exception.

52:01.080 --> 52:08.440
Есть другой способ, это одна из suspend функций под названием yield, которая просит текущей

52:08.440 --> 52:18.280
диспатчер перейти на новый цикл, ну короче, зашедулить какое-то новое вычисление, не выполнять

52:18.280 --> 52:23.240
текущую курутину, а переключиться на что-то другое в рамках потока. Вот, и эта функция yield приходит

52:23.240 --> 52:28.040
нам в стандартной библиотеке и соответственно она также имеет возможность кинуть conciliation exception,

52:28.040 --> 52:35.640
если это уже, ну если нас кто-то до этого попросил полностью завершить работу и отменить текущую

52:35.640 --> 52:42.760
курутину. В общем, главное, что стоит вынести отсюда, это то, что есть стандартный набор функций из

52:42.760 --> 52:49.840
библиотеки крутин и практически у всех из них по дефолту есть вот такая возможность, ну вообще есть

52:49.840 --> 52:56.040
поддержка conciliation exception и отмена крутин. Вот, мы можем ими пользоваться, если захотим, ну либо

52:56.040 --> 53:03.080
явно сами проверять с помощью стейтов у job, который является абстракцией к текущей курутине.

53:03.080 --> 53:09.640
Окей, что еще? Здесь мы рассмотрели то, как мы работаем с лаунчами, то есть с

53:09.640 --> 53:14.040
курутинами, которые мы когда-то запустили и пошли дальше, а что делать со сингком,

53:14.040 --> 53:20.520
который возвращает результат. Здесь, на самом деле, примерно то же самое, только есть особенности при

53:20.520 --> 53:25.920
вызове await, да, так как await нам возвращает результат, соответственно не всегда мы получим то, что хотим,

53:25.920 --> 53:33.200
в случае отмены. Вот, здесь я пытаюсь как раз в рамках моей крутины подождать и потом вернуть

53:33.200 --> 53:38.320
результат в виде стренги async result, а в основной родительской крутини я пытаюсь заделается на

53:38.320 --> 53:45.040
секунду, потом дождаться результата и отменить. Да, здесь, возможно, надо было с ручками поменять

53:45.040 --> 53:51.160
местами. Да, вот я как раз это и сделал, забыл про слайд следующий. В общем, здесь я просто дожидаюсь

53:51.160 --> 53:57.680
крутины и отменяю. Здесь в этом, на самом деле, не так много смысла. Я просто дождался, а потом ее

53:57.680 --> 54:02.120
попросил отмениться, но она и так уже в завершенном состоянии, здесь ничего не произойдет. А в случае,

54:02.120 --> 54:07.360
если я поменяю строчку местами, то есть сначала попрошу отмениться, а потом дождаться результата,

54:07.360 --> 54:13.600
то я славлю job consolation exception, вот, потому что результата как такового у меня на руках нет.

54:13.600 --> 54:20.040
По теме крутины, это все. Главное, что стоит вынести, что есть consolation exception,

54:20.040 --> 54:24.640
он по отдельному обрабатывается внутри фармворка крутин, мы с ним можем, в принципе,

54:24.640 --> 54:33.200
работать сами, мы можем даже наследовать свои exception от данного и как-то явно у себя в логике

54:33.200 --> 54:37.360
уметь его обрабатывать. Я, если честно, особо таким никогда не занимался, но, в принципе,

54:37.360 --> 54:46.240
у вас такая возможность есть, опять же, welcome, вдруг найдете ему применение. Что дальше? Дальше,

54:46.560 --> 54:52.560
на мой взгляд, одна из самых сложных, особенно для первой лекции, где мы погружаемся в тему

54:52.560 --> 55:02.280
крутин, вот, тема с отменой крутин, мне кажется, дается всегда тяжелее всего. Почему? На мой взгляд,

55:02.280 --> 55:09.080
просто потому что сам API крутин и сам фреймворк, который у нас есть на руках, позволяет нам,

55:09.080 --> 55:15.320
как разработчикам, слишком много всего и часть кода, которую мы можем в теории написать и

55:15.720 --> 55:21.760
часто делаем так, не приводит к ожидаемому результату. Опять же, чуть позже на слайдах я попробую

55:21.760 --> 55:26.760
привести примеры, почему так. И, возможно, из-за этого, из-за того, что мы, как разработчики,

55:26.760 --> 55:32.240
можем написать много всего, которое, по нашему мнению, может или должно работать, не является,

55:32.240 --> 55:39.320
если работать не так, как задумано нами, вот, и приводит к ошибкам, приводит к каким-то проблемам

55:39.320 --> 55:46.560
на проде, в общем, приводит к какому-то полному непониманию у разработчиков, как же это вообще

55:46.560 --> 55:55.720
вся тема работает и как ее грамотно обработать у себя в коде, обработку ошибок, имею ввиду. Что

55:55.720 --> 56:01.440
тут важно знать? Непойманная ошибка в крутине отменяет как родители, так и у всех дочерних

56:01.440 --> 56:07.280
элементов. Что это значит? Вот, возьмем наше дерево крутин, возьмем нашу дочернюю крутину,

56:07.280 --> 56:12.480
которая кинула исключение, причем не consolation exception, а какой-то другой. Например, у нас реально

56:12.480 --> 56:20.800
ошибка в коде, либо какой-нибудь checked exception мы не обработали у себя внутри, нормально. Что

56:20.800 --> 56:26.240
происходит дальше? Это исключение доходит до родительской крутины. Родительская крутина,

56:26.240 --> 56:32.440
в первую очередь, отменяет все остальные дочерние крутины, вот, свои, вот. Соответственно, тут она

56:32.440 --> 56:40.200
отойдет до крутин 5 и крутин 7, отменит их и потом отменит сама себя. Дальше, если внутри нее мы уже

56:40.200 --> 56:47.000
не смогли обработать никак это исключение, она прокинет это исключение дальше, выше, к своей

56:47.000 --> 56:53.440
родительской крутине. Здесь произойдет ровно то же самое. И получается, что мы вот это исключение

56:53.440 --> 56:59.800
прокинули в самый верх, до нашего корневого, до нашей корневой крутины. Ну и в принципе,

56:59.800 --> 57:05.640
вообще до своего скопа так может быть. Возвращаясь к предыдущему слайду, как раз вот мы берем наш

57:05.640 --> 57:12.680
throwable. Получается, что наш throwable не является наследником cancellation exception, и получается,

57:12.680 --> 57:19.680
мы его пытаемся обработать как обычное исключение. И прокидываем выше через вот эту взаимосвязь

57:19.680 --> 57:24.880
всех крутин между собой. То есть, так как у меня есть возможность в крутин-контексте получить

57:24.880 --> 57:32.040
доступ к родительской крутине и к, через дочерней крутины, у меня есть возможность информацию об

57:32.040 --> 57:38.680
исключении кинуть вверх до родителя. Вот это как раз таки есть structured concurrency, про которое

57:38.680 --> 57:45.760
я говорил в самом начале. Вот получается, что мы, да, я тоже имплементацию привел вот на T-Fi

57:45.760 --> 57:53.480
canceling. Мы как раз сначала пытаемся отменить всех наших детей, а потом пытаемся отменить уже себя.

57:53.480 --> 58:01.760
Получается, что вот так вот мы дошли до самого верха, до родительской крутины и, в принципе,

58:01.760 --> 58:06.400
до всего крутин-скопа. И если исключение дойдет до крутин-скопа, она его, соответственно,

58:06.400 --> 58:11.400
полностью и отменит. И он будет отменен, и на основе него мы уже не сможем создавать новые крутины.

58:11.400 --> 58:20.240
И все дочерние крутины также будут отменены. Это для нас не сказать, что прям классные новости,

58:20.240 --> 58:25.440
почему. Ну, типа, если мы так шумудрились и не словили где-то какое-то исключение,

58:25.440 --> 58:30.400
то оно действительно прям дойдет до самой верхушки, до корневых элементов и вообще,

58:30.400 --> 58:36.280
в принципе, отменит все, что там было. Нам все же нужно как-то уметь с этим работать. Для этого у

58:36.280 --> 58:44.040
нас есть Supervisor Job. Он частично решает нашу проблему, я покажу как, но им надо уметь

58:44.040 --> 58:51.320
пользоваться, нужно понимать для чего и для каких целей он может быть применен. Это отдельный,

58:51.320 --> 59:00.920
скажем так, подтип нашей Job с определенными свойствами подкапот. Если мы используем Supervisor Job,

59:00.920 --> 59:08.360
у себя в коде, покажу как, ошибка или отмена дочерней крутины не приводит к отмене нашей

59:08.360 --> 59:15.040
родительской крутины и не влияет на его наследников, я имею ввиду наследников нашего

59:15.040 --> 59:21.480
родительского Job. Давайте посмотрим, как это выглядит. Представим, что у нас есть крутин Scope,

59:21.480 --> 59:31.080
который был создан на основе Supervisor Job. И если мы попытаемся получить какую-то ошибку внутри

59:31.080 --> 59:37.440
дочерней крутины, она передаст эту информацию дальше выше, внутри самого Scope или какой-то

59:37.440 --> 59:43.760
родительской крутины. Но особенность того, что у нас есть Supervisor Job позволяет нам не отменять

59:43.760 --> 59:51.280
наши другие, наши дочерние крутины, как в принципе и сам Croutine Scope. Но вот эта особенность,

59:51.280 --> 59:56.080
мне кажется, про эту особенность редко кто пишет, редко кто про это говорит, но сам Exception

59:56.080 --> 01:00:02.760
никто не обработал. То есть мы через взаимосвязь между Job, между нашими крутинами, передали

01:00:02.760 --> 01:00:08.400
информацию о том, что Exception случился, и мы не дали возможность родительской крутини полностью

01:00:08.400 --> 01:00:16.120
отмениться, но сама информация дальше через Job пропихивается наверх. Она распространяется выше

01:00:16.120 --> 01:00:23.520
через родителя. И получается, что в теории, даже если мы где-то на начальной стадии использовали

01:00:23.520 --> 01:00:29.560
Supervisor Job, который позволил нам не заканцелить все дочерние крутины внутри своего поддерева,

01:00:29.560 --> 01:00:36.320
это не значит, что дальше эта информация будет обработана выше по стеку, ну или там по связи

01:00:36.320 --> 01:00:44.320
между Job и не дойдет до обычного Job или обычного Croutine Scope, который увидит от Exception, его сильно

01:00:44.320 --> 01:00:53.320
испугается и отменит все, что было ниже его по дереву, все его дочерние крутины. Важно получается

01:00:53.320 --> 01:01:00.160
то, что Supervisor Job работает только в том случае, если он является прямым родителем для дочерних

01:01:00.160 --> 01:01:10.120
крутин, и по-хорошему он должен являться что-то типа, скажем так, рутовым элементом, ключевым

01:01:10.120 --> 01:01:15.360
элементом в момент создания крутин Scope. Вот я бы так выразился, потому что в других случаях,

01:01:15.360 --> 01:01:22.600
скорее всего, пользы будет от него не так много. Давайте рассмотрим это на примере. Вот здесь я

01:01:22.600 --> 01:01:31.000
пытаюсь создать мою крутину, ну вообще новую крутину, и передаю ей Supervisor Job в качестве

01:01:31.000 --> 01:01:38.480
параметра, надеясь на то, что он сможет обработать исключение из моих дочерних крутин. Вот внутри,

01:01:38.480 --> 01:01:44.680
дальше я пытаюсь создать две новых крутины. В первой также жду секунду и кидаю Exception,

01:01:44.680 --> 01:01:49.680
который мы никак не отловили внутри крутины, а во втором случае, во второй крутине я жду две

01:01:49.680 --> 01:01:54.080
секунды и пытаюсь напечатать строчку Will not be printed. Наверное, несложно догадаться,

01:01:54.080 --> 01:01:59.280
что произойдет с этой крутиной. А в родительской крутине дальше я пытаюсь заджониться по

01:01:59.280 --> 01:02:07.440
всему тому, что я создал с помощью Supervisor Job. Если я попытаюсь просто диаграммами, ну или там

01:02:07.440 --> 01:02:13.520
так вот обвести участки кода и показать, что одна крутина относится к одному Job, другая крутина

01:02:13.520 --> 01:02:24.680
ко второму интерфейсу Job, поймем, что две наши крутины соответствуют своим элементам Job. Здесь

01:02:24.680 --> 01:02:31.600
вроде бы пока все понятно. Но что дальше? А дальше происходит то, что в одной из моих дочерних

01:02:31.600 --> 01:02:40.200
крутин происходит ошибка, но обрабатывает эти две крутины только что созданной самим фреймворком Job.

01:02:40.200 --> 01:02:47.720
Помните, я в самом начале рассказывал по теме с крутин-билдерами, что крутин-билдер и фреймворк

01:02:47.720 --> 01:02:56.840
вообще создает сам свой Job и передает его как такой базовый элемент для всех дочерних крутин. Так вот,

01:02:56.840 --> 01:03:04.400
то, что мы передали Supervisor Job, особо-то ни на что не влияет, потому что он будет родительским

01:03:04.400 --> 01:03:11.360
элементом по отношению к Job, созданным внутри крутин-билдера. И получается, что сначала мой

01:03:11.360 --> 01:03:17.840
обычный Job пытается обработать ошибку внутри дочерней крутины, он зафейлится благополучно,

01:03:17.840 --> 01:03:24.240
потому что он не является Supervisor Job и не умеет игнорировать такие исключения. Соответственно,

01:03:24.240 --> 01:03:29.880
он сам отменится и отменит все свои дочерние крутины. Вот этот ключевой момент, я надеюсь,

01:03:29.880 --> 01:03:36.040
стал чуть более понятен. Если нет, постараюсь в конце лекции или в серии вопросов еще раз

01:03:36.040 --> 01:03:42.280
раскрыть этот вопрос, раскрыть этот момент и объяснить получше. Но вот, грубо говоря,

01:03:42.280 --> 01:03:46.440
у нас есть возможность передать Supervisor Job и сам компилятор даст нам такую возможность,

01:03:46.440 --> 01:03:53.280
ничего не будет подсвечивать. И если просто почитать документацию, может сложиться впечатление,

01:03:53.280 --> 01:03:59.640
что мы можем так сделать и передать Supervisor Job внутри крутин-билдера. Но по факту польза от

01:03:59.640 --> 01:04:05.360
этого практически не будет. Все из-за того, что под капотом внутри крутин-билдера создается

01:04:05.360 --> 01:04:10.760
свой собственный Instance Job, на основе которого и дальше могут создаваться другие дочерние крутины.

01:04:10.760 --> 01:04:21.840
Вот. Этот момент, кстати, хорошо обсуждается в одном из докладов на Kotlin Conf. Опять же,

01:04:21.840 --> 01:04:27.960
ссылочку я приведу в конце. Окей, как мы могли бы в теории использовать Supervisor Job? Но,

01:04:27.960 --> 01:04:33.080
опять же, про спойлер особо так не рекомендую, просто пытаюсь объяснить механику работы Supervisor

01:04:33.080 --> 01:04:42.160
Job. В данном примере я создаю его сам, явно, потом передаю его в одну крутину в лаунч и потом

01:04:42.160 --> 01:04:48.160
явно передаю в другую крутину. Здесь получается уже кейс немножко другой. То есть у нас каждая

01:04:48.160 --> 01:04:53.280
крутина также под капотом, точнее крутин-билдер, также под капотом создает Job, который может быть

01:04:53.280 --> 01:05:00.920
зафейлен, но он дальше передаст эту информацию о проблеме в Supervisor Job, который не отменит все

01:05:00.920 --> 01:05:07.240
другие дочерние крутины. Но особенность, точнее так, нюанс этого примера в том, что мы немного

01:05:07.240 --> 01:05:13.400
ломаем саму систему structured concurrency. Почему? Потому что мы явно сами начинаем руками создавать

01:05:13.400 --> 01:05:22.640
Job, Supervisor Job, что в моей практике лучше не делать, а лучше использовать либо обычные крутин-билдеры,

01:05:22.640 --> 01:05:28.640
либо крутин-скоп функций, которые мы рассмотрим чуть позже, типа крутин-скопа. Кстати, да, даже я

01:05:28.640 --> 01:05:37.120
его на слайде использую в самом начале. Я вызываю функцию suspend main и первой строчкой пишу крутин-скоп.

01:05:37.120 --> 01:05:44.320
Вот именно про них речь. То есть нужно использовать тот готовый арсенал из функций, который уже есть в

01:05:44.320 --> 01:05:50.600
стандартной библиотеке, а не городить самим, явно не создавать вот такие Job, чтобы потом их и явно

01:05:50.600 --> 01:05:59.080
самим как-то стараться заменеджить. Потому что здесь мне приходится явно самому прописывать в самом

01:05:59.080 --> 01:06:07.400
конце Job1.Join, Job2.Join, просто потому что теперь сам механизм работы крутины structured concurrency

01:06:07.400 --> 01:06:13.280
не работает, мне приходится явно дожидаться самостоятельно завершения крутин. Но здесь

01:06:13.280 --> 01:06:17.520
я пытался просто привести пример, что можно использовать Job для определенных кейсов, и он будет

01:06:17.520 --> 01:06:25.840
работать, но лучше так не делать. А как нужно? Можно использовать крутин-скоп функцию. По аналогии

01:06:25.840 --> 01:06:33.920
с крутин-скоп есть супервизор-скоп, в рамках которого мы можем запускать свои дочерние крутины.

01:06:33.920 --> 01:06:41.400
Он позволяет вам выполнить то, что по факту и хотелось бы в самом начале, когда мы начали

01:06:41.400 --> 01:06:50.920
разбирать тему, точнее не с отменой крутин, а с обработкой исключений в крутинах. Здесь мы увидим

01:06:50.920 --> 01:06:56.480
как раз нашу строчку will be printed, просто потому что одна из крутин зафейлится, но супервизор-скоп

01:06:56.480 --> 01:07:01.920
позволит нам проигнорировать это исключение конкретно в этом куске кода и дождаться выполнения

01:07:01.920 --> 01:07:11.440
крутины, которая ждет 2 секунды и печатает строчку. Важно подсвечиваю, что наше исключение

01:07:11.440 --> 01:07:19.240
не проглатывается нигде, про него мы не забываем, оно дальше передастся всем родительским крутином,

01:07:19.240 --> 01:07:25.600
если мы поддерживаем принцип structure concurrency и сами явно Job не создаем, эта информация

01:07:25.600 --> 01:07:36.000
передастся дальше и нужно, чтобы ее кто-то обработал. Повторюсь, исключения распространяются выше

01:07:36.000 --> 01:07:42.880
по иерархии Job. Вот мы имеем scope, мы создаем дальше крутины, дальше из родительских крутин мы

01:07:42.880 --> 01:07:50.440
создаем дочерние и вот информация о том, кто кому является родителем и так далее, как раз и

01:07:50.440 --> 01:07:57.240
содержится внутри крутин контекста и внутри наших интерфейсов Job и исключения передаются ровно по

01:07:57.240 --> 01:08:06.880
этой схеме, по этой взаимосвязи и если мы не смогли обработать исключение в какой-то из дочерних крутин,

01:08:06.880 --> 01:08:13.720
оно обязательно передастся выше и это касается и обычного Job и супервизор Job, я надеюсь это я смог

01:08:13.720 --> 01:08:19.780
донести, но да и особенно супервизор Job, что он имеет отличие работы с дочерними крутинами, как раз на

01:08:19.780 --> 01:08:25.620
слайдах мы это увидели, что он не отменяет сходу все свои дочерние крутины. Но как же тогда ловить

01:08:25.620 --> 01:08:33.780
исключения, вот если у нас была бы возможность так сделать? Во-первых, не допускать ситуации,

01:08:33.780 --> 01:08:39.140
что мы что-то не отловили и дальше это исключение вверх пошло по иерархии. В первую очередь, конечно

01:08:39.140 --> 01:08:45.780
же стараемся, как и в обычном коде, работать через try-catch, либо через run-catching, который нам вернет

01:08:45.780 --> 01:08:51.000
результат, посмотрим как это выглядит, либо на кроняк используем крутин exception handler, но опять же

01:08:51.000 --> 01:08:55.980
с ним есть нюансы. Cruitian exception handler это еще один элемент крутин контекста, напомню.

01:08:55.980 --> 01:09:02.060
С try-catch как мы это можем сделать? Ну вот допустим у нас есть функция, которая кидает исключение и мы

01:09:02.060 --> 01:09:08.060
в теории можем предположить, что она может кинуть исключение. Что это за примеры такие? Ну представим,

01:09:08.060 --> 01:09:12.020
что мы работаем с каким-то внешним фреймворком, который мы не контролируем или с какой-то

01:09:12.020 --> 01:09:17.420
библиотекой, которую мы не контролируем. Мы не знаем, может ли она в теории что-то вернуть плохое или

01:09:17.420 --> 01:09:24.620
нет. По-хорошему нам бы стоило такой вызов обернуть в try-catch, не полагаться на то, что это исключение

01:09:24.620 --> 01:09:30.620
потом кем-то там будет обработано, а явно на месте это сделать и обработать результат в случае получения

01:09:30.620 --> 01:09:39.540
exception. Получается мы здесь делаем это через try. Пример, конечно же, очень такой синтетический и

01:09:39.540 --> 01:09:46.220
особо пользовать него нет, но представим, что мы обращаемся к какой-то опишке или библиотеке и

01:09:46.220 --> 01:09:54.820
дальше ловим какое-то исключение и как-то с ним работаем. Но особенность-то какая? Вот если,

01:09:54.820 --> 01:10:01.580
в теории мы можем так сделать, я видел примеры кода, когда разработчики пытались обернуть в

01:10:01.580 --> 01:10:08.300
try-catch сам вызов launch. Так вот это вообще ни к чему не приведет. Повторюсь, исключение,

01:10:08.300 --> 01:10:15.620
которое было кинуто внутри лаунч функции, то есть внутри блока для лаунч-крутинбилдера,

01:10:15.620 --> 01:10:24.220
оно не прокинется как обычное исключение и не отдастся просто вот в функцию main. А вот эта

01:10:24.220 --> 01:10:31.220
информация о исключении передастся через интерфейсы job. Соответственно, пользы в try-catch

01:10:31.220 --> 01:10:37.420
здесь нет никакой, мы никогда не отловим exception вот таким вот образом. Информация об исключении

01:10:37.420 --> 01:10:45.820
передастся дальше в job, к routine-scope, который я вызвал в самой первой строчке. Вот, пожалуйста,

01:10:45.820 --> 01:10:50.780
вот мне кажется здесь надо обратить внимание явно и может быть еще раз вернуться к этой теме,

01:10:50.780 --> 01:10:54.940
ну понять как это работает. Может быть даже попрактиковаться самим, понаписать просто

01:10:54.940 --> 01:11:01.380
примеры кода, покидать исключения и посмотреть в какой момент вы можете их поймать. Есть,

01:11:01.380 --> 01:11:08.420
повторюсь, кроме try-catch и run-catching, его полезное свойство в том, что он возвращает result.

01:11:08.420 --> 01:11:14.140
Довольно полезная API, это такая оберточка над результатом, которая может нам сказать о том,

01:11:14.140 --> 01:11:19.340
успешен ли вызов или нет внутри функции. То есть мы через run-catching слоим exception,

01:11:19.340 --> 01:11:26.300
получается вернем результат, точка там, фейлур. Выглядит это вот следующим образом. Мы вызываем

01:11:26.300 --> 01:11:33.140
run-catching, возвращаем результат типа result и дальше можем с этим результатом работать. У нас даже

01:11:33.140 --> 01:11:39.060
в Яндексе есть прям целые проекты, которые работают через этот result API и местами даже довольно

01:11:39.060 --> 01:11:45.860
полезно, на мой взгляд, вот этот API довольно полезно и может быть применимо, но с ним тоже

01:11:45.860 --> 01:11:52.180
есть нюансы. Какие? Например, мы через run-catching слоим вообще практически все exception, в том числе

01:11:52.180 --> 01:12:01.500
и cancellation exception. Про это не забываем. То есть если у нас внутри нашей, точнее, внутри нашей

01:12:01.500 --> 01:12:08.500
крутины и внутри какой-то suspend функции есть точка приостановки и из нее вытащился cancellation

01:12:08.500 --> 01:12:15.860
exception, то мы сломим его как в try-catch, так и в run-catching. И нам по-хорошему бы этот cancellation

01:12:15.860 --> 01:12:22.980
exception заново отправить дальше в другие крутины, либо явно это обработать и понять, что окей,

01:12:22.980 --> 01:12:28.100
нас кто-то решил здесь приостановить, давайте попробуем очистить ресурсы. В общем, этот API

01:12:28.100 --> 01:12:35.220
полезный, удобный, но также с ним нужно уметь работать. И вот как в завершение того, что мы можем

01:12:35.220 --> 01:12:41.220
использовать сами в коде без каких-то собственных костылей, это крутин exception handler. Повторюсь,

01:12:41.220 --> 01:12:48.180
это элемент крутин контекста, он является его частью. Он обрабатывает неперехваченные исключения,

01:12:48.180 --> 01:12:53.660
но опять же не всегда и не везде. Его нужно в нужное место, точнее так, его нужно вставить в

01:12:53.660 --> 01:12:58.380
определенные места и тогда он будет работать. Опять же, на мой взгляд, такой некий недостаток

01:12:58.380 --> 01:13:08.380
всего API-крутин. API нам позволяет делать слишком много всего, что не приносит нам должного профита,

01:13:08.860 --> 01:13:16.060
или должного результата. Здесь я пишу, что если не указан в крутин scope, исключение передается

01:13:16.060 --> 01:13:21.220
on code exception handler. Это такой handler, который у нас есть в Android, в том числе и вообще в любой

01:13:21.220 --> 01:13:28.700
GVM. В случае с Android, этот handler просто-напросто крашнет приложение. Возможно, вы знаете,

01:13:28.700 --> 01:13:36.220
что если мы в каком-то из потоков нашего основного процесса не отловим исключения и наш поток

01:13:36.220 --> 01:13:41.900
полностью крашнется, то и все приложение может быть крашнуто. Нам бы не хотелось такого допускать,

01:13:41.900 --> 01:13:49.460
поэтому лучше все же для нашего какого-то корневого крутин scope указать крутин exception

01:13:49.460 --> 01:13:56.580
handler, который обработает вот такие неперехваченные исключения. Создать его довольно просто,

01:13:56.580 --> 01:14:01.420
также как любой другой объект. Создаем, передаем ему финальную имплементацию того,

01:14:01.420 --> 01:14:06.300
что делать с тем или иным исключением. Здесь в данном случае я просто печатаю текущий exception

01:14:06.300 --> 01:14:13.740
в консоли. Как можно его использовать? И это, наверное, такой способ, который я могу хотя бы

01:14:13.740 --> 01:14:20.860
порекомендовать, хотя бы рекомендовать к рассмотрению. Мы создаем handler, дальше мы создаем scope. Это

01:14:20.860 --> 01:14:26.540
может быть какой-то ваш основной app scope внутри приложения, либо scope, привязанный к определенному

01:14:26.540 --> 01:14:33.340
экрану вью модели, неважно. Дальше этому scope мы передаем supervisor job, позволяющий не отменять

01:14:33.340 --> 01:14:39.660
наш дочерник крутины в случае чего, а также сам handler, который обработает неперехваченные

01:14:39.660 --> 01:14:45.140
исключения. И вот если мы в такой концепции будем жить, в такой парадигме, у нас появляется

01:14:45.140 --> 01:14:50.500
возможность на основе scope создать наш дочерник крутины, в них даже кинуть какие-то исключения,

01:14:50.500 --> 01:14:55.780
как я это делаю в примере, кидаю runtime exception, а во второй крутине просто печатаю результат.

01:14:55.780 --> 01:15:03.900
И здесь я получу ожидаемый результат. Я никем не обработал исключения, и оно дошло до конца,

01:15:03.900 --> 01:15:11.220
дошло до верхушки цепочки job, дошла до крутины exception handler, и я его напечатал у себя в консоли.

01:15:11.220 --> 01:15:18.860
А потом во второй крутине, так как благодаря нашему supervisor job, я смог не отменить ее и

01:15:18.860 --> 01:15:26.340
благополучно напечатать в консоли результат. И это чуть ли не единственный вариант использования,

01:15:26.340 --> 01:15:32.540
на мой взгляд, где мы и нормально используем supervisor job и handler, крутин exception handler.

01:15:32.540 --> 01:15:37.740
В других случаях, так проспольерю, когда вы начнете чуть-чуть практиковаться, вы поймете,

01:15:37.740 --> 01:15:43.180
что мы чуть ли не в любой крутин builder можем передать как supervisor job, так и handler,

01:15:43.180 --> 01:15:50.780
но пользы от них будет не так много. Лучше рассмотреть и начать использование как supervisor job,

01:15:50.780 --> 01:16:00.420
так и handler внутри крутин scope. Это будет ваш самый ротовый элемент во всей цепочке.

01:16:00.420 --> 01:16:06.780
Вы от него, от крутин scope начнете создавать крутины и его специальным образом настроите.

01:16:06.780 --> 01:16:15.020
Вот и тогда и крутин exception handler и supervisor job будут иметь всю свою мощь, всю свою силу внутри него.

01:16:15.020 --> 01:16:24.060
Вот повторюсь, действительно для первой лекции, где мы погружаемся в тему крутин, отмена крутин

01:16:24.060 --> 01:16:29.540
и обработка ошибок это чуть ли не самые сложные вещи, на мой взгляд. Их сложно понять сходу,

01:16:29.540 --> 01:16:35.540
и нужно чуть-чуть практиковаться, может быть даже посмотреть не один доклад с объяснением и

01:16:35.540 --> 01:16:41.780
почитать хорошо документацию. Надеюсь хотя бы какую-то базу сегодня я смог рассказать и

01:16:41.780 --> 01:16:47.700
стало чуточку понятнее. Вот это наверное моя главная задача на сегодня. Ну что еще есть? Есть

01:16:47.700 --> 01:16:55.540
dispatcher. Мы не раз, ну и я не раз упоминал его. Он нужен для, он тоже является крутин контекст

01:16:55.540 --> 01:17:03.380
элементов, он необходим для переключения потоков. Его особенность в том, что мы его, вот его-то мы

01:17:03.380 --> 01:17:09.020
можем практически везде передавать, и он действительно будет влиять практически всегда на поведение

01:17:09.020 --> 01:17:15.140
крутин. Мы его можем передавать при создании крутин или с помощью крутин скоп функций, как vis

01:17:15.140 --> 01:17:23.060
context, покажу на примере. Там мы также можем передать dispatcher и явно сказать в текущей

01:17:23.060 --> 01:17:27.820
сопрограмме, в текущей крутине на каком пуле потоков, либо на конкретном потоке нужно исполняться.

01:17:27.820 --> 01:17:36.060
Вот в данном примере я создаю с помощью крутин скопа свою новую крутину. Там я пытаюсь тысячу раз

01:17:36.060 --> 01:17:43.020
запустить новые крутины, причем в каждой крутине делаю возможность запуститься на dispatcher с IO. То

01:17:43.020 --> 01:17:49.340
есть я и явно говорю вот крутина создайся пожалуйста и выполняйся в определенном пуле потоков,

01:17:49.340 --> 01:17:59.500
которые соответствуют dispatcher с IO. Это просто такое явное обозначение, что крутина, у меня есть

01:17:59.500 --> 01:18:05.180
пул потоков из dispatcher с IO, используй его. Здесь я использую те инструменты, которые мы с вами

01:18:05.180 --> 01:18:10.180
рассматривали на предыдущей лекции, вытаскиваю ими текущего потока, ну и соответственно могу

01:18:10.180 --> 01:18:17.380
увидеть, что там top worker 1, top worker 4, top worker 3 печатаются. То есть мы наши тысячи крутин

01:18:17.380 --> 01:18:25.380
запустили на пуле потоков и дальше печатаем текущее имя потока внутри них. А крутин скоп функцию,

01:18:25.380 --> 01:18:31.580
которую я упинул ранее, viscontext, это можно также использовать для переключения потоков. Очень

01:18:31.580 --> 01:18:38.380
полезная функция используется не только для dispatchers, но часто вы можете увидеть ее использование

01:18:38.380 --> 01:18:45.860
только вот в таких вот конкретных сценариях. Здесь я уже внутри текущей крутины сначала печатаю имя

01:18:45.860 --> 01:18:56.140
потока, а потом с помощью viscontext меняю dispatcher на IO и печатаю уже поток, имя потока внутри новой

01:18:56.140 --> 01:19:03.140
свежесозданной крутины. Здесь я получаю сначала first main, потому что я на основном потоке запустил

01:19:03.140 --> 01:19:11.180
мою родительскую крутину, а потом свежесозданную я уже запускаю на dispatcher с IO и получаю default

01:19:11.180 --> 01:19:20.940
dispatcher. Здесь, к слову, можно заметить, что у нас есть определенный пул потоков для IO,

01:19:20.940 --> 01:19:26.380
для dispatchers default и они может быть даже местами будут переиспользоваться, такое тоже возможно.

01:19:26.380 --> 01:19:33.180
Более того, вы можете указать свой dispatcher, создать его и передавать внутри функции, и это супер

01:19:33.180 --> 01:19:39.500
полезное свойство, так нужно делать. Обычно мы абстрагируем передачу dispatchers с помощью

01:19:39.500 --> 01:19:45.220
определенных интерфейсов для чего? Чтобы потом при тестировании их подменять. Обычно сами мы

01:19:45.220 --> 01:19:50.980
никогда не вызываем статичные функции dispatcher с IO, dispatcher default или dispatcher с main, а передаем

01:19:50.980 --> 01:19:57.700
свою абстракцию над ними свой какой-то интерфейс, предоставляющий нужные конкретные реализации

01:19:57.700 --> 01:20:05.060
наших плов. Опять же, для того чтобы подменить в тестах и передать нужную реализацию дальше.

01:20:05.060 --> 01:20:12.580
Как бы мы могли работать с main потоком? Помните, у нас одна из основных проблем была в том,

01:20:12.580 --> 01:20:18.500
в предыдущей лекции, что мы сначала выполняем что-то в background в потоке, а потом хотим вернуться на

01:20:18.500 --> 01:20:25.580
основной поток. Это делается, например, так. Мы вызываем функцию visContext и передаем dispatcher.main.

01:20:25.580 --> 01:20:30.700
В Android реализации, то есть вот крутины, они могут использоваться не только в Android, но и на

01:20:30.700 --> 01:20:38.140
обычных GVM. И вот dispatcher с main там будет разный. В случае с Android мы будем использовать

01:20:38.140 --> 01:20:45.740
нативный Android поток, вот main thread, который мы разбирали на прошлой лекции. И здесь мы явно

01:20:45.740 --> 01:20:53.580
декларируем, что нашу функцию showUser всегда надо вызывать на dispatcher с main, и все содержимое

01:20:53.580 --> 01:20:59.740
внутри visContext будет выполнено на main потоке до тех пор, пока мы явно сами не переключим этот

01:20:59.740 --> 01:21:10.900
dispatcher на другой. Но что стоит помнить? Практически я это еще сегодня не упоминал. Это работа

01:21:10.900 --> 01:21:16.780
со разделяемыми ресурсами. Помните, опять же, в предыдущей лекции это была чуть ли не главная

01:21:16.780 --> 01:21:23.060
проблема по работе с потоками. Нам нужно уметь правильно читать и записывать в разделяемый

01:21:23.060 --> 01:21:28.700
ресурс. В случае с крутинами большинство проблем решено за нас. Вот если бы мы создавали какие-то

01:21:29.580 --> 01:21:41.340
функции внутри suspend функции и работали с локальными переменами, то вся магия по видимости наших

01:21:41.340 --> 01:21:51.660
элементов, по атомарности изменений решалась самим фреймворком крутин и компилятором. Но в случае

01:21:51.660 --> 01:21:57.340
если мы работаем явно с каким-то разделяемым ресурсом вне текущих крутин, как на слайде,

01:21:57.340 --> 01:22:03.900
где у меня просто где-то в стране объявлен каунтер, просто какой-то разделяемый ресурс, и дальше мы

01:22:03.900 --> 01:22:10.060
внутри своих крутин, своих дочерних крутин пытаемся с этим разделяемым ресурсом начать

01:22:10.060 --> 01:22:15.620
работать, то у нас могут возникнуть проблемы ровно такие же, как при работе с потоками. То есть,

01:22:15.620 --> 01:22:21.260
представьте, что наши крутины работают на каком-то пыле потоков, соответственно, этих потоков может

01:22:21.260 --> 01:22:27.740
быть не один, а несколько, и нам нужно уметь заменеджить состояние нашего разделяемого

01:22:27.740 --> 01:22:34.500
ресурса между этими потоками. Здесь на слайде я что делаю. Есть функция Massive Run, где я вызываю

01:22:34.500 --> 01:22:40.460
какой-то action довольно много раз, тысячу раз я создаю крутин, и внутри каждой крутины тысячу

01:22:40.460 --> 01:22:48.060
раз прогоняю этот action, переданной мне в Massive Run. А в самом Massive Run я пытаюсь инкриментировать

01:22:48.060 --> 01:22:55.220
мою переменную, мой разделяемый ресурс, текущий свойство Counter. То есть, это такой счетчик,

01:22:55.220 --> 01:23:03.700
который я хочу заинкриментить кучу раз в тысяче крутин по тысяче раз. И если я такое вызову,

01:23:03.700 --> 01:23:11.940
причем на DispatchersDefault, то есть на пыле потоков, состоящем из не одного потока, а из нескольких,

01:23:11.940 --> 01:23:18.540
я получу не то число, которое ожидаю. Ровно по тем же причинам, что у меня нет возможности никак

01:23:18.540 --> 01:23:25.460
синхронизировать данные. В текущем коде нет явных признаков о том, что я хочу синхронизировать

01:23:25.460 --> 01:23:30.820
доступ к Counter. И мне нужно использовать те инструменты, которые мы с вами разбирали. Это

01:23:30.820 --> 01:23:38.340
Atomiki из Util Concurrent. Это Thread Confirmant, это определение, что мы работу с разделяемым ресурсом

01:23:38.340 --> 01:23:46.580
выделяем в отдельный один поток, в котором нам уже не нужно переживать о том, что там есть

01:23:46.580 --> 01:23:52.700
проблемы с видимостью, есть проблемы с атомарностью изменений и так далее. Ну есть Karoutine Mutics,

01:23:52.700 --> 01:24:01.620
который очень похож на то, что мы использовали на предыдущей лекции с локами. Давайте рассмотрим

01:24:01.620 --> 01:24:07.980
его чуть отдельно. У нас есть возможность его создать, у нас есть возможность также вызвать его

01:24:07.980 --> 01:24:16.220
и выполнить какую-то логику, как вот с синхроной секцией, также и тут. Мы у Mutics вызываем VizLog

01:24:16.220 --> 01:24:22.340
и выполняем какую-то функцию внутри него, какую-то логику внутри него. Главная особенность,

01:24:22.340 --> 01:24:29.700
главное отличие обычно вот этого Mutics из Karoutine по сравнению с Mutics или с локом из обычных

01:24:29.700 --> 01:24:37.220
потоков в том, что он не является reentrant. Помните такое свойство лока, позволяющее нам заходить в ту

01:24:37.220 --> 01:24:41.940
же критическую секцию под тем же локом, точнее так заходить в критическую секцию под тем же локом,

01:24:41.940 --> 01:24:48.100
который мы уже и так держим. Вот здесь на примере у меня есть функция Do Some Operation,

01:24:48.100 --> 01:24:53.540
которая под локом вызывает функцию Do Some Other Operation, которая также под этим же локом пытается

01:24:53.540 --> 01:24:59.380
что-то сделать. Так вот в случае использования Mutics из Karoutine у нас так сделать не получится,

01:24:59.380 --> 01:25:05.620
мы засаспендимся навсегда при вызове Do Some Other Operation, потому что у нас нет возможности

01:25:06.020 --> 01:25:11.900
заново зайти в ту же критическую секцию под тем же локом. Тут это стоит учитывать,

01:25:11.900 --> 01:25:17.220
ну и в принципе, наверное, не проектировать IP так, чтобы у вас была потребность несколько раз

01:25:17.220 --> 01:25:26.060
обращаться к одному и тому же Mutics внутри критических секций. И здесь мы словим определенный

01:25:26.060 --> 01:25:34.100
deadlock. Опять же, здесь, наверное, я бы приостановился, мы обсудили с вами довольно много важных тем,

01:25:34.100 --> 01:25:38.700
как отмена Karoutine, так и работа с включениями. Дальше нам предстоит чуть-чуть ознакомиться с

01:25:38.700 --> 01:25:47.980
поддержкой Jetpack и рассмотреть немножко Flow и Channels. Грубо говоря, там две части мы уже с

01:25:47.980 --> 01:25:53.100
вами довольно хорошо обсудили, давайте попробуем поотвечать на вопросы. Они, наверное, уже скопились.

01:25:53.100 --> 01:26:00.700
Что заставляет Karoutine запуститься после отработавшего delay? Она же не может запустить

01:26:00.700 --> 01:26:10.100
сама себя. Да, как раз прошу вас посмотреть, даже, наверное, доклады по ссылке, которую я приложил,

01:26:10.100 --> 01:26:18.340
вы увидите в конце лекции. Там это объясняется. Как раз-таки компилятор за нас придумает и

01:26:18.340 --> 01:26:27.100
реализует такую схему, позволяющую с помощью обьекта класса continuation заново вызвать нас и

01:26:27.100 --> 01:26:35.380
восстановить тот стэк методов, который мы до этого прихранили. Сейчас это, мне кажется, я довольно

01:26:35.380 --> 01:26:41.900
долго буду объяснять всю концепцию, пожалуйста, лучше посмотрите целый доклад про это. Но действительно,

01:26:41.900 --> 01:26:47.300
сама по себе Karoutine себя заново не запустит. Это точно так. То есть мы с помощью компилятора

01:26:47.300 --> 01:26:52.620
создаем такую магию и с помощью обьекта класса continuation позволяем нам возобновить работу.

01:26:52.620 --> 01:26:57.580
Как выглядит место в коде, где происходит приостановка и переход к другому коду,

01:26:57.580 --> 01:27:01.580
например, к отрисовке UI? Используются какие-то возможности, которые уже были в лекции рассказаны?

01:27:01.580 --> 01:27:09.100
Как выглядит место в коде, где происходит приостановка? Может быть тоже такой нюанс и

01:27:09.100 --> 01:27:17.540
особенность работы Karoutine, что если вы смотрите на код, может быть, на GitHub, на GitLab или еще где-то,

01:27:17.540 --> 01:27:24.460
на pull request, где нет нормальной подсветки синтаксиса, то просто посмотрев на функцию,

01:27:24.460 --> 01:27:30.740
у вас практически не будет возможности понять, что мы там находимся с suspend, кроме того,

01:27:30.740 --> 01:27:38.020
что вы посмотрите на сигнатуру метода и увидите suspend модификатор в названии. Либо какие-то

01:27:38.020 --> 01:27:44.500
ключевые функции типа delay, yield или еще что-то, которые явно говорят о том, что мы сейчас находимся

01:27:44.500 --> 01:27:53.180
внутри suspend функций. В наших средах разработки типа Android Studio, типа IntelliJ IDE, там есть явное

01:27:53.180 --> 01:27:59.980
обозначение, что есть suspend функция, и она слева напротив строчки кода будет обозначать,

01:27:59.980 --> 01:28:07.500
что у нас здесь Karoutine может быть приостановлено. Что это значит? Представим, что у нас есть большая

01:28:07.500 --> 01:28:14.260
suspend функция, и внутри нее мы видим такой значочек, типа вот api.fetchstudent, и там напротив нее

01:28:14.260 --> 01:28:18.860
есть значочек приостановки. Это не значит, что мы прям при вызове fetchstudent приостановимся,

01:28:18.860 --> 01:28:26.820
это скорее говорит о том, что внутри fetchstudent мы дойдем до места, где Karoutine полностью остановится,

01:28:26.820 --> 01:28:35.780
и дальше вот мы вот это состояние прихраним, где-то захешируем, где-то положим на полочку,

01:28:35.780 --> 01:28:43.380
а потом возобновим работу ровно в том месте. И так вот по цепочке, по стеку вызовов мы вернем

01:28:43.380 --> 01:28:48.340
результат обратно к нашему клиенту, клиентской части, там где мы вызываем fetchstudent у api.

01:28:48.340 --> 01:28:54.420
Вот подход примерно такой. Вся магия с тем, что мы стек вызовов прихраниваем с помощью

01:28:54.420 --> 01:29:01.300
continuation, возобновляем работу, и там вообще используется стейт-машина с флажочками,

01:29:01.300 --> 01:29:07.420
со стейтами, и мы в коде поймем, на каком этапе мы приостановились, и как в стейт-машине перейдем

01:29:07.420 --> 01:29:13.260
на нужный индекс, на нужный этап работы нашей функции. То есть как бы наша функция и каждая

01:29:13.260 --> 01:29:18.740
suspend точка, она будет помечаться для стейт-машины, которую создаст сам компилятор. Опять же вот

01:29:18.740 --> 01:29:25.300
эту механику, если вам это интересно, можете отдельно подробно изучить, я приложил ссылку на доклад.

01:29:25.300 --> 01:29:32.860
Вот, к примеру, мы берем какие-либо данные из базы данных по типу activity. Так, что будет

01:29:32.860 --> 01:29:43.140
лучше передавать контекст к рутине? Сейчас, секунду, вопрос довольно сложно сформулирован,

01:29:43.140 --> 01:29:53.780
я не могу сходу понять, о чем речь. Что будет лучше передавать контекст? Вкратце, ладно,

01:29:53.780 --> 01:30:00.500
там вопрос про то, как мы будем использовать крутины в связке с репозиториями, с view-моделями

01:30:00.500 --> 01:30:06.060
и так далее. Чуть позже на слайдах я покажу пример того, как бы я хотел, например, видеть

01:30:06.060 --> 01:30:14.980
обычный дефолтный репозиторий, view-модель и так далее в контексте работы с крутиными. Надеюсь,

01:30:14.980 --> 01:30:19.940
я смогу ответить на ваши вопросы именно там. Если использовать In-Chore Active, то где проводить

01:30:19.940 --> 01:30:26.460
очистку ресурсов? Здесь, наверное, предполагается, что нам очищать-то ничего особо не надо. То есть,

01:30:26.460 --> 01:30:36.020
если In-Chore Active мы называем, то мы ожидаем, что мы кинем исключение в случае вызова этой функции и

01:30:36.020 --> 01:30:44.900
одновременно отмены данной крутины. Может быть, также через strike edge словить, но я бы так,

01:30:44.900 --> 01:30:48.900
наверное, даже не делал. Может быть, просто вызову тогда флажочек, проверил, что из In-Chore Active и

01:30:48.900 --> 01:30:56.220
погнали дальше. In-Chore Active это скорее прокейс, когда мы хотим явно сразу оборвать всю работу,

01:30:56.220 --> 01:31:03.580
и быстро дойти через исключение, пробросить исключение выше по стеку вызовов и закончить

01:31:03.580 --> 01:31:09.780
работу тут. И не писается бесконечный флс. Может быть, даже для читаемости это будет лучше.

01:31:09.780 --> 01:31:17.940
Если в текущем потоке запустить через лаунж две крутины подряд сложными вычислениями непрестанавливаемыми,

01:31:17.940 --> 01:31:23.900
то они будут последовательно выполняться. It depends зависит от того, как крутины настроены,

01:31:24.020 --> 01:31:29.420
но по факту да. Если вы сделаете так, что эти крутины будут выполняться на одном потоке,

01:31:29.420 --> 01:31:34.100
то никакой магии не произойдет. У вас поток всегда будет загружен какими-то вычислениями в одной

01:31:34.100 --> 01:31:40.940
крутине, и это может повлиять на работу крутины номер два. Если все же у вас шарится какой-то

01:31:40.940 --> 01:31:47.420
пул потоков и есть возможность распараллелить работу в этих двух крутинах, то как будто они

01:31:47.420 --> 01:31:56.140
могут жить и рядом вместе. Если на одном потоке, то как будто бы да. У вас работа одной крутины

01:31:56.140 --> 01:32:05.780
может повлиять на другую. Если так, это я прочитал, супервизор Job имеет смысл использовать только при

01:32:05.780 --> 01:32:12.420
малой вложенности крутин. Скорее его нужно, на мой взгляд, уже так по практике, его нужно декларировать

01:32:12.420 --> 01:32:19.060
как можно выше, желательно в крутинскопе, как я это указал на слайде. В общем, там нужно понимать,

01:32:19.060 --> 01:32:24.460
что вы делаете в других кейсах, и я их специально не приводил сейчас здесь на слайде, как будто бы

01:32:24.460 --> 01:32:30.180
только усложнил понимание того, как устроен супервизор Job. На мой взгляд, это непростая штука,

01:32:30.180 --> 01:32:36.780
и нужно еще отдельно про него почитать и с ним попрактиковаться. А вот супербазовый пример,

01:32:36.780 --> 01:32:44.940
тот пример, в котором я уверен, я привел на слайде. Немножко запутался MainThread и UITread.

01:32:44.940 --> 01:32:52.020
UITread – это ведь одно и то же, но в моем контексте точно да. Есть MainThread, его еще называют UITread

01:32:52.020 --> 01:33:00.860
на Android. Те примеры, которые я запускаю и привожу на слайдах, это скорее какие-то консольные программы,

01:33:00.860 --> 01:33:09.100
они не привязаны к какому-то Android, и тут я имею в виду, что есть вот MainThread обычный из консольной

01:33:09.100 --> 01:33:17.340
программы. Но если бы я запускал те же самые крутины внутри MainThread, то это был бы UITread из Android.

01:33:17.340 --> 01:33:25.580
Так, наверное, ответил на все, что мне пришло. Давайте продолжим и закончим с нашей темы по

01:33:25.580 --> 01:33:34.300
крутинам. На сегодня быстренько пройдемся по Jetpack поддержке и по Flow. Думаю, и так сегодня

01:33:34.300 --> 01:33:41.620
довольно много информации прозвучало. Как я уже говорил ранее, не один раз в Jetpack есть поддержка,

01:33:41.620 --> 01:33:48.860
крутин. Это очень круто. Это нам как разработчикам позволяет не сильно париться насчет

01:33:48.860 --> 01:33:53.700
реализации своих каких-то концепций, как, например, нам бы пришлось делать Executor

01:33:53.700 --> 01:34:00.460
Service. Даже мы понимаем, что такое Executor Service, умеем им пользоваться, но чтобы сделать это грамотно,

01:34:00.460 --> 01:34:08.780
правильно, в контексте Android и обработать всевозможные проблемы с отменой, с переворотом

01:34:08.780 --> 01:34:14.940
экрана, с сменой всего контекста внутри Activity. В общем, как будто бы много кейсов, которые нам

01:34:14.940 --> 01:34:21.460
стоит учитывать и хорошо организовать работу Executor Service, не так уж и просто. А тут за нас уже

01:34:21.460 --> 01:34:27.900
продумали многие вещи, добавили поддержку ViewModels, добавили поддержку Lifecycle Scope. Давайте попробуем

01:34:27.900 --> 01:34:36.540
рассмотреть, что у нас есть уже из коробки при использовании обычного Android X пакета и набора

01:34:36.540 --> 01:34:43.020
библиотека TUDO. У нас есть возможность использовать ViewModel. Я вообще, наверное, у вас еще не было

01:34:43.020 --> 01:34:50.100
лекций по архитектуре и так далее. Наверное, еще до конца обсуждали те возможности, которые

01:34:50.100 --> 01:34:57.020
есть JPEG. Но так вот на скидку скажу, что ViewModel довольно прикольная штука, позволяет вам хранить

01:34:57.020 --> 01:35:02.700
внутри нее много информации о текущем экране, вообще хранить сам стейт экрана и дает возможность

01:35:02.700 --> 01:35:11.580
переживать жизненный цикл Activity либо фрагмента, который сейчас находится непосредственно на самом

01:35:11.580 --> 01:35:18.620
экране. И вот у нас есть поддержка, у текущей ViewModel поддержка крутин, имею ввиду. И у каждой

01:35:18.620 --> 01:35:26.540
ViewModel можно дернуть ViewModel Scope, который, мне кажется, по факту чуть ли не всю реализацию тут сейчас приведу

01:35:26.540 --> 01:35:35.420
на слайде, делает примерно то же самое, что мы с вами писали чуть ранее. Сам создает крутин Scope явно,

01:35:35.420 --> 01:35:43.820
привязывает его к текущему инстанцию ViewModel и к его жизненному циклу ViewModel. И у нас есть

01:35:43.820 --> 01:35:50.500
возможность в рамках ViewModel Scope, а соответственно и в рамках жизни ViewModel запускать крутины. И из

01:35:50.500 --> 01:35:56.180
коробки у нас уже появится возможность отмены крутин. В том случае, когда ViewModel полностью

01:35:56.180 --> 01:36:03.500
уничтожится и вызовется метод onClear at у ViewModel, мы отменим текущий ViewModel Scope и отменим все

01:36:03.500 --> 01:36:09.980
эти чернику-рутины, которые еще не завершили свою работу, что очень удобно. И только благодаря

01:36:09.980 --> 01:36:18.020
этому уже можно пользоваться default ViewModel Scope из коробки из Android Jetpack. Как бы это могло

01:36:18.020 --> 01:36:24.100
выглядеть на каком-то нашем примере? Вот я здесь создал Yandex ViewModel, передаю ему опишку, с которой

01:36:24.100 --> 01:36:32.780
наша ViewModel работает. Дальше внутри своей функции, в данном случае это Face Student, я на ViewModel Scope

01:36:32.780 --> 01:36:39.900
запускаю свою новую крутину и хожу в API. Причем дальше там могу вызвать UpdateState,

01:36:39.900 --> 01:36:45.940
поработать со стейтом экрана, неважно. Но главная фишка, главная идея, это то, что я использую

01:36:45.940 --> 01:36:51.540
ViewModel Scope для создания крутины. И в случае, если моя ViewModel, в данном случае Yandex ViewModel,

01:36:51.540 --> 01:36:59.260
уничтожится и захочет очистить ресурсы, моя дочерняя крутина с походом в API отменится сама,

01:36:59.260 --> 01:37:07.260
вот что прикольно. Мы можем сами создать свой Scope в случае, если мы, ну знаете, это привожу

01:37:07.260 --> 01:37:14.540
пример для каких-то кастомных классов, похожих на ViewModel. У нас в Yandex такой используется,

01:37:14.540 --> 01:37:20.900
поэтому приведу пример и такого варианта. Здесь мы явно сами ручками создаем крутин Scope,

01:37:20.900 --> 01:37:27.100
передаем ему DispatchersMain, чтобы мы по дефолту запускали задачи на Main потоке. Здесь ничего

01:37:27.100 --> 01:37:33.180
страшного в принципе нет. Благодаря тому, что наши крутины не блокируют поток, а приостанавливают

01:37:33.180 --> 01:37:39.180
свое выполнение и дают возможность потоку выполнять что-то еще, не сильно аффектит Main

01:37:39.180 --> 01:37:45.940
поток. И мы многие, особенно какие-то базовые операции типа там, обнови переменную, обработай

01:37:45.940 --> 01:37:50.260
какое-то действие пользователя, обнови стейт, можем спокойно вызывать на Main потоке, это не

01:37:50.260 --> 01:37:54.940
блокировка на несколько сотен миллисекунд в ожидании ответа от API. Такого не произойдет,

01:37:54.940 --> 01:38:05.260
и благодаря этому мы в принципе часто можем безопасно работать с данными внутри Main потока

01:38:05.260 --> 01:38:11.940
с использованием Dispatchers.main. И тут я еще передаю Supervisor Job явно для того, чтобы не отменять

01:38:11.940 --> 01:38:18.780
какие-то свои дочерние крутины в случае, если мы получили ошибку в одной из них. В OnCreate я

01:38:18.780 --> 01:38:27.540
запускаю задачку, что-то там пытаюсь получить, а в OnClear это как раз из библиотеки функция callback,

01:38:27.540 --> 01:38:33.900
которая будет дергаться, когда наша viewmodel уничтожается. Я беру текущий скоп, беру крутин

01:38:33.900 --> 01:38:39.260
контекст из него и отменяю все дочерние крутины. Вот примерно то же самое происходит и во view

01:38:39.260 --> 01:38:44.380
модели, которая приходит из коробки из Android Jetpack. Можете даже в этом убедиться, сами

01:38:44.380 --> 01:38:51.820
посмотрите. Но повторюсь, используйте пожалуйста viewmodel, хороший класс замена

01:38:51.820 --> 01:38:58.380
всевозможным презентером из MVP-архитектуры, каким-то своим кастомным классом, который могут

01:38:58.380 --> 01:39:05.380
пережить жизненный цикл всей активе телефрагмента. Мне кажется, довольно удобный класс, дающий много

01:39:05.380 --> 01:39:12.820
преимуществ, плюс еще из коробки у нас есть возможность использовать крутины, что тоже классно.

01:39:12.820 --> 01:39:21.020
Есть еще lifecycle scope, у самих классов типа Activity фрагмента они являются lifecycle

01:39:21.020 --> 01:39:28.140
owner, у них можно вытащить на основе lifecycle owner lifecycle scope. Этот lifecycle scope я бы

01:39:28.140 --> 01:39:36.940
использовал для каких-то UI-ных крутин. В случае, если мы хотим обработать какое-то действие на

01:39:36.940 --> 01:39:41.820
экране и запланировать какую-то задачу на самом UI, мы можем использовать lifecycle scope для этого.

01:39:41.820 --> 01:39:48.500
Либо, что мне кажется самый частый кейс, это использовать lifecycle scope для запуска и для

01:39:48.500 --> 01:39:58.100
дальнейшей подписки на изменение стейта lifecycle и подписки на стейт экрана. Сейчас довольно

01:39:58.100 --> 01:40:03.880
популярный подход в Android разработке, где во view модели у нас хранится стейт экрана в виде

01:40:03.880 --> 01:40:11.960
state flow. Чуть позже мы посмотрим, как это может выглядеть. Наш UI в виде Activity или фрагмента только

01:40:11.960 --> 01:40:18.320
в определенные нужные моменты, когда этот UI активен доступен, подписывается на этот стейт из

01:40:18.320 --> 01:40:24.280
view модели. Выглядит это всегда примерно так, как я показал на слайде. То есть, мы вызываем специальную

01:40:24.280 --> 01:40:31.340
функцию repeat life cycle started у самого lifecycle. Перед этим все это дело вызываем, так как это

01:40:31.340 --> 01:40:38.100
suspend функция. Все это дело перед этим вызываем с помощью новой свежесозданной корутины на основе

01:40:38.100 --> 01:40:45.740
lifecycle scope из Activity или фрагмента. А внутри корутины мы подписываемся на state flow, то есть на стейт

01:40:45.740 --> 01:40:51.460
нашего экрана и пытаемся реагировать на все обновления текущего стейта и как-то по-другому

01:40:51.460 --> 01:40:58.580
отрисовывать UI. Будь то compose UI, либо обычные вьюшки, там уже не важно, в принципе. Этот механизм

01:40:58.580 --> 01:41:07.820
позволяет работать и с тем и с тем. Резюмируя, в общем, из Android Jetpack, view модели и работа с

01:41:07.820 --> 01:41:14.340
lifecycle scope, это чуть ли не самый маскет, который у нас есть. Есть куча библиотек, бесконечное

01:41:14.340 --> 01:41:18.540
количество библиотек на самом деле у сейчас у гугла. Мне кажется, что 15 последнее время только

01:41:18.540 --> 01:41:22.940
использовал. Практически у каждой из них есть поддержка корутин и вообще, как бы корутин,

01:41:22.940 --> 01:41:28.780
это чуть ли не номер один инструмент работы в такой много поточной среде с точки зрения гугла и

01:41:28.780 --> 01:41:35.540
Android разработки. Так что, кажется, вы не ошибетесь, если начнете изучать подробно корутины и начнете

01:41:35.540 --> 01:41:43.140
пользоваться библиотеками из Android Jetpack. В заключение, я понимаю, что уже довольно

01:41:43.140 --> 01:41:49.380
долго и довольно долго с вами тут сидим и изучаем корутины. Немножко пробежимся по channels

01:41:49.380 --> 01:41:56.620
and flow. Повторюсь, главная задача текущей лекции вам в основном рассказать про корутины. Channels

01:41:56.620 --> 01:42:02.860
and flow, на мой взгляд, это не такая сложная тема и их можно узнать самостоятельно, просто чуть-чуть

01:42:02.860 --> 01:42:09.460
попрактиковавшись. Важно просто понимать всю концепцию корутин, работы со spin функциями и

01:42:09.460 --> 01:42:17.020
работа там с jobs, с их lifecycle и так далее. А остальное, это дело наживное, вы сможете сами спокойно

01:42:17.020 --> 01:42:23.700
разобраться в этой теме, хорошо поняв предварительную фундаментальную часть в виде корутин. Но все же,

01:42:23.700 --> 01:42:27.020
все равно в рамках лекции мы чуть-чуть пробежимся по основным интерфейсам, поймем, как с ними

01:42:27.020 --> 01:42:34.500
работать. У нас есть интерфейс channels. Вообще channels, как каналы, это возможность в виде, знаете,

01:42:34.500 --> 01:42:41.940
это очень похоже на какой-то blocking queue, где вы имеете потребителя и имеете производителя каких-то

01:42:41.940 --> 01:42:48.900
элементов общаться между собой. То есть у вас есть канал передачи, есть канал получения. И channels

01:42:48.900 --> 01:42:56.100
реализуют оба таких входа, выходных точек. То есть есть send channel, позволяющий вам отправлять

01:42:56.100 --> 01:43:02.580
что-либо, и receive channel, позволяющий вам получать что-либо. Отдельно здесь останавливаться не буду,

01:43:02.580 --> 01:43:07.460
здесь все более-менее понятно. Есть функция send, которая отправляет значения, есть функция receive,

01:43:07.460 --> 01:43:14.500
которая эти значения получает. И заметьте, что они являются suspend. Вот я сказал, что channel очень

01:43:14.500 --> 01:43:21.860
похож на blocking queue, но вот blocking queue, судя по своему названию, блокируется. То есть мы, если мы

01:43:21.860 --> 01:43:28.100
являемся потребителем и пытаемся получить новый элемент, которого нет еще, мы заблокируемся. Если

01:43:28.100 --> 01:43:35.580
же мы являемся поставщиком элементов и на текущий момент нету потребителя, готова обработать наш

01:43:35.580 --> 01:43:40.980
новый элемент, мы также заблокируемся. Так вот, в случае с channel-ами все примерно то же самое,

01:43:40.980 --> 01:43:46.420
только мы не блокируемся, а приостанавливаемся, как и везде. Вот поэтому эти функции являются suspend.

01:43:46.420 --> 01:43:53.820
Пример использования давайте рассмотрим. Здесь я явно сам создаю channel, использую этот channel для

01:43:53.820 --> 01:43:59.340
того, чтобы отправить сообщение через, ну с помощью одной крутины. Вот и здесь я явно пометил, что это

01:43:59.340 --> 01:44:05.140
у меня sender. Вот я создал крутину, здесь я 5 раз что-то пытаюсь в цикле пройтись и напечатать какую-то

01:44:05.140 --> 01:44:10.780
строчку. Вот потом этот channel закрываю. А есть еще receiver, это какая-то соседняя крутина, которая,

01:44:10.780 --> 01:44:18.140
причем видите здесь можно использовать обычный for each loop, то есть пройтись по всем элементам

01:44:18.140 --> 01:44:25.500
channel-а, как в цикле и обработать эти сообщения. Вот и это будет нашим receiver. К слову, вот даже

01:44:25.500 --> 01:44:31.780
в нашем проекте в Yandex.P мы используем вообще концепцию channel-ов и умеем обрабатывать вот

01:44:31.780 --> 01:44:36.780
такие сообщения примерно так же, как я показал на слайде. То есть у нас есть поставщик каких-то

01:44:36.780 --> 01:44:42.980
событий, есть получатель. И вот получатель также в for each цикле ожидает новые значения и их потом

01:44:42.980 --> 01:44:49.100
как-то обрабатывает. Ключевой момент в том, что channel является горячим источником данных. Что это

01:44:49.100 --> 01:44:57.100
значит? Что этому каналу особо-то не важно, есть ли у него сейчас какие-то потребители и он будет

01:44:57.100 --> 01:45:03.540
производить, ну в случае, если мы просто создаем его через функцию produce, как на слайде, он будет

01:45:03.540 --> 01:45:09.580
производить элементы и ему там не особо-то и важно, есть ли сейчас какие-то потребители, он может

01:45:09.580 --> 01:45:15.460
там закашировать какие-то значения, если мы буфер изначально передали. Ну и какие-то элементы может

01:45:15.460 --> 01:45:24.020
потом пропустить, если буфер не позволяет хранить все. Вот. И это важно, почему я вообще начал

01:45:24.020 --> 01:45:29.060
говорить про горячий источник данных в том, что flow, который мы рассмотрим буквально на следующем

01:45:29.060 --> 01:45:33.540
слайде, является изначально вот сам интерфейс с холодным источником данных. Вот. Горячий

01:45:33.540 --> 01:45:38.700
получается, что он активно генерирует данные, даже если никто не принимает эти данные и не слушает

01:45:38.700 --> 01:45:44.540
сейчас в моменте. И при подписке на горячий источник данных мы начнем получать данные, вот только

01:45:44.540 --> 01:45:49.620
те актуальные, которые у него есть сейчас на данный момент или те данные, которые он закашировал

01:45:49.620 --> 01:45:57.020
у себя в буфере. Вот. А flow он генерирует, обычный flow, который мы сейчас посмотрим, как создавать,

01:45:57.020 --> 01:46:02.780
он будет генерирует, генерирует элементы только при запросе. И каждый подписчик начнет получать

01:46:02.780 --> 01:46:09.340
свою, свою копию, свою серию данных, начиная сначала, ну начиная сначала создание элементов

01:46:09.340 --> 01:46:15.740
внутри flow. Вот. Получается, что flow у нас холодный источник данных. И сейчас я не говорю про

01:46:15.740 --> 01:46:21.620
state flow и про shared flow, а именно про обычный интерфейс flow, в котором мы также можем работать.

01:46:21.620 --> 01:46:28.220
Вот. Flow сам по себе можно как-то перевести как поток, но пожалуйста не путайте его с тредами,

01:46:28.220 --> 01:46:32.780
которые мы рассмотрели раньше. Просто это какой-то некий поток значений или поток данных,

01:46:32.780 --> 01:46:38.940
который мы можем обработать, цепочка событий. Вот. Эти данные там могут работать и вычисляться

01:46:38.940 --> 01:46:50.540
синхронно. И мы начнем получать данные только в момент непосредственно самой подписки. Сам интерфейс flow,

01:46:50.540 --> 01:46:55.660
он выглядит полностью, я его полностью уже указал на слайде, то есть у него есть только одна функция

01:46:55.660 --> 01:47:01.300
collect. Этот flow можно самим реализовать, но мы посмотрим на его там такие основные реализации

01:47:01.300 --> 01:47:08.420
чуть позже. Вот. В flow есть два интерфейса основных, это непосредственно сам flow и flow collector,

01:47:08.420 --> 01:47:14.380
который он принимает в своей функции collect. Использовать сам flow можно вот таким образом.

01:47:14.380 --> 01:47:22.620
Мы вызываем фабричную функцию flow, в которой начинаем производить элементы. В примере со

01:47:22.620 --> 01:47:30.820
students flow я что делаю? Я пытаюсь три раза после дилея заимитить юзера с текущим индексом. Но вот

01:47:30.820 --> 01:47:37.340
вся особенность в том, что если я просто вызову students flow, который вернет мне flow моих

01:47:37.340 --> 01:47:48.540
юзеров, не приведет к самому вычислению данных юзеров. Они начнут вычисляться и начнут приходить

01:47:48.540 --> 01:47:56.220
мне как подписчику только в момент подписки. Вот я suspend функции main вызываю функцию collect,

01:47:56.220 --> 01:48:02.940
и это является триггером для сбора элементов, для начала сбора элементов, для начала их создания.

01:48:03.900 --> 01:48:11.820
И дальше уже в collect я начинаю этих подписчиков этих студентов обрабатывать. Получается,

01:48:11.820 --> 01:48:17.700
что здесь отличие от channel в том, что produce моментально начнет производить элементы,

01:48:17.700 --> 01:48:22.500
как только я их создам, а во flow мне нужно подписаться. И только после этого,

01:48:22.500 --> 01:48:27.860
то есть должен быть какой-то терминальный оператор, терминальная функция, которая затриггерит запуск

01:48:27.860 --> 01:48:36.980
имита, запуск отправки и создание новых элементов. Сама структура flow указана на слайде,

01:48:36.980 --> 01:48:42.740
то есть у нас сначала есть flow builder, это обычно вот такая фабричная функция типа flow, где мы

01:48:42.740 --> 01:48:51.620
внутри экшена пытаемся по особому алгоритму, как мы захотим, начать имитить значения. Дальше

01:48:51.620 --> 01:48:56.620
обычно идет серия операторов. Что это такое? Intermediate операторы, я их тут так назвал,

01:48:56.620 --> 01:49:03.540
это промежуточные операторы, которые как-то видоизменяют наш поток, нашу цепочку данных.

01:49:03.540 --> 01:49:08.580
Вот здесь я привел в пример, что есть on itch, on start, on completion, catch. Ну вот для примера,

01:49:08.580 --> 01:49:13.660
on itch возьмет текущий элемент и может с ним что-то сделать по ходу дела, как сайд эффект какой-то.

01:49:13.660 --> 01:49:20.140
В данном случае я просто печатаю текущее значение, которое пришло в on itch на экран. Есть

01:49:20.140 --> 01:49:26.980
on start, on completion. Это такие стартовые кулбеки, когда я только подписываюсь на новый flow,

01:49:26.980 --> 01:49:34.020
или когда этот flow полностью завершается. Catch позволяет мне, как подписчику на flow,

01:49:34.020 --> 01:49:39.500
обработать определенные исключения и заметить новые значения. В общем, на самом деле вот этих

01:49:39.500 --> 01:49:45.300
операторов целая тьма, мы часть из них сейчас рассмотрим дальше на слайдах. А есть терминальная

01:49:45.300 --> 01:49:51.580
операция, терминал operator как collect. Их на самом деле несколько бывает, но вот collect,

01:49:51.580 --> 01:49:58.140
наверное, основной. Только он затриггерит запуск нашего flow. Как это происходит? Вот представьте,

01:49:58.140 --> 01:50:04.740
что есть flow builder, он вернул нам какой-то объект. Это просто напросто какой-то действительно объект,

01:50:04.740 --> 01:50:09.820
который ничего сейчас не делает. Дальше мы к нему применяем серию intermediate операторов,

01:50:09.820 --> 01:50:14.620
которые также ничего не делают, они просто декларируют, что произойдет с элементами,

01:50:14.620 --> 01:50:20.780
когда они начнут приходить. А есть терминальный оператор, который всю эту движуху запускает.

01:50:20.780 --> 01:50:26.420
Он вот как по цепочке, вот как здесь по коду, начинает снизу вверх идти и просить дать ему

01:50:26.420 --> 01:50:33.220
элементы. То есть функция collect затриггерит тот flow, который был передан после функции catch,

01:50:33.220 --> 01:50:38.100
отдай мне, пожалуйста, элементы. Тут в свою очередь пойдет в он completion, тот вон start,

01:50:38.100 --> 01:50:44.220
тот вон itch и так дойдет до, все дело дойдет до flow builder, который начнет иметь значение. Вот

01:50:44.220 --> 01:50:47.500
это вот такая вот особенность в том, что есть терминальный оператор, который начинает

01:50:47.500 --> 01:50:54.540
триггерить получение элементов, работает как в нашем flow в крутинах, так и в том же rig.java.

01:50:54.540 --> 01:51:01.180
Поэтому, вот возвращаясь к теме с rigs, если вы сначала хорошо поймете крутины, потом на их

01:51:01.180 --> 01:51:07.340
основе поймете, как работает flow, вы довольно легко справитесь с концепцией rig.java, потому что там

01:51:07.340 --> 01:51:12.940
происходит примерно то же самое, что я вам рассказываю здесь. Есть исключения, есть отличия,

01:51:12.940 --> 01:51:18.940
но концепция очень похожа. Есть колонны источник данных, мы на него подписываемся, точнее мы к нему

01:51:18.940 --> 01:51:24.060
прикручиваем набор операторов, а потом с помощью терминального оператора пытаемся затриггерить

01:51:24.060 --> 01:51:31.580
все создание данных внутри flow. И вот когда вы пишете какие-то участки кода, вы спокойно можете

01:51:31.580 --> 01:51:36.940
формировать ваш flow, накручивать на него кучу операторов, но не беспокоиться о том, что он,

01:51:36.940 --> 01:51:43.740
то есть вы уже что-то начинаете создавать. Запуск непосредственно начнется только в момент коллекта

01:51:43.740 --> 01:51:51.100
каким-то образом. Надеюсь, здесь немножко концепцию объяснил. Что насчет промежуточных операторов?

01:51:51.100 --> 01:51:57.460
Назову парочку из них довольно интересных и полезных. Есть мэп, который, соответственно, из

01:51:57.460 --> 01:52:05.260
одних значений конвертит во что-то другое, причем отличие мэп от его аналогов из той же rigs java в том,

01:52:05.260 --> 01:52:10.180
что этот мэп является suspend, и мы можем даже здесь приостановиться, дождаться какого-то

01:52:10.180 --> 01:52:20.780
результата и после чего возобновить работу. Что я здесь делаю? Я, во-первых, создаю набор

01:52:20.780 --> 01:52:29.500
чисел от 1 до 5 и превращаю их во flow. То есть если я начну коллектить мой flow из чисел,

01:52:29.500 --> 01:52:37.420
то я начну по итративно по цепочке получать значение от 1 до 5. Дальше я использую промежуточный

01:52:37.420 --> 01:52:45.380
оператор в виде мэп и пытаюсь текущее значение возвести в квадрат. Дальше уже с помощью коллект,

01:52:45.380 --> 01:52:55.220
с помощью терминальной функции я запускаю генерацию моих элементов, начиная сначала с цепочки

01:52:55.220 --> 01:53:01.780
создания numbers flow и после того как я замапил значения возвелых квадрат, я их печатаю в

01:53:01.780 --> 01:53:10.660
консоли и получаю заветные 1,4,9,16,25. Все числа возвелых квадратов. И вообще мэп супер полезная

01:53:10.660 --> 01:53:15.660
штука, она используется практически везде для разных целей. Здесь привел такой банальный пример

01:53:15.660 --> 01:53:22.460
с маппингом одного числа в другое. Есть фильтр, который будет отфильтровывать набор данных. В данном

01:53:22.460 --> 01:53:30.260
случае я пытаюсь проверить четное число или нет. Если да, то пропускаю дальше. Если нет, то не беру

01:53:30.260 --> 01:53:40.500
с собой. В общем я их пропускаю и не отдаю остальным промежуточным операторам после оператора фильтра

01:53:40.500 --> 01:53:46.620
в данном случае. То есть вот у меня есть 1,2,3,4,5 числа, потом я применяю к нему промежуточный оператор

01:53:46.620 --> 01:53:53.380
в виде фильтра и фильтрую только те числа, которые являются четными и получается на выходе из фильтра

01:53:53.380 --> 01:53:59.620
у меня уже будет только 2,4. И остальные операторы, промежуточные операторы будут работать с 2,4,

01:53:59.620 --> 01:54:07.180
а 1,3,5 даже не увидят. Вот это как бы особенность оператора фильтра. С take, мне кажется, можете

01:54:07.180 --> 01:54:12.860
догадаться и сами, то есть мы ему передаем число и он будет брать только определенный набор чисел

01:54:12.860 --> 01:54:19.420
по счету. Вот здесь я вызываю take, не передаю 3, соответственно я возьму только первые 3 числа.

01:54:19.420 --> 01:54:26.380
Я говорю числа, первых 3 элемента в данном случае это числа. Это 1 до 5 и получается первые 3 числа

01:54:26.380 --> 01:54:36.020
1,2,3. Есть еще zip, который связывает набор данных. Вот представьте, что у нас есть два flow. Первый

01:54:36.020 --> 01:54:44.860
возвращает числа, второй возвращает символы. В данном случае abcd, e. И я пытаюсь zip как цепочку

01:54:44.860 --> 01:54:51.660
на молнии, я пытаюсь склеить один flow с другим и у меня будут сформированы пары значений. Вот,

01:54:51.660 --> 01:55:00.300
то есть я получается вызвал numbersflow.zip и передал ему второй flow и дальше он будет склеивать

01:55:00.300 --> 01:55:05.820
значения из этих flow, он будет склеивать между собой и формировать новое значение. Вот обычно

01:55:05.820 --> 01:55:12.100
такие операторы используются для того, чтобы склеить походы в разные опишки, которые возвращают

01:55:12.100 --> 01:55:18.700
свои flow и мы пытаемся на основе нескольких опишек получить финальный результат. Вот здесь опять же

01:55:18.700 --> 01:55:25.660
такой пример синтетический простой, но поверьте в продакшн коде zip тоже используется как раз для

01:55:25.660 --> 01:55:30.580
склеивания данных из разных опишек, из разных сервисов, чтобы потом получить какой-то единый

01:55:30.580 --> 01:55:36.940
результат. Вот. И таких примеров, таких операторов уйма, я не хочу тратить ваше время, чтобы просто

01:55:36.940 --> 01:55:42.660
объяснять каждый из них по отдельности. Кажется проще просто пройти по документации и почитать

01:55:42.660 --> 01:55:47.100
про них. И я хотел именно объяснить концепцию того, что вот есть промежуточные операторы,

01:55:47.100 --> 01:55:52.900
которые как-то видоизменяют наши элементы по ходу дела. Что насчет shared flow, state flow? Вот они

01:55:52.980 --> 01:56:01.780
как раз являются горячими источниками данных, то есть они в отличие от обычного flow позволяют

01:56:01.780 --> 01:56:09.100
нам генерить какие-то элементы по ходу дела и не зависит от того, есть ли у них сейчас подписчик или

01:56:09.100 --> 01:56:15.940
нет. Вот. Shared flow как видите наследуется от flow, у него есть reply cache, который как раз нужен для

01:56:15.940 --> 01:56:23.140
хранения элементов внутри себя. У него есть возможность, точнее так, есть shared flow как

01:56:23.140 --> 01:56:31.420
red-only коллекция по аналогии с листами и mutable листами в Kotlin. У него есть свой аналог в виде mutable

01:56:31.420 --> 01:56:37.660
shared flow, который позволяет изменять значения внутри flow, то есть имитить новые значения внутри него.

01:56:37.660 --> 01:56:45.900
Вот. Как это обычно работает? Представим, что есть flow как поток данных, мы с помощью mutable

01:56:45.900 --> 01:56:51.660
shared flow можем этот поток данных видоизменять с помощью внешнего интерфейса, с помощью функции try

01:56:51.660 --> 01:56:59.420
emit, ну или просто emit. Как мы это делаем? Вот я здесь создаю shared flow, делаю mutable shared flow и

01:56:59.420 --> 01:57:07.380
создаю две крутины, которые начинают коллектить мой shared flow. Делаюсь на секунду, а после чего

01:57:07.380 --> 01:57:14.460
имитчу message1 и message2 вот в мой flow. То есть есть внешний контракт у самого mutable shared flow,

01:57:14.460 --> 01:57:20.380
если возможно, заимитить значения, я это делаю, а в других крутинах пытаюсь подписаться и получить

01:57:20.380 --> 01:57:27.540
результаты. Так как я подписался заранее, грубо говоря, и делай в одну секунду мне точно хватит на

01:57:27.540 --> 01:57:33.340
то, чтобы создать крутины и подписаться, я получу ровно то, что ожидается. В каждой из крутин я

01:57:33.340 --> 01:57:41.060
получу и первое сообщение, и второе. В случае, если бы я создал эти крутины сильно позже, после того,

01:57:41.060 --> 01:57:47.260
сколько я бы заимитил, тут уже зависит от того, как реализован shared flow и какие гарантии он дает по

01:57:47.260 --> 01:57:54.580
поводу хранения данных, заимиченных ранее до того, как кто-то подписался на этот shared flow.

01:57:54.580 --> 01:58:03.660
Что такое shared flow? Это его аналог, это расширение концепции shared flow, он работает аналогично,

01:58:03.660 --> 01:58:10.460
только его особенность в том, что reply cache, вот этот внутренний cache по хранению данных,

01:58:10.460 --> 01:58:16.380
которые никому еще не были переданы, оно связано к одному, то есть state flow хранит в себе всегда

01:58:16.380 --> 01:58:23.180
только одно конкретное значение. Для нас это супер важно в контексте работы с тем же стейтом

01:58:23.180 --> 01:58:29.700
экрана. Почему? Нам не хочется хранить стейты экрана, какие-то предыдущие стейты экрана, а нам

01:58:29.700 --> 01:58:34.980
всегда хочется иметь актуальное, единственное значение, которое ему соответствует. И вот state

01:58:34.980 --> 01:58:40.740
flow это идеальный кандидат, для этого покажу каким образом. Получается в state flow у нас

01:58:40.740 --> 01:58:45.980
есть всегда в единый момент времени текущее значение, его можно вытащить через value,

01:58:45.980 --> 01:58:54.980
а есть в контракте mutable state flow возможность, причем атомарно, изменить текущее значение

01:58:54.980 --> 01:59:01.180
внутри state flow. Это как раз делается примерно через те же концепции compare and set, которые я

01:59:01.180 --> 01:59:08.780
объяснял на предыдущей лекции по многопоточности. Примерно та же концепция, как в атомиках. И функции

01:59:08.780 --> 01:59:14.220
примерно также называются compare and set, update and get, в общем, очень похоже. Давайте покажу,

01:59:14.220 --> 01:59:19.980
как это выглядит. Вот я создаю mutable state flow, опять же в какой-то курантине я на этот state

01:59:19.980 --> 01:59:26.300
подписываюсь, дальше после задержки я во-первых, а какая еще особенность, я забыл про это сказать,

01:59:26.300 --> 01:59:31.940
для state flow нужен initial value, то есть начальное значение. Мы его обязательно должны передать,

01:59:31.940 --> 01:59:38.380
в данном случае я просто передаю буквку A. Дальше я в курантине пытаюсь подписаться на этот

01:59:38.380 --> 01:59:47.260
state, печатаю значение, которое из этого state могут прийти, и после дилея я пытаюсь из текущего

01:59:47.260 --> 01:59:55.420
стейта взять значение и его переназначить на буквку B. И это поможет, это будет работать,

01:59:55.420 --> 02:00:02.780
я реально в state flow получу другое значение. И дальше после дилея я пытаюсь подписаться на этот

02:00:02.780 --> 02:00:11.980
стейт еще раз и получу ровно буквку B, которую изменил ранее. Что тут важно? Во-первых, именно

02:00:11.980 --> 02:00:18.940
state.value я бы так особо не делал. Почему? Хочется, чтобы вы явно создавали проблему работы с

02:00:18.940 --> 02:00:25.940
разделяемым ресурсом, и что явно обращаться к переменной просто вот так и менять у нее значение

02:00:25.940 --> 02:00:32.580
не стоит. Это можно делать только если вы явно знаете, что сейчас находитесь в usl, в main потоке,

02:00:32.580 --> 02:00:38.060
в одном единственном потоке, и безопасно менять значение вот так вот на ходу. Что я вам предлагаю?

02:00:38.060 --> 02:00:44.460
Работать примерно по такой концепции. Вот у вас есть view-модель. Туда вы передаете какие-то

02:00:44.460 --> 02:00:50.220
репозиторы, интеракторы, use-кейсы, не важно что, это те классы, которые отвечают либо за работу с

02:00:50.220 --> 02:00:57.820
датаслоем, с каким-то данными, либо за работу в domain-слое, то есть вашу бизнес-логику непосредственно.

02:00:57.820 --> 02:01:06.940
Дальше есть UI-state, которая отвечает за state-экрана. Это может быть описание того, каких состояний

02:01:07.020 --> 02:01:12.340
экран находится, какие кнопки нужно показать, какие скрыть, как реагировать на нажатие

02:01:12.340 --> 02:01:17.340
пользователя, какую анимацию запустить, и так далее. В общем, этот UI-state должен описывать то, как

02:01:17.340 --> 02:01:24.620
выглядит ваш экран. И обычно это происходит так, что вы в mutable-state-flow храните, причем с нижним

02:01:24.620 --> 02:01:33.740
подчеркиванием для чего, чтобы явно разделить интерфейсы read-only-flow и mutable-flow. В общем,

02:01:33.740 --> 02:01:40.580
вы в mutable-state-flow храните state-вашего экрана, а внутри функции, типа вот как у меня onCreate,

02:01:40.580 --> 02:01:47.180
вы получаете определенные данные, а потом автомарно, например, через функцию update,

02:01:47.180 --> 02:01:53.220
которая есть в mutable-state-flow, вы обновляете ваш state-экран. И это происходит, повторюсь,

02:01:53.220 --> 02:02:01.100
автомарно и безопасно для работы в многопоточной среде. Вот такой концепции я бы ожидал от вас в

02:02:01.180 --> 02:02:10.340
ваших работах и в ваших проектах. То есть есть state-flow, который олицетворяет вообще ваш state-экран,

02:02:10.340 --> 02:02:16.580
и вы его автомарно меняете с помощью функции update в разных точках, либо вообще в определенном

02:02:16.580 --> 02:02:24.060
каком-то месте, где, может быть, у вас есть, не знаю, switch или van по всем состояниям экрана или

02:02:24.060 --> 02:02:29.620
там бизнес-логики, и вы явно говорите, что только вот в этой функции вы можете менять state-экрана

02:02:29.620 --> 02:02:38.620
через функцию update в state-flow. В общем, вот что-то такое я бы в первую очередь начал делать в

02:02:38.620 --> 02:02:46.540
проектах, так использовать state-flow. В общем, наверное, ключевая мысль. Повторюсь, здесь явно вынес

02:02:46.540 --> 02:02:53.660
надельный слайд. Вот обновлять state стоит вот так. Не нужно обращаться к переменной точке value у

02:02:53.660 --> 02:03:02.780
state-flow и что-то у нее менять, потому что тем самым вы можете для себя же в будущем поломать логику

02:03:02.780 --> 02:03:08.980
работы, если вы из того не сего начнете работать со state в нескольких потоках. Лучше явно сразу

02:03:08.980 --> 02:03:19.020
обезопаситься и работать автомарно со значениями внутри него. И напоследок я приведу пример того,

02:03:19.020 --> 02:03:25.380
как у нас работают некоторые репезитории в проектах. В случае, если мы хотим, чтобы репезитории

02:03:25.380 --> 02:03:30.900
работали по такой концепции, что в in-memory кэше, например, они хранили данные, и эти данные могли

02:03:30.900 --> 02:03:36.380
меняться только автомарно, вот мы обычно делаем примерно следующее. То же самое, как в view-модели.

02:03:36.380 --> 02:03:46.060
У нас есть state-flow, который хранит данные, и мы через него обновляем само состояние внутри. А

02:03:46.060 --> 02:03:51.620
есть flow, который вытащен наружу для чтения. Все наши подписчики наших репезиторий будут

02:03:51.620 --> 02:03:56.740
подписываться на state-flow и получать актуальное значение оттуда. И причем давайте, наверное,

02:03:56.740 --> 02:04:02.140
еще ни разу не объяснял, и вот как раз завершающая мысль будет, почему есть такое разделение на

02:04:02.140 --> 02:04:07.500
mutable state-flow и на обычный state-flow. Mutable state-flow нужен только для внутреннего использования

02:04:07.500 --> 02:04:15.420
внутри класса, и он позволяет видоизменять на state-flow. А наружу мы вытаскиваем интерфейс

02:04:15.420 --> 02:04:22.500
state-flow, не позволяющий нам никак влиять на state-flow и менять значение внутри него. Благодаря

02:04:22.500 --> 02:04:29.660
этому у нас есть возможность вытащить наружу только red-only вариант. И на этом на самом деле

02:04:29.660 --> 02:04:35.340
сегодня все. Я, мне кажется, прошелся по основным концепциям, которые, на мой взгляд, важны,

02:04:35.340 --> 02:04:44.260
которые вам стоит использовать у себя в коде. Давайте еще раз напомню, какие темы мы с вами

02:04:44.260 --> 02:04:49.580
обсудили. Мы узнали, что такое крутина, хотя бы, надеюсь, на базовом уровне. Мы узнали, что такое

02:04:49.580 --> 02:04:59.020
крутин-билдеры, узнали, как работать с estate наших крутин, немножко окунулись в тему отмены крутин,

02:04:59.020 --> 02:05:06.940
работать с исключениями и немножко познакомились с state-flow и с shared-flow. Надеюсь, сегодня было

02:05:06.940 --> 02:05:13.740
довольно полезно хотя бы для такой вводной встречки. На что стоит посмотреть. Каждый год

02:05:13.740 --> 02:05:20.620
рекомендую примерно одно и то же. Здесь немножко поменял ссылки, мне кажется. В общем, на самом деле

02:05:20.620 --> 02:05:26.660
можете приходить ко мне еще в личку, порекомендую еще такой же большой список. Здесь основное,

02:05:26.660 --> 02:05:32.740
что точно стоит прочитать и узнать. Официальный гайд по крутинам, пройдитесь, пожалуйста, там довольно

02:05:32.740 --> 02:05:39.620
много ключевой информации изложено. Каждый раз привожу ссылку Scott Linkon, где объясняю эту

02:05:39.620 --> 02:05:44.660
концепцию, работа с исключениями. Там как раз один из примеров, которые я указывал на слайде.

02:05:44.660 --> 02:05:51.180
Всегда топлю за статьи Романа Лизарова, прочитал, мне кажется, все его статьи на медиуме. Вот тоже

02:05:51.180 --> 02:06:00.700
прошу вас глянуть. Как раз это один из основных авторов крутин. Особенно в начале работы над

02:06:00.700 --> 02:06:07.020
крутинами и проектированием крутин в 18-19 годах он очень много писал статей на медиуме и объяснял

02:06:07.020 --> 02:06:13.140
причины того, почему крутина работает так, как они сейчас устроены и что служило доводом для

02:06:13.140 --> 02:06:17.060
этого. Плюс объясняет некоторые концепции, как, например, работа с разделяемыми ресурсами,

02:06:17.060 --> 02:06:22.460
объясняет, что такое как раз таки холодный поток и горячий поток, ну и много всего другого

02:06:22.460 --> 02:06:28.820
полезного, так что прошу посмотрите. Вот. А насчет того, как устроены крутины, есть много докладов.

02:06:28.820 --> 02:06:33.980
От того же Романа Лизарова несколько докладов, причем на разных конференциях. Есть вот Мартсен

02:06:33.980 --> 02:06:39.660
Маскала, который автор нескольких книг про котлин, в том числе по крутины, и вот в ролике,

02:06:39.660 --> 02:06:44.380
который ссылку, которые прикладываю здесь, он объясняет то, как крутина устроена под

02:06:44.380 --> 02:06:50.060
капотом и во что превращаются наши suspend функции после работы компилятора. Мне кажется, как раз этот

02:06:50.060 --> 02:06:56.980
доклад сможет вам помочь в освоении крутин и в понимании того, как крутины устроены под капотом.

02:06:56.980 --> 02:07:06.060
Вот. На этом все. Давайте попробуем ответить на вопросы, на последнюю часть, и сегодня закончим.

02:07:06.060 --> 02:07:14.860
Можно ли вручную задать размер пул потоков для диспатчера? Да. Вы можете передать свой

02:07:14.860 --> 02:07:20.900
кастомный диспатчер и сформировать его так, как хотите. Можете создать пул потоков из одного

02:07:20.900 --> 02:07:26.780
потока всего, то есть сделать его таким однопоточным и использовать для своих нужд, например,

02:07:26.780 --> 02:07:33.500
для упрощенной работы с многопоточным кодом со со разделяемым ресурсом. Можете указать даже

02:07:33.500 --> 02:07:38.620
пул потоков из тех же экзекьюторов, почему нет? Ну, тех же пул потоков, которые используются в

02:07:38.620 --> 02:07:46.620
экзекьюторах у вас с другой частью кода. Подписка в UI на Stateflow из VM выглядит избыточно, особенно если

02:07:46.620 --> 02:07:54.900
стейтов много. Есть ли смысл в Core модуль выносить логику подписки? Не уверен, что это выглядит

02:07:54.900 --> 02:08:01.700
избыточно. Есть ли смысл в Core модуль выносить логику подписки? Мне кажется, сложно мне ответить

02:08:01.700 --> 02:08:06.380
на такой вопрос, потому что я не до конца его понимаю, что мы хотим вынести в Core модуль. Ну,

02:08:06.380 --> 02:08:11.740
я бы сказал так. Для начала точно стоит отталкиваться от концепции, что у нас есть

02:08:11.740 --> 02:08:18.420
view модель, которая хранит какой-то стейт, а в UI мы не храним сами по себе никакой стейт,

02:08:18.420 --> 02:08:23.580
мы только лишь подписываемся на что-то, что имеет жизненный цикл больше, чем у вьюшки,

02:08:23.580 --> 02:08:29.780
у нашего активити, у нашего фрагмента или там у каких-то компус-функций, и мы получаем данные

02:08:29.780 --> 02:08:35.420
из той же view модели, точнее подписываемся на эти данные тогда, когда нам удобно, когда мы можем

02:08:35.420 --> 02:08:40.580
что-то отрисовать и реагируем на изменения. Вот эту концепцию я бы точно использовал практически

02:08:40.580 --> 02:08:46.700
везде, на всех экранах, и она уже доказала свою состоятельность и может быть по праву

02:08:46.700 --> 02:08:57.060
использована практически везде. Вопрос стоит, нужно ли использовать крутины? Так, при наблюдении

02:08:57.060 --> 02:09:03.500
за flow или live data можно еще пару предложений об этом. Тоже не совсем понял вопрос, но услышал

02:09:03.500 --> 02:09:10.980
ключевое слово live data. На мой взгляд, ее особо не стоит использовать уже. Это избыточный фреймворк,

02:09:10.980 --> 02:09:16.380
который вам по факту-то не нужен. Я бы все же рекомендовал везде использовать flow и обычные

02:09:16.380 --> 02:09:23.580
крутины и live data практически нигде не использовать. Мне кажется, потом будет вам сложнее от нее уйти,

02:09:23.580 --> 02:09:31.620
в случае, если будете по-прежнему ее использовать. На мой взгляд, это история временная и скоро live

02:09:31.620 --> 02:09:38.340
data практически не будет. Я не вижу предпосылок, чтобы она имела популярность и смогла закрыть

02:09:38.340 --> 02:09:44.060
какие-то определенные кейсы из state flow или из обычного flow. Можешь привести примеры

02:09:44.060 --> 02:09:51.420
использования Channel именно в Android? К сожалению, я думал о том, чтобы показать пример того,

02:09:51.420 --> 02:09:57.660
как у нас в проекте используется Channel. Давайте просто на словах объясним. У нас используется

02:09:57.660 --> 02:10:06.420
Channel. Мы его используем для отправки... Давайте так. Есть концепция MVI. Это один из таких

02:10:06.420 --> 02:10:11.780
архитектурных паттернов для presentation слоя. Он может быть по-разному использован. Есть библиотека

02:10:11.780 --> 02:10:19.740
Orbit. Можете прогуглить, что это такое. Там есть механизм отправки интентов. У нас в проекте

02:10:19.740 --> 02:10:26.460
аналогично используется отправка интентов. Мы отправляем интенты путем сэнда в Channel событий

02:10:26.460 --> 02:10:33.780
на этот интент, на обработку какого-либо действия. А дальше наш обработчик и обрабатывает все интенты

02:10:33.780 --> 02:10:42.700
и как-то их менеджит у себя внутри. Там мы как раз используем концепцию Channel. Все extension

02:10:42.700 --> 02:10:52.740
коллекциям будут работать с Flow. Что ни вопрос, я пока не очень понимаю, как на них отвечать. Все

02:10:52.740 --> 02:11:00.220
extension с коллекциями будут работать с Flow. Смотрите, если имеется в виду, что я создал набор чисел и

02:11:00.220 --> 02:11:10.700
потом их превратил в Flow, вообще, можно практически любую коллекцию завернуть во Flow и начать имитить

02:11:10.700 --> 02:11:15.700
значения оттуда. Наверное, да. То есть вы можете даже сами вручную такое сделать, создать свой

02:11:15.700 --> 02:11:21.580
factory method Flow и начать имитить значения оттуда, просто притерировавшись по коллекции. Почему нет?

02:11:21.580 --> 02:11:29.020
Зачем повторно подписываться на Slateflow, разве данные не должны изменяться динамически? Слайд

02:11:29.020 --> 02:11:34.020
139. Так, а я на каком сейчас слайде? Давайте, ладно, тут всего пару слайдов, я дойду до конца.

02:11:34.020 --> 02:11:43.720
Дело в том, что здесь уже создана другая крутина, то есть я в двух крутинах подписываюсь на одно и

02:11:43.720 --> 02:11:48.460
тоже. Просто привожу пример, что подписчиков может быть несколько и каждый из подписчиков будет

02:11:48.460 --> 02:11:55.740
получать свои значения. То есть я в каждой крутине получу значение актуальное. Как-то так.

02:11:55.740 --> 02:12:08.140
Почему немутабельный UIStateSharedFlow, а не StateFlow? Так, опять же, наверное, это в контексте какого-то

02:12:08.140 --> 02:12:12.420
слайда, пожалуйста, если прям интересно, можете написать мне отдельно с указанием слайда,

02:12:12.420 --> 02:12:18.060
я постараюсь ответить. И давайте последний вопрос, вижу он как раз мне пришел, и на этом

02:12:18.060 --> 02:12:23.220
закончим. А почему для public StateFlow не использовать Getter Value? На слайде было явное создание через

02:12:23.220 --> 02:12:29.740
присвоение. Не, вообще, на самом деле, это можно по-разному реализовать эту концепцию. Главная идея

02:12:29.740 --> 02:12:37.260
того, что мы скрываем интерфейс, который видоизменяет наш StateFlow, и наружу выставляем

02:12:37.260 --> 02:12:43.380
только Redon-ли часть. Это можно сделать реально по-разному. Можно через Getter и закрыть приватную

02:12:43.380 --> 02:12:51.700
Setter. Можно сделать, как я указал, мы используем приватный полис с mutable StateFlow, а наружу вытаскиваем

02:12:51.700 --> 02:12:57.100
публично только Redon-ли часть. В общем, я здесь не утверждаю, что это единственный верный путь,

02:12:57.100 --> 02:13:01.900
то как я указал на слайде, скорее хотел передать главную идею того, что мы делаем. Мы не отдаем

02:13:01.900 --> 02:13:07.100
подписчикам возможность видоизменять на StateFlow, а делаем это только внутри, то есть мы именно

02:13:07.100 --> 02:13:15.060
скрываем внутреннюю реализацию. Наверное, на этом все. Довольно много вопросов было, я надеюсь,

02:13:15.060 --> 02:13:21.700
на большинство из них ответил и, в принципе, сегодня было полезно. По остальным вопросам,

02:13:21.700 --> 02:13:28.460
прошу, можете писать мне в личку, в телеграмме, постараюсь ответить, как будет время. А на сегодня

02:13:28.460 --> 02:13:31.580
все. Всем спасибо за внимание и до новых встреч.

02:14:07.100 --> 02:14:09.100
С вами был Игорь Негода.

02:14:37.100 --> 02:14:39.100
С вами был Игорь Негода.

