start	end	text
0	4000	Редактор субтитров А.Синецкая Корректор А.Егорова
30000	33000	Корректор А.Кулакова
60000	63000	Корректор А.Кулакова
90000	93000	Корректор А.Кулакова
120000	123000	Корректор А.Кулакова
150000	153000	Корректор А.Кулакова
180000	183000	Корректор А.Кулакова
210000	213000	Корректор А.Кулакова
240000	243000	Корректор А.Кулакова
270000	273000	Корректор А.Кулакова
300000	303000	Корректор А.Кулакова
330000	333000	Корректор А.Кулакова
360000	363000	Корректор А.Кулакова
390000	393000	Корректор А.Кулакова
420000	423000	Корректор А.Кулакова
450000	453000	Корректор А.Кулакова
480000	483000	Корректор А.Кулакова
510000	513000	Корректор А.Кулакова
540000	543000	Корректор А.Кулакова
570000	573000	Корректор А.Кулакова
600000	603000	Корректор А.Кулакова
630000	633000	Корректор А.Кулакова
660000	663000	Корректор А.Кулакова
690000	693000	Корректор А.Кулакова
720000	723000	Корректор А.Кулакова
750000	753000	Корректор А.Кулакова
780000	783440	в этой функции наша крутина может быть остановлена.
783440	784440	Вот и все.
784440	787960	После того, как данная функция будет скомпилирована окончательно,
787960	793160	она немножечко трансформируется в не совсем читаемый для нас вид,
793160	797760	но как раз компилятор сделает вывод из того, что функция является suspend
797760	801840	и сделает определенные доработки нашего кода,
801840	805280	которые позволят нам в определенный момент останавливать крутину,
805280	809440	а потом ее возобновлять, то есть доставать из недр наш стек вызовов
809440	817320	всех функций и начинать дальнейшую обработку кода с того места, где мы закончили.
817320	822400	Вот это, наверное, главная мысль, которую нужно вытащить из этого слайда.
822400	823400	Идем дальше.
823400	827400	Какие основные фишки крутин? Почему мы вообще их сегодня рассматриваем,
827400	828960	помимо того, что только что обсудили?
828960	833000	Они соблюдают принцип structure concurrent. Что это значит?
833000	838480	Это значит, что у нас есть возможность выстроить взаимосвязь
838480	840840	между родительскими крутинами и дочерними.
840840	847400	В примере из пятницы я вам показывал, как можно из одного потока создать другие потоки
847400	852040	и запустить их дальше. Вот они живут там у себя и вычисляют что-то,
852040	853680	но мы их особо не контролируем.
853680	862840	Но вот в крутинах есть возможность из родительской крутины достать несколько дочерних,
862840	865400	и у нас будет явная взаимосвязь между ними.
865760	871080	То есть мы в любой момент из родительской крутины сможем узнать, какие у нее есть дочерние,
871080	875000	их там, например, отменить, узнать какой-то дополнительный статус и так далее.
875000	878320	Опять же, чуть позже сегодня в рамках лекции мы увидим примеры.
878320	883880	И вот такая взаимосвязь позволяет нам грамотно устроить, точнее,
883880	888680	выстроить такую каскадную модель отмены всех крутин или обработку ошибок.
888680	892160	Опять же, чуть позже в рамках лекции мы посмотрим, как это делается.
892880	895760	Что еще из плюсов для нас, как для Android разработчиков?
895760	899040	У нас есть отличная полноценная поддержка в Android Jetpack.
899040	906800	То есть практически любая библиотека из Jetpackа от Google уже имеет поддержку крутины,
906800	910800	и мы можем этим пользоваться уже довольно давно, мне кажется пару лет точно.
910800	912920	Идем дальше.
912920	918640	Вот до этого мы просто обсудили, что такое крутины, узнали, как они,
918640	921800	точнее, где они могут выполняться в наших suspend функциях.
921800	928560	Но получается так, что есть suspend функции, эти suspend функции могут вызывать другие suspend функции,
928560	930920	но с чего-то же все это должно начинаться, правильно?
930920	935240	Вот. И все это начинается с двух ключевых элементов.
935240	942440	Первое это крутин-билдеры, по названию можно догадаться, что это такие элементы нашего
942440	945880	аппи из крутин, позволяющие создать новые крутины.
945880	950040	Вот. Но особенность в том, что просто так их создать нельзя,
950040	952360	для этого им нужен крутин-скоп.
952360	956160	И давайте как раз с этими двумя элементами мы познакомимся поближе.
956160	959800	Начнем с билдеров. Здесь я перечисляю, наверное,
959800	964600	сам на из них, причем, мне кажется, главный из них это launch и async, run blocking мы
964600	968880	обсудим немножечко всего лишь. Давайте немного посмотрим на примеры.
968880	972800	Начнем с launch. Launch концептуально очень похоже на поток.
972800	979640	Если посмотрите на слайд, увидите, что мы здесь пытаемся запустить две крутины
979640	985640	с помощью launch. Одна крутина у нас делается на секунду и печатает строчку,
985640	988200	вторая делается на две секунды и тоже печатает строчку.
988200	996520	Вот здесь мы в рамках suspend функции main создали две новых крутины, две дочерних крутины.
996520	1003080	Вот. И если я здесь поменяю launch на thread, концептуально реально будет одно и то же.
1003080	1008120	То есть мы что-то запустили, отправили свободное плавание, там что-то выполним,
1008120	1010120	но нам не важен результат. Вот это вот такая концепция.
1010120	1016040	Запустили какую-то крутину, не возвращающую нам результат, а что-то делающее у себя полезное.
1016040	1024160	Вот. Async же, в свою очередь, это скорее крутина, которая возвращает нам результат,
1024160	1027480	какой-то результат в будущем, отложенный результат.
1027480	1031560	Вот. Аналогию можно привести с executor и функции submit,
1031560	1034600	которые мы рассматривали на предыдущей лекции по многопоточности.
1035480	1039880	Это функция, я имею в виду функция async, она возвращает defret,
1039880	1044240	который как раз и является таким результатом отложенной операции.
1044240	1047840	И здесь мы делаем ровно то же самое, что в предыдущем слайде,
1047840	1050680	только не печатаем строчку, а возвращаем ее после дилея.
1050680	1056400	И в самой последней строчке мы дожидаемся ответа от двух наших крутин.
1056400	1062920	Вот. Но главная особенность в отличие от потоков и executor сервиса,
1062920	1068480	через который мы могли бы ссабмитить задачку, здесь мы крутины приостанавливаем.
1068480	1073560	То есть мы можем всю эту функцию даже вызвать на Main-потоке и не особо беспокоиться о том,
1073560	1078440	что мы как-то сильно заблочим основной поток и не дадим возможность ему отрисовывать наш UI.
1078440	1084280	Потому что сначала мы довольно практически моментально создадим две новых крутины.
1084280	1088560	Эти крутины могут выполняться на Main-потоке, здесь нам это особо не важно.
1088560	1098240	Дилей, кстати, это тоже одна из со спин функций, которая не блокирует поток текущий.
1098240	1108720	Она приостанавливает выполнение текущим потоком и потом возвращает в активное действие текущий
1108720	1113000	поток спустя то время, которое было передано в функции дилей.
1113000	1117840	А с самой последней строчкой мы также приостанавливаем наших крутины, дожидаемся ответа
1117840	1121720	и сама вся функция Main вернет нам результат.
1121720	1130680	Run blocking – это такой особенный вид крутин билдера. Его отличие в том, что он блокирует основной,
1130680	1136320	ну или вообще тот поток, на котором был запущен, до тех пор, пока все, что находится внутри его
1136320	1143360	action кода, то есть внутри лямбдочки, который мы ему передаем, до тех пор он будет заблокирован,
1143360	1147080	если ждет выполнения той или иной suspend функции или крутины.
1147080	1154280	В чем еще важная особенность, которую я не назвал, но буквально сейчас это обсудим.
1154280	1162920	На примере с и Async и с Launch я самой первой строчкой вызываю функцию крутин scope. Почему?
1162920	1169240	Повторюсь, при создании крутин есть два важных элемента, которые стоит рассмотреть.
1169240	1176520	Это крутин билдеры, а второе это крутин scope. Так вот, билдеры типа Async и Launch требуют
1176520	1182600	крутин scope для запуска. По факту они вообще являются extension функциями крутин scope,
1182600	1191040	и это неспроста. Как раз таки крутин scope нам нужен для того, чтобы быть некой входной точкой в
1191040	1197000	крутины и явно обозначать ограничительный какой-то момент, ограничительный фактор того,
1197000	1203480	где наши крутины могут работать и сколько по времени, грубо говоря. То есть мы явно
1203480	1210320	контролируем жизненный цикл наших крутин с помощью крутин scope. И вот в самих extension
1210320	1214680	функциях у нас есть довольно много полезных параметров, которые мы точно будем использовать
1214680	1221440	как на протяжении лекции, так и дальше уже в ходе нашей практики. Первое это крутин контекст.
1221440	1229640	Довольно важная штука, позволяющая нам из одной крутины передавать данные другой дочерней крутина.
1230120	1235960	Так как это крутин билдеры, у нас есть возможность от родительской крутины передать всю необходимую
1235960	1243000	информацию дальше дочерним крутином. Ровно для этого и нужен крутин контекст. Дальше есть параметр
1243000	1248760	start, крутин start. Он позволяет нам регулировать способ запуска. То есть мы можем крутину создать
1248760	1255080	не сразу, а лениво. Например, запланировать какую-то задачку в будущем и затем ее в какой-то
1255080	1260680	момент запустить. Опять же в теме по многопоточности я приводил пример, как я это делал с помощью
1260680	1267080	concurrent hash map и туда клал наши отложенные задачки. И только потом в какой-то момент запускал.
1267080	1273480	Ну и конечно же третьим параметром мы передаем саму функцию блок, в которой и будем выполнять
1273480	1280280	все то, что нужно выполнить текущей крутине. Важно тут подметить, что она является suspend.
1280280	1287880	Благодаря этому мы сможем внутри блок функции вызывать другие suspend функции и приостанавливать
1287880	1296480	наши крутины. В завершение по этой теме важно усвоить то, что крутин scope является входной точкой в
1296480	1303000	крутина. То есть не имея крутин scope у вас практически не получится создать нормальные крутины в самом начале.
1303000	1310000	То есть выйти из этого нашего обычного мира с обычными функциями в мир крутин. Так что мы
1310000	1315560	сегодня увидим много примеров, где то тут, то там мы достаем наш крутин scope, либо создаем его
1315560	1320720	сами вручную и на основе этого крутин scope создаем наши первые крутины. Вообще крутин scope
1320720	1328400	довольно важная вещь и такая фундаментальная, с нее все и начинается. Что дальше? Дальше то, что наш
1328400	1334920	крутин scope знает про остальные крутины. Из него информацию можно вытащить через крутин контекст и
1334920	1341960	как-то косвенно повлиять на другие крутины, либо вытащить мета информацию. В общем сценариев
1341960	1348240	использованы довольно много. И конечно же у крутин scope есть возможность отменить все дочерние крутины,
1348240	1355680	которые были созданы в рамках него. Сам интерфейс крутин scope довольно минимален, в общем у него
1355680	1360600	есть только возможность вытащить крутин контекст, но поверьте нам этого будет достаточно, как раз из
1360600	1367040	крутин контекста можно вытащить много полезной информации. Давайте попробуем его создать.
1367040	1373080	Создадим наш первый крутин scope сами вручную. Делается это довольно просто, также как и любой
1373080	1377720	другой объект. Мы можем создать его с помощью конструктора, передать ему либо пустой крутин
1377720	1385400	контекст, либо вообще ничего. Из-под коробки как раз и будет создан mt-cruitint-context. А на основе
1385400	1392080	него дальше мы запускаем, ну во-первых создаем, а потом мы запускаем наши крутины. Ровно это я и
1392080	1398960	сделал на слайде. Создал scope, на основе scope создал нашу первую крутину. Вот там может быть что-то
1398960	1406600	полезное сделал, а сама функция launch возвращает нам job. Давайте поймем, что такое job. Job это
1406600	1412040	абстракция над жизненным циклом крутины. У нее есть возможность отслеживать то, в каком сейчас
1412200	1417480	состояние она находится и опять же косвенно как-то на нее влиять с помощью API, которая
1417480	1423720	предоставляет интерфейс job. Тут пишу, что как раз job имеет функцию отмены, это мы будем использовать
1423720	1430320	дальше в примерах. И что еще интересно, job является элементом крутин контекста. Как помните,
1430320	1437600	при создании крутин мы передаем крутин контекст, и вот job является одним из элементов крутин контекста,
1437600	1443680	то есть он является ее частью. Вот как раз явно здесь это и показано. Мы видим, что есть объявлен
1443680	1450520	интерфейс job, он наследуется от крутин контекст.element, соответственно, является элементом крутин контекста,
1450520	1456040	и есть полезное API для нас. Первые три свойства — это возможность вытащить информацию о том,
1456040	1463960	в каком состоянии сейчас находится job и соответственно сама крутина, которой он относится. А также есть
1463960	1470840	функция start, позволяющая нам запустить крутину до этого созданного лениво, и функцию cancel,
1470840	1475640	которая позволит нам отменить текущую крутину и все ее дочерние крутины, как мы поймем дальше.
1475640	1483160	Также есть функция join, это практически аналогия тому, что есть у потоков, когда мы у объекта
1483160	1489720	потока можем вызывать join и дождаться выполнения текущего потока ровно то же самое крутиной. Мы
1489720	1494920	можем, имея ссылку на job, заджойниться к ней и дождаться завершения той или иной крутины.
1494920	1501360	Окей, давайте попробуем подробно рассмотреть, в каких состояниях может быть наша крутина. Первое,
1501360	1506520	просто разберем все стейты, которые тут есть. Это new, когда мы крутину только создали, active,
1506520	1513200	когда она уже в активной фазе действия, completing и completed, соответственно, когда она пытается
1513200	1517800	завершиться или уже завершена, и то же самое с отменой. То есть мы либо в процессе отмены,
1517800	1525480	либо уже полностью все отменили и крутина уже не активна. И вот информацию о стейтах мы просто
1525480	1533720	так сами не вытащим, но понимание того, в каком состоянии мы сейчас находимся, мы можем вытащить
1533720	1538280	с помощью наших properties, с помощью наших свойств. Из active, из cancelled, из completed. Попробую
1538280	1543360	продемонстрировать как раз на примере. То есть вот допустим, мы только создали нашу крутину,
1543360	1548920	она сейчас находится в статусе new, соответственно, все флажочки будут возвращать false. Если же мы
1548920	1556920	перешли в активную фазу действия, то наша крутина выйдет в состояние active, а флажочек из active
1556920	1561760	будет возвращать true. Итак, по аналогии, на самом деле мы можем разобрать все стейты в момент
1561760	1567800	завершения, ну попытки завершения, потом в момент непосредственного завершения, дальше в момент
1567800	1576800	отмены крутин, и после того, как крутина полностью завершилась, мы увидим, что и cancelled true,
1576800	1582600	и completed true, потому что мы ее попытались отменить и успешно это сделали. Так что с помощью
1582600	1587240	флажочков можно косвенно понять, что сейчас происходит с крутиной и выполнить какую-то бизнес
1587240	1597080	логику вокруг этого. Давайте попробуем рассмотреть, как работает JDOB на примерах. Опять же, вернемся
1597080	1604400	к нашему примеру из предыдущего слайда, где мы просто запускаем наши две крутины. Здесь мы добавляем,
1604400	1611080	как мы теперь знаем, launch возвращает job, поэтому можем присвоить job1 и job2 к нашим крутинам,
1611080	1619040	после чего мы дождемся выполнения этих двух их обеих крутин и напечатаем значение, свойств
1619040	1625240	из наших job. Соответственно, в конце мы увидим и строчки, которые были напечатаны в крутинах,
1625240	1632000	и статусы каждой из крутин. Из active false, потому что мы крутину уже дождались, и она полностью
1632000	1638440	выполнила все, что нужно, а из completed true, по яным признакам, крутина завершилась, и из completed
1638440	1646360	тоже должен быть true. Дальше мы рассмотрим, как еще можно JDOB использовать в коде. Главная его
1646360	1653320	особенность в том, что есть возможность трека, текущее состояние крутины, ее жизненный цикл. Как я
1653320	1660400	уже сказал ранее, job является элементом крутин контекста, а что там есть еще? Опять же, мы
1660400	1669640	поняли, что в крутин скопе есть крутин контекст, и job является крутин контекстом, а что еще? Что
1669640	1676240	еще там может находиться? Давайте вообще рассмотрим сам интерфейс крутин контекста. Сам по себе
1676240	1683200	контекст — это такой универсальный способ группировать элементы между собой. Что главное,
1683200	1689880	стоит выяснить, что крутин контекст передается от родителя к дочерним крутинам, и концептуально
1689880	1695120	он очень похож на map или set, то есть мы можем обратиться к крутин контексту и вытащить из
1695120	1703920	него элементы по ключу, а ключом будет являться как раз один из интерфейсов, который наследуется от
1703920	1708960	крутин контекста точка элемент. То есть мы можем передать какой-то элемент и вытащить текущее
1708960	1715320	значение по ключу. Крутин контекст определяет поведение крутин, то есть из него мы вытащим
1715320	1720240	информацию, на каком потоке, например, нужно выполнять ту или иную крутину, какое у нее название,
1720240	1727000	как мы будем обрабатывать исключения и так далее. То есть это важная контекстная информация,
1727000	1731920	которая передается от одной крутини к другой. Соответственно, он содержит набор элементов,
1731920	1737040	которые мы можем вытащить внутри крутин и как-то с ними работать, и есть возможность
1737040	1743000	переопределять элементы, если нам это потребуется. Сам фреймворк крутин, он это делает на регулярной
1743000	1748480	основе, каждый раз, когда вы создаете новую крутину, он передает контекст от родительских
1748480	1753840	дочерней и переопределяет некоторые крутины элементы внутри, например, как раз таки джоб,
1753840	1761280	мы это посмотрим чуть позже. Из базовых элементов я бы выделил как раз джоб, крутин name, который нам
1761280	1768840	часто будет необходим просто для дебаг информации или просто если мы хотим вытащить информацию о том,
1768840	1774040	где мы сейчас находимся, в какой крутине, вот это можно сделать через крутин name. Есть крутин
1774040	1779080	dispatcher, сегодня его рассмотрим, он необходим для переключения потоков. Есть крутин exception
1779080	1786160	handler, который необходим нам для обработки исключений, тоже его сегодня обсудим. Как я уже
1786160	1791720	сказал ранее, есть элемент, который является крутин контекстом, мы в принципе не ограничены тем,
1791720	1799280	что есть в библиотеке изначально, мы можем объявить свой элемент крутин контекста и его
1799280	1806280	затащить в текущий крутин контекст в целом. Здесь особо этого делать не будем, это нужно только в
1806280	1810680	конкретных случаях, просто знайте, что у вас есть такая возможность по аналогии с крутин name,
1810680	1819240	крутин dispatcher, вы можете создать свой необходимый вам для работы крутин. А здесь же смотрите,
1819240	1825000	попробую продемонстрировать такой пример. Так как у нас крутин name является элементом крутин
1825000	1829800	контекста, я попробую это сделать, сработать с крутин name как с элементом крутин контекста,
1829800	1835920	а потом вытащить из этого крутин контекста по ключу нужное мне значение. То есть первой строчкой я
1835920	1841080	создаю крутин name, потом к этому же крутин name я обращаюсь к контексту и пытаюсь вытащить
1841080	1848520	значение имени по ключу. И дальше вытаскиваю как раз имя, а если бы я хотел вытащить какой-то
1848520	1854000	другой крутин элемент, например job, которого я еще туда не передавал, то логично, что я получу
1854000	1861840	null. Вот собственно так и происходит. Что дальше? Контексты, как я уже сказал ранее, можно объединять
1861840	1869240	либо как-то видоизменять. Это и происходит в момент создания крутин. Мы пытаемся получить
1869240	1874640	текущую мапу этих элементов, потом с ними выполняем определенную логику с помощью функций
1874640	1881240	fault или дополнительных функций, которые заложены внутри имплементации создания крутин. Мы же можем
1881240	1887000	это использовать у себя в какой-то бизнес логике, например, захотели на основе текущего крутин контекста
1887000	1892160	получить копию, но с измененными элементами внутри. Мы это можем сделать ровно так же, как мы это
1892160	1899960	обычно делаем с мапой. По ключу обращаемся, переименовываем, точнее, переназначаем какой-то
1899960	1908920	элемент по ключу и идем дальше. Вот ключевой момент, что в билдерах в момент создания наших
1908920	1916760	крутин происходит ровно то, что я описал. Берется из родительской крутины текущий крутин-контекст,
1916760	1922640	он используется практически полностью для создания новой дочерней крутины, только еще
1922640	1928920	создается новый job. Мы это рассмотрим буквально на следующих слайдах. Давайте глянем, как это
1928920	1940280	выглядит. Смотрите, сначала я пытаюсь создать крутин name и новый крутин элемент job. Их связку,
1940280	1946560	то есть как раз через плюсик я создаю новый крутин-контекст. Я пытаюсь передать эти данные
1946560	1953680	в мою новую только что созданную крутину через крутин билдер лаунч. А дальше пытаюсь понять,
1953680	1959040	а что же у меня с элементами текущего крутин-контекста. Так как я нахожусь внутри
1959040	1964280	скопа, у меня есть возможность вытащить крутин-контекст и дальше как мапе обратиться и по ключу вытащить нужное
1964280	1972120	мне значение. Так вот, мы видим, что крутин name в моем случае будет печатать то имя, которое я
1972120	1978920	изначально заложил. Я получу true. Но в случае, если я захочу получить job, соответствия не будет.
1978920	1987000	Почему? Потому что при создании новой крутины берется весь крутин-контекст текущий, создается
1987000	1994480	новый job и присваивается по ключу интерфейса job вот в этот новый крутий-контекст. Главное,
1994480	2001000	что нужно запомнить, что при вызове и лаунч и ассинк сама система, то есть сам фреймворк,
2001000	2008480	будет за вас создавать job и делать его наследником всех новых крутин внутри только что созданной.
2008480	2014400	Получается последней строчкой, я пытаюсь вытащить список детей у текущей крутины,
2014400	2022640	и первый же элемент будет равен тому job, который я создал ранее. Как раз-таки это сигнализирует о том,
2022640	2032800	что я вижу то, что есть job, который был создан за меня, а есть job, который создал я сам,
2032800	2038880	и он будет являться только дочерним, точнее, родительским элементом для только что созданного
2038880	2049600	job. Этот пример еще разберем чуть дальше, позже, когда будем обсуждать тему отмены крутин и
2049600	2058040	обработки ошибок, потому что там создание job вместо нас играет ключевую роль и поймем почему.
2058040	2065640	Итого, у нас крутин-билдеры создают новый job на основе родительского и из крутин-контекста,
2065640	2071960	а в верхнем уровне вся наша картина выглядит следующим образом. У нас сначала должен быть
2071960	2077280	крутин-скоп, на этом крутин-скопе у нас есть возможность создать с помощью крутин-билдеров
2077280	2084040	наши крутины. В лекции и вообще в практике мы будем часто использовать либо launch, либо async.
2084040	2090480	Дальше внутри этих крутин-билдеров у нас есть возможность работать со suspend функцией,
2090480	2095440	в рамках которой мы можем вызывать другие suspend функции. Тут уже начался такой
2095440	2101400	мир suspend функций, в котором мы можем выполнять всю нашу бизнес логику.
2101400	2112000	А крутин-функции могут вызывать другие части из библиотеки крутин, например,
2112000	2117600	крутин-скоп-билдеры, как крутин-скоп или vis-контекст, опять же их примеры мы посмотрим чуть
2117600	2123400	позже, но по факту они являются также suspend функциями, которые и можно вызывать только
2123400	2129320	внутри контекста других suspend функций. Так что в верхнем уровне, наверное, картина выглядит так.
2129320	2136720	И, наверное, с фундаментальной частью пока что на этом все. Дальше коснемся темы отмены,
2136720	2140560	а сейчас попробуем отвечать на вопросы, которые уже, наверное, скопились.
2140560	2153040	Первый вопрос. Часто ли сейчас используется RectJava? Давайте я отвечу так. Я, по-моему,
2153040	2158640	уже немного отвечал и раскрывал этот вопрос на предыдущей лекции. На мой взгляд, RectJava
2158640	2164800	все меньше и меньше используется на практике, где-то в бою в каких-то
2164800	2173880	продакшн-приложениях готовых. Почему? Потому что фреймворк крутин и фреймворк flow и stateflow,
2173880	2178480	которые мы сегодня немного рассмотрим, он практически полностью закрывает те возможности,
2178920	2185300	которые нам давал RectJava. В принципе, нет сейчас никакого смысла изучать целый отдельный фреймворк и
2185300	2191280	тащить огромный объем DexCount для того, чтобы решать те задачи, которые мы уже можем решать с помощью
2191280	2199760	крутин и flow. Так что мой ответ сейчас все реже и реже. И, наверное, такой совет всем начинающим
2199760	2205440	разработчикам все же подробно изучить именно тему крутин и flow, а в случае необходимости,
2205440	2212840	при хорошем погружении в тему flow вы сможете понять, как устроен RectJava, как второй, так и третий.
2212840	2219360	В общем, здесь проблем не будет. Но я бы сфокусировался все же на крутинах на текущий момент.
2219360	2224360	Как работает крутина под капотом, на каких трессах они выполняются? Все зависит от того, на каком
2224360	2228800	диспатчере и какой шедулер используется во время исполнения. Наверное, ключевая мысль,
2228800	2233920	возможно, которую я не очень хорошо донес в рамках первой части, есть потоки, есть крутины.
2234160	2240560	Крутины будут исполняться на каком-то потоке или на каком-то пулле потоков. Это зависит от диспатчера.
2240560	2248480	Они не блокируют поток, они только лишь позволяют эффективно использовать текущие потоки и давать им
2248480	2253960	возможность заниматься чем-то другим, пока наша крутина бездействует, она приостановлена.
2253960	2262760	Соответственно, вкратце, как работают крутины под капотом, я сегодня рассказывать не буду. Я
2262760	2270680	специально привел пару... Я, по-моему, привел в конце ролик от хорошего автора, который объясняет то,
2270680	2274800	как устроена крутина под капотом, во что они трансформируются, во что трансформируются
2274800	2281880	вообще с аспент-функцией, которые мы с вами написали. Там вся происходит магия с continuation,
2281880	2291560	там происходит вся магия с таким набором действий, где мы можем в любой момент, в точке
2291560	2298040	остановки приостановиться, запомнить то, в каком моменте мы остановились, закэшировать,
2298040	2303320	сохранить весь стэк функции и затем его прихранить, а после чего, как, знаете,
2303320	2307800	как какую-то дискету или как какое-то сохранение вытащить и возобновить именно в том месте,
2307800	2314080	где мы представились в прошлый раз. Эта вся концепция хорошо объясняется, по-моему,
2314080	2319560	в полторачасовом докладе, так что я решил, что в рамках текущей сегодняшней встречи объяснять
2319560	2325920	это особо не буду. Но ссылочку обязательно прикреплю. Вообще, в целом, есть набор хороших
2325920	2332240	роликов от Романа Елизарова, который является одним из авторов крутин. Он объяснял также
2332240	2337720	в своих докладах то, как устроена крутина под капотом и во что они трансформируются с помощью
2337720	2341640	компилятора. Точнее, во что трансформируется с аспент-функцией с помощью компилятора.
2341640	2349840	Так, что такое крутина? В рассказе лекции говорили вот крутина активна или нет,
2349840	2354400	а на слайде Job Lifecycle. Так что значит создать, запустить крутину? Это выполняемый код внутри
2354400	2363240	скопа? Да, то есть концептуально это то, что очень похоже, в общем, на поток. Это набор каких-то
2363240	2370680	вычислений, которые проводит текущий поток. То есть, вот мы строчка за строчкой что-то
2370680	2374840	выполняем, но особенность крутин в том, что вот на определенной строчке мы можем приостановить
2374840	2380520	свое выполнение и возобновить ее в какой-то определенный момент в будущем. Вот это и главная
2380520	2387320	особенность. А Job это такая абстракция над этой крутиной, то есть Job просто нам сигнализирует о
2387320	2394760	том, в каком статусе находится вот этот вот набор вычисляемых инструкций вот сейчас в рантайме.
2394760	2403920	Вот всего лишь так. И запустить крутину, это значит начать выполнять набор данных,
2403920	2408960	набор кода, который мы сами прописали у себя в программе. Аналогия очень похожа на поток,
2408960	2414800	только это скажем так под часть потока набор кода, который выполняется внутри определенного потока.
2414800	2422080	Так, тут есть вопросы конкретно по слайдам. Я боюсь, что я не буду сейчас прям возвращаться,
2422080	2426960	то там анимация и так далее мы довольно долго будем ждать. Пропущу вопросы, где мы прям явно
2426960	2433920	к какому-то слайду переходим. Дальше следующий вопрос. Ключ контекста типа класса извлекается?
2433920	2441000	Да, что типа того? То есть мы там, кстати, это прикольный подход, связанный с обращением к маппи,
2441000	2445960	к крутин-контексту. У нас есть возможность, в принципе, я вам рекомендую посмотреть на то,
2445960	2452040	как устроены интерфейсы крутин-контекст-элементов. Мы действительно по названию интерфейса сможем
2452040	2458200	типа название интерфейса использовать как ключ к маппи крутин-контексту. Мне кажется,
2458200	2464320	такой поход вообще довольно редко используется где-либо, я вот его видел только в библиотеке крутин.
2464320	2470760	Можно еще раз объяснить, пожалуйста, что мы складываем при создании крутин-контекста. Они
2470760	2477000	складываются как что? Как строки? У них же разный класс, нет? Еще раз, мы складываем... Смотрите,
2477000	2481800	в Kotlin есть возможность переопределить оператор плюсика, то есть переопределить
2481800	2487800	логику, которая дает вот этот вот плюсик. Соответственно, там логика следующая. У нас есть
2487800	2492920	крутин-контекст-элемент и есть другой крутин-контекст-элемент. И переопределена функция
2492920	2499600	оператор сложения двух крутин-контекст-элементов. Они вместе с собой формируют новый крутин-контекст
2499600	2505320	сам по себе. Грубо говоря, у нас есть маппы из одного элемента, мы ее складываем с маппой из другого
2505320	2511320	элемента и по итогу получаем маппу из двух элементов. Грубо говоря, то, что происходит при
2511320	2519840	сложении двух элементов, как у меня было на слайде. То есть, по сути, крутин-это не замена потока,
2519840	2523880	а удобный эффективный инструмент для работы с потоками. Что-то типа того. На мой взгляд,
2523880	2528880	так можно выразиться. Да, то есть у нас есть концепция потоков, которые никуда не уходят,
2528880	2533840	а есть крутины, которые живут в рамках определенных потоков, и вот эти крутины мы можем в любой момент
2533840	2539120	остановить. В любой момент, который мы явно задекларируем. Давайте это я явно сам буду
2539120	2543600	и подсвечивать в рамках лекции. То есть не в любой рандомный момент мы можем взять и приостановиться,
2543600	2551840	а скорее в определенных точках, которые мы явно сами задекларируем в коде. А так, да, есть потоки,
2551840	2556000	они никуда не делись, с ними также надо уметь работать, и поэтому у нас была целая лекция,
2556000	2561720	посвященная потокам. А дальше нужно понимать то, что есть крутины, которые дают нам очень много
2561800	2565680	преимуществ. То есть мы используем крутины как раз, чтобы упростить себе жизнь и дать
2565680	2571560	определенные гарантии по работе с отменной действий, с обработкой исключений, может быть,
2571560	2577080	с эффективным использованием тех же самых потоков. В общем, это такой удобный инструмент для нашей
2577080	2586560	поседневной работы. Так, вроде бы вопросы кончились, давайте пойдем дальше. Перейдем к теме отмены
2586560	2593760	крутин. Что тут? Я уже сказал ранее, что у крутин скопа есть возможность отменить все дочерние
2593760	2598720	крутины. Делается это довольно просто. Вот у нас есть интерфейс крутин скопа, на нем мы вызываем
2598720	2605960	функцию cancel. Также мы здесь можем передать причину cancellation exception, но обычно даже это
2605960	2611880	не передается, просто по дефолту вызывает функцию cancel. У самого интерфейса job также есть возможность
2611880	2619200	вызвать cancel. То есть это вот наверное два самых простых способа отменить нашу крутину. Давайте
2619200	2625080	посмотрим, как это выглядит на практике. Вот я создал свой крутин скоп и дальше на основе
2625080	2633160	этого крутин скопа создал три крутины. А дальше их всех вместе я отменяю с помощью нашего скопа.
2633160	2639040	На диаграмме, на самой схемке выглядит вот так, что есть крутин скоп, на его основе я создал три
2639040	2646200	крутины. Потом крутин скопу передал намерение все это дело отменить, он каскадно прошелся по всем
2646200	2651640	своим дочерним крутинам и попросил их сделать ровно то же самое. После чего они уже перешли в
2651640	2659280	состояние cancel. Получается, что отмена крутин скопа отменяет все дочерние крутины, это стоит
2659280	2669000	запомнить. Что дальше? Дальше у нас есть возможность отменять с помощью интерфейса job определенную
2669000	2675040	крутину. Здесь я сделал ровно то же самое, только теперь не на скопе отменяю все крутины, а только на
2675040	2681280	конкретно из них. И возвращаясь к схемке, я именно крутину два пытаюсь отменить. Она отменяется,
2681280	2687040	но никак не влияет на другие крутины, которые были созданы рядом с ней. Они также продолжают
2687040	2695000	работу как ни чем не бывало. Давайте рассмотрим схемку поглубже, по детальнее, если у нас уже
2695000	2702440	вот такая есть довольно большое дерево крутин. Я пытаюсь дочернюю крутину отменить. Она на самом
2702440	2708320	деле никак не влияет на свою родительскую крутину. Соответственно и самой родительской крутины все
2708320	2715240	будет хорошо, и с дочерними крутинами также будет все хорошо. Но особенность в том, что после отмены
2715240	2719920	крутины вот этот интерфейс job он уже не может быть использован для создания новых крутин. То есть
2719920	2729440	на его основе мы не можем создать новые крутины. Как могли бы без отмены изначальной. Повторюсь,
2729440	2735600	при отмене крутин у нас отменяются все дочерние крутины. Сам родитель может не отменяться,
2735600	2742160	если пришел ивент отмены от одного из его дочерних крутин. И после отмены job не может
2742160	2749640	быть использован для создания новых крутин. Что дальше? Попробуем рассмотреть уже какое-то
2749640	2756160	более-менее нормальный пример, где мы выполняем какую-то логику, а потом захотели в параллеле
2756160	2764800	где-то отменить нашу текущую крутину. Мы здесь создаем нашу крутину, где пытаемся в цикле пройтись
2764800	2771280	и напечатать какой-то текущий индекс после определенной задержки. Здесь я 10 раз пытаюсь в цикле
2771280	2777640	пройтись, делаюсь на 100 мс и печатаю индекс. А в основной крутине, в родительской крутине я
2777640	2786400	делаюсь на 320 мс. Даю возможность моей дочерни к крутине поработать 3-4 цикла и что-то напечатать
2786400	2792200	в консоль. А потом ее отменяю, причем еще и join-усь. Параллельно с помощью функции cancel on join она
2792200	2796680	прям явно и говорит то, что происходит внутри ее имплеметации. Мы первой строчкой cancel job,
2796680	2802280	а второй пытаемся зажониться к ней и дождаться, когда же она полностью завершит свою работу. После
2802280	2809280	чего печатаем строчку cancel. Здесь опять же никакой магии не произойдет. То есть мы сначала
2809280	2816520	напечатали 3 индекса, так как как раз и ждали в родительской крутине 320 мс ровно на 3 итерации,
2816520	2824240	и затем напечатали строчку cancel, а сама дочерняя крутина приостановила свою работу. Вообще вся
2824240	2832840	магия по отмене крутин происходит с помощью cancelation exception. У этого интерфейса, точнее вообще
2832840	2840040	у этого исключения есть специальные скажем флажочки внутри имплементации. То есть сам
2840040	2848240	фреймворк крутин знает про cancelation exception и по отдельному, ну знаете так, он явно понимает,
2848240	2854160	что это cancelation exception и выполняет определенную отдельную логику по работе с конкретно с ней.
2854160	2859960	Либо с его наследниками. Сознанно это для различия между отменой и ошибкой, то есть если мы получили
2859960	2864480	какую-то ошибку, кинули исключение, то скорее всего это исключение будет отлично от cancelation
2864480	2871040	exception и мы по-другому обработаем это исключение. Пройдем по другой ветке. Вот я как раз это имел
2871040	2876680	в виду, вот как раз привел пример из реализации крутин, где мы первые строчки проверяем на
2876680	2882600	instance cancelation exception, а потом уже, если понимаем, что это не cancelation exception, потом отдаем
2882600	2893160	обработчику в другую ветку. Вот по-другому работаем в общем с исключением. Что еще важно,
2893160	2903200	вот до этого в некоторых примерах, как как например delay, это стандартная функция из библиотеки
2903200	2910280	крутин, есть возможность поддержки отмены. Помните в лекции по многопоточности я рассказывал,
2910280	2916720	что можно поток приостановить на определенное время и если мы попытаемся завершить поток во
2916720	2923520	время той же функции slip, то мы кинем interrupted exception. Вот здесь происходит примерно то же
2923520	2929360	самое, то есть есть стандартный набор функций из крутин библиотеки и вот в каждой из этой
2929360	2937880	функции в момент саспенда у нас есть возможность кинуть cancelation exception. Вот, как-то так. Этим
2937880	2943440	можно пользоваться, покажу на примерах как именно. Но главная особенность, так же как и в потоках,
2943440	2951160	отмена должна быть кооперативной, то есть если у нас карутина выполняет довольно большую сложную
2951160	2958720	логику и у нее нету так называемых вот этих вот точек приостановок, то есть нет возможности
2958720	2964480	приостановить текущую карутину, она просто довольно долго выполняет что-то сложное. Вот здесь на слайде
2964480	2970560	привожу пример, что мы в цикле опять же делаем что-то сложное, вычисляем, печатаем какие-то строчки,
2970560	2977320	но нигде не приостанавливаем карутину. Так вот, в нашей родительской карутине или в принципе
2977320	2983240	вообще в какой-то другой карутине не будет возможности по нормальному нашу рабочую карутину
2983240	2991240	приостановить. То есть здесь мы по итогу дождемся выполнения всех всех итераций и увидим печать
2991240	2998240	всех наших индексов. Ровно то же самое происходит и с потоками, как помните, мы делали примерно то
2998240	3004520	же самое, приводили, например, ровно такой же участок кода, только связанный с потоками. Соответственно,
3004520	3013200	опять же должен быть какой-то механизм, позволяющий нам трекать, а хотят ли нас кто-то, есть ли потребитель
3013200	3019400	или какая-то сторонняя карутина, которая хочет нас приостановить. Это делается как раз таки с
3019400	3025560	помощью флажочков мы можем узнать, является ли карутина сейчас активна или нет. В случае, если
3025560	3033240	такого не является и нас кто-то уже явно попросил приостановиться и сработали внутреннее,
3033240	3039320	сработала внутренняя реализация по отмене карутины, то вот наш флажочек, означающий то, что карутина сейчас
3039320	3045640	в активной стадии или нет, будет явно об этом сигнализировать. Вот нас захотел кто-то приостановить,
3045640	3051640	наш флажочек перешел в статус false, из актив флажочек перешел статус false и мы можем, в данном случае,
3051640	3058680	очистить ресурсы и завершить всю работу в цикле. Есть более удобный, на мой взгляд, способ, такой
3058680	3064440	более декларативный что ли. Есть функция ensureActive, то есть она делает примерно то же самое, только у
3064440	3072560	себя под капотом проверяет статус этого флажочка и мы можем, и причем она еще явно выбросит
3072560	3079240	conciliation exception, если это не так и это нам позволяет не дробить логику на несколько ветвей типа if false,
3079240	3086800	а скорее явно хорошо дезакларировать, что у нас в момент, в определенный момент мы проверяем
3086800	3092080	действительно ли мы сейчас активны, если нет, полностью сворачиваем всю работу, завершаем ее и выходим
3092080	3098640	из цикла, выходим вообще из функции. Вот бывает, что мы используем ровно ее для вот такой цели,
3098640	3106800	быстро выйти из функции и завершить свою работу. Вот как раз-таки здесь я и привел в пример то,
3106800	3114240	как вообще этот интерфейс выглядит. У интерфейса job можно вызвать функцию ensureActive и мы там
3114240	3121080	проверяем статус флажочка и в случае, если этот флажочек дает false, мы кидаем conciliation exception.
3121080	3128440	Есть другой способ, это одна из suspend функций под названием yield, которая просит текущей
3128440	3138280	диспатчер перейти на новый цикл, ну короче, зашедулить какое-то новое вычисление, не выполнять
3138280	3143240	текущую курутину, а переключиться на что-то другое в рамках потока. Вот, и эта функция yield приходит
3143240	3148040	нам в стандартной библиотеке и соответственно она также имеет возможность кинуть conciliation exception,
3148040	3155640	если это уже, ну если нас кто-то до этого попросил полностью завершить работу и отменить текущую
3155640	3162760	курутину. В общем, главное, что стоит вынести отсюда, это то, что есть стандартный набор функций из
3162760	3169840	библиотеки крутин и практически у всех из них по дефолту есть вот такая возможность, ну вообще есть
3169840	3176040	поддержка conciliation exception и отмена крутин. Вот, мы можем ими пользоваться, если захотим, ну либо
3176040	3183080	явно сами проверять с помощью стейтов у job, который является абстракцией к текущей курутине.
3183080	3189640	Окей, что еще? Здесь мы рассмотрели то, как мы работаем с лаунчами, то есть с
3189640	3194040	курутинами, которые мы когда-то запустили и пошли дальше, а что делать со сингком,
3194040	3200520	который возвращает результат. Здесь, на самом деле, примерно то же самое, только есть особенности при
3200520	3205920	вызове await, да, так как await нам возвращает результат, соответственно не всегда мы получим то, что хотим,
3205920	3213200	в случае отмены. Вот, здесь я пытаюсь как раз в рамках моей крутины подождать и потом вернуть
3213200	3218320	результат в виде стренги async result, а в основной родительской крутини я пытаюсь заделается на
3218320	3225040	секунду, потом дождаться результата и отменить. Да, здесь, возможно, надо было с ручками поменять
3225040	3231160	местами. Да, вот я как раз это и сделал, забыл про слайд следующий. В общем, здесь я просто дожидаюсь
3231160	3237680	крутины и отменяю. Здесь в этом, на самом деле, не так много смысла. Я просто дождался, а потом ее
3237680	3242120	попросил отмениться, но она и так уже в завершенном состоянии, здесь ничего не произойдет. А в случае,
3242120	3247360	если я поменяю строчку местами, то есть сначала попрошу отмениться, а потом дождаться результата,
3247360	3253600	то я славлю job consolation exception, вот, потому что результата как такового у меня на руках нет.
3253600	3260040	По теме крутины, это все. Главное, что стоит вынести, что есть consolation exception,
3260040	3264640	он по отдельному обрабатывается внутри фармворка крутин, мы с ним можем, в принципе,
3264640	3273200	работать сами, мы можем даже наследовать свои exception от данного и как-то явно у себя в логике
3273200	3277360	уметь его обрабатывать. Я, если честно, особо таким никогда не занимался, но, в принципе,
3277360	3286240	у вас такая возможность есть, опять же, welcome, вдруг найдете ему применение. Что дальше? Дальше,
3286560	3292560	на мой взгляд, одна из самых сложных, особенно для первой лекции, где мы погружаемся в тему
3292560	3302280	крутин, вот, тема с отменой крутин, мне кажется, дается всегда тяжелее всего. Почему? На мой взгляд,
3302280	3309080	просто потому что сам API крутин и сам фреймворк, который у нас есть на руках, позволяет нам,
3309080	3315320	как разработчикам, слишком много всего и часть кода, которую мы можем в теории написать и
3315720	3321760	часто делаем так, не приводит к ожидаемому результату. Опять же, чуть позже на слайдах я попробую
3321760	3326760	привести примеры, почему так. И, возможно, из-за этого, из-за того, что мы, как разработчики,
3326760	3332240	можем написать много всего, которое, по нашему мнению, может или должно работать, не является,
3332240	3339320	если работать не так, как задумано нами, вот, и приводит к ошибкам, приводит к каким-то проблемам
3339320	3346560	на проде, в общем, приводит к какому-то полному непониманию у разработчиков, как же это вообще
3346560	3355720	вся тема работает и как ее грамотно обработать у себя в коде, обработку ошибок, имею ввиду. Что
3355720	3361440	тут важно знать? Непойманная ошибка в крутине отменяет как родители, так и у всех дочерних
3361440	3367280	элементов. Что это значит? Вот, возьмем наше дерево крутин, возьмем нашу дочернюю крутину,
3367280	3372480	которая кинула исключение, причем не consolation exception, а какой-то другой. Например, у нас реально
3372480	3380800	ошибка в коде, либо какой-нибудь checked exception мы не обработали у себя внутри, нормально. Что
3380800	3386240	происходит дальше? Это исключение доходит до родительской крутины. Родительская крутина,
3386240	3392440	в первую очередь, отменяет все остальные дочерние крутины, вот, свои, вот. Соответственно, тут она
3392440	3400200	отойдет до крутин 5 и крутин 7, отменит их и потом отменит сама себя. Дальше, если внутри нее мы уже
3400200	3407000	не смогли обработать никак это исключение, она прокинет это исключение дальше, выше, к своей
3407000	3413440	родительской крутине. Здесь произойдет ровно то же самое. И получается, что мы вот это исключение
3413440	3419800	прокинули в самый верх, до нашего корневого, до нашей корневой крутины. Ну и в принципе,
3419800	3425640	вообще до своего скопа так может быть. Возвращаясь к предыдущему слайду, как раз вот мы берем наш
3425640	3432680	throwable. Получается, что наш throwable не является наследником cancellation exception, и получается,
3432680	3439680	мы его пытаемся обработать как обычное исключение. И прокидываем выше через вот эту взаимосвязь
3439680	3444880	всех крутин между собой. То есть, так как у меня есть возможность в крутин-контексте получить
3444880	3452040	доступ к родительской крутине и к, через дочерней крутины, у меня есть возможность информацию об
3452040	3458680	исключении кинуть вверх до родителя. Вот это как раз таки есть structured concurrency, про которое
3458680	3465760	я говорил в самом начале. Вот получается, что мы, да, я тоже имплементацию привел вот на T-Fi
3465760	3473480	canceling. Мы как раз сначала пытаемся отменить всех наших детей, а потом пытаемся отменить уже себя.
3473480	3481760	Получается, что вот так вот мы дошли до самого верха, до родительской крутины и, в принципе,
3481760	3486400	до всего крутин-скопа. И если исключение дойдет до крутин-скопа, она его, соответственно,
3486400	3491400	полностью и отменит. И он будет отменен, и на основе него мы уже не сможем создавать новые крутины.
3491400	3500240	И все дочерние крутины также будут отменены. Это для нас не сказать, что прям классные новости,
3500240	3505440	почему. Ну, типа, если мы так шумудрились и не словили где-то какое-то исключение,
3505440	3510400	то оно действительно прям дойдет до самой верхушки, до корневых элементов и вообще,
3510400	3516280	в принципе, отменит все, что там было. Нам все же нужно как-то уметь с этим работать. Для этого у
3516280	3524040	нас есть Supervisor Job. Он частично решает нашу проблему, я покажу как, но им надо уметь
3524040	3531320	пользоваться, нужно понимать для чего и для каких целей он может быть применен. Это отдельный,
3531320	3540920	скажем так, подтип нашей Job с определенными свойствами подкапот. Если мы используем Supervisor Job,
3540920	3548360	у себя в коде, покажу как, ошибка или отмена дочерней крутины не приводит к отмене нашей
3548360	3555040	родительской крутины и не влияет на его наследников, я имею ввиду наследников нашего
3555040	3561480	родительского Job. Давайте посмотрим, как это выглядит. Представим, что у нас есть крутин Scope,
3561480	3571080	который был создан на основе Supervisor Job. И если мы попытаемся получить какую-то ошибку внутри
3571080	3577440	дочерней крутины, она передаст эту информацию дальше выше, внутри самого Scope или какой-то
3577440	3583760	родительской крутины. Но особенность того, что у нас есть Supervisor Job позволяет нам не отменять
3583760	3591280	наши другие, наши дочерние крутины, как в принципе и сам Croutine Scope. Но вот эта особенность,
3591280	3596080	мне кажется, про эту особенность редко кто пишет, редко кто про это говорит, но сам Exception
3596080	3602760	никто не обработал. То есть мы через взаимосвязь между Job, между нашими крутинами, передали
3602760	3608400	информацию о том, что Exception случился, и мы не дали возможность родительской крутини полностью
3608400	3616120	отмениться, но сама информация дальше через Job пропихивается наверх. Она распространяется выше
3616120	3623520	через родителя. И получается, что в теории, даже если мы где-то на начальной стадии использовали
3623520	3629560	Supervisor Job, который позволил нам не заканцелить все дочерние крутины внутри своего поддерева,
3629560	3636320	это не значит, что дальше эта информация будет обработана выше по стеку, ну или там по связи
3636320	3644320	между Job и не дойдет до обычного Job или обычного Croutine Scope, который увидит от Exception, его сильно
3644320	3653320	испугается и отменит все, что было ниже его по дереву, все его дочерние крутины. Важно получается
3653320	3660160	то, что Supervisor Job работает только в том случае, если он является прямым родителем для дочерних
3660160	3670120	крутин, и по-хорошему он должен являться что-то типа, скажем так, рутовым элементом, ключевым
3670120	3675360	элементом в момент создания крутин Scope. Вот я бы так выразился, потому что в других случаях,
3675360	3682600	скорее всего, пользы будет от него не так много. Давайте рассмотрим это на примере. Вот здесь я
3682600	3691000	пытаюсь создать мою крутину, ну вообще новую крутину, и передаю ей Supervisor Job в качестве
3691000	3698480	параметра, надеясь на то, что он сможет обработать исключение из моих дочерних крутин. Вот внутри,
3698480	3704680	дальше я пытаюсь создать две новых крутины. В первой также жду секунду и кидаю Exception,
3704680	3709680	который мы никак не отловили внутри крутины, а во втором случае, во второй крутине я жду две
3709680	3714080	секунды и пытаюсь напечатать строчку Will not be printed. Наверное, несложно догадаться,
3714080	3719280	что произойдет с этой крутиной. А в родительской крутине дальше я пытаюсь заджониться по
3719280	3727440	всему тому, что я создал с помощью Supervisor Job. Если я попытаюсь просто диаграммами, ну или там
3727440	3733520	так вот обвести участки кода и показать, что одна крутина относится к одному Job, другая крутина
3733520	3744680	ко второму интерфейсу Job, поймем, что две наши крутины соответствуют своим элементам Job. Здесь
3744680	3751600	вроде бы пока все понятно. Но что дальше? А дальше происходит то, что в одной из моих дочерних
3751600	3760200	крутин происходит ошибка, но обрабатывает эти две крутины только что созданной самим фреймворком Job.
3760200	3767720	Помните, я в самом начале рассказывал по теме с крутин-билдерами, что крутин-билдер и фреймворк
3767720	3776840	вообще создает сам свой Job и передает его как такой базовый элемент для всех дочерних крутин. Так вот,
3776840	3784400	то, что мы передали Supervisor Job, особо-то ни на что не влияет, потому что он будет родительским
3784400	3791360	элементом по отношению к Job, созданным внутри крутин-билдера. И получается, что сначала мой
3791360	3797840	обычный Job пытается обработать ошибку внутри дочерней крутины, он зафейлится благополучно,
3797840	3804240	потому что он не является Supervisor Job и не умеет игнорировать такие исключения. Соответственно,
3804240	3809880	он сам отменится и отменит все свои дочерние крутины. Вот этот ключевой момент, я надеюсь,
3809880	3816040	стал чуть более понятен. Если нет, постараюсь в конце лекции или в серии вопросов еще раз
3816040	3822280	раскрыть этот вопрос, раскрыть этот момент и объяснить получше. Но вот, грубо говоря,
3822280	3826440	у нас есть возможность передать Supervisor Job и сам компилятор даст нам такую возможность,
3826440	3833280	ничего не будет подсвечивать. И если просто почитать документацию, может сложиться впечатление,
3833280	3839640	что мы можем так сделать и передать Supervisor Job внутри крутин-билдера. Но по факту польза от
3839640	3845360	этого практически не будет. Все из-за того, что под капотом внутри крутин-билдера создается
3845360	3850760	свой собственный Instance Job, на основе которого и дальше могут создаваться другие дочерние крутины.
3850760	3861840	Вот. Этот момент, кстати, хорошо обсуждается в одном из докладов на Kotlin Conf. Опять же,
3861840	3867960	ссылочку я приведу в конце. Окей, как мы могли бы в теории использовать Supervisor Job? Но,
3867960	3873080	опять же, про спойлер особо так не рекомендую, просто пытаюсь объяснить механику работы Supervisor
3873080	3882160	Job. В данном примере я создаю его сам, явно, потом передаю его в одну крутину в лаунч и потом
3882160	3888160	явно передаю в другую крутину. Здесь получается уже кейс немножко другой. То есть у нас каждая
3888160	3893280	крутина также под капотом, точнее крутин-билдер, также под капотом создает Job, который может быть
3893280	3900920	зафейлен, но он дальше передаст эту информацию о проблеме в Supervisor Job, который не отменит все
3900920	3907240	другие дочерние крутины. Но особенность, точнее так, нюанс этого примера в том, что мы немного
3907240	3913400	ломаем саму систему structured concurrency. Почему? Потому что мы явно сами начинаем руками создавать
3913400	3922640	Job, Supervisor Job, что в моей практике лучше не делать, а лучше использовать либо обычные крутин-билдеры,
3922640	3928640	либо крутин-скоп функций, которые мы рассмотрим чуть позже, типа крутин-скопа. Кстати, да, даже я
3928640	3937120	его на слайде использую в самом начале. Я вызываю функцию suspend main и первой строчкой пишу крутин-скоп.
3937120	3944320	Вот именно про них речь. То есть нужно использовать тот готовый арсенал из функций, который уже есть в
3944320	3950600	стандартной библиотеке, а не городить самим, явно не создавать вот такие Job, чтобы потом их и явно
3950600	3959080	самим как-то стараться заменеджить. Потому что здесь мне приходится явно самому прописывать в самом
3959080	3967400	конце Job1.Join, Job2.Join, просто потому что теперь сам механизм работы крутины structured concurrency
3967400	3973280	не работает, мне приходится явно дожидаться самостоятельно завершения крутин. Но здесь
3973280	3977520	я пытался просто привести пример, что можно использовать Job для определенных кейсов, и он будет
3977520	3985840	работать, но лучше так не делать. А как нужно? Можно использовать крутин-скоп функцию. По аналогии
3985840	3993920	с крутин-скоп есть супервизор-скоп, в рамках которого мы можем запускать свои дочерние крутины.
3993920	4001400	Он позволяет вам выполнить то, что по факту и хотелось бы в самом начале, когда мы начали
4001400	4010920	разбирать тему, точнее не с отменой крутин, а с обработкой исключений в крутинах. Здесь мы увидим
4010920	4016480	как раз нашу строчку will be printed, просто потому что одна из крутин зафейлится, но супервизор-скоп
4016480	4021920	позволит нам проигнорировать это исключение конкретно в этом куске кода и дождаться выполнения
4021920	4031440	крутины, которая ждет 2 секунды и печатает строчку. Важно подсвечиваю, что наше исключение
4031440	4039240	не проглатывается нигде, про него мы не забываем, оно дальше передастся всем родительским крутином,
4039240	4045600	если мы поддерживаем принцип structure concurrency и сами явно Job не создаем, эта информация
4045600	4056000	передастся дальше и нужно, чтобы ее кто-то обработал. Повторюсь, исключения распространяются выше
4056000	4062880	по иерархии Job. Вот мы имеем scope, мы создаем дальше крутины, дальше из родительских крутин мы
4062880	4070440	создаем дочерние и вот информация о том, кто кому является родителем и так далее, как раз и
4070440	4077240	содержится внутри крутин контекста и внутри наших интерфейсов Job и исключения передаются ровно по
4077240	4086880	этой схеме, по этой взаимосвязи и если мы не смогли обработать исключение в какой-то из дочерних крутин,
4086880	4093720	оно обязательно передастся выше и это касается и обычного Job и супервизор Job, я надеюсь это я смог
4093720	4099780	донести, но да и особенно супервизор Job, что он имеет отличие работы с дочерними крутинами, как раз на
4099780	4105620	слайдах мы это увидели, что он не отменяет сходу все свои дочерние крутины. Но как же тогда ловить
4105620	4113780	исключения, вот если у нас была бы возможность так сделать? Во-первых, не допускать ситуации,
4113780	4119140	что мы что-то не отловили и дальше это исключение вверх пошло по иерархии. В первую очередь, конечно
4119140	4125780	же стараемся, как и в обычном коде, работать через try-catch, либо через run-catching, который нам вернет
4125780	4131000	результат, посмотрим как это выглядит, либо на кроняк используем крутин exception handler, но опять же
4131000	4135980	с ним есть нюансы. Cruitian exception handler это еще один элемент крутин контекста, напомню.
4135980	4142060	С try-catch как мы это можем сделать? Ну вот допустим у нас есть функция, которая кидает исключение и мы
4142060	4148060	в теории можем предположить, что она может кинуть исключение. Что это за примеры такие? Ну представим,
4148060	4152020	что мы работаем с каким-то внешним фреймворком, который мы не контролируем или с какой-то
4152020	4157420	библиотекой, которую мы не контролируем. Мы не знаем, может ли она в теории что-то вернуть плохое или
4157420	4164620	нет. По-хорошему нам бы стоило такой вызов обернуть в try-catch, не полагаться на то, что это исключение
4164620	4170620	потом кем-то там будет обработано, а явно на месте это сделать и обработать результат в случае получения
4170620	4179540	exception. Получается мы здесь делаем это через try. Пример, конечно же, очень такой синтетический и
4179540	4186220	особо пользовать него нет, но представим, что мы обращаемся к какой-то опишке или библиотеке и
4186220	4194820	дальше ловим какое-то исключение и как-то с ним работаем. Но особенность-то какая? Вот если,
4194820	4201580	в теории мы можем так сделать, я видел примеры кода, когда разработчики пытались обернуть в
4201580	4208300	try-catch сам вызов launch. Так вот это вообще ни к чему не приведет. Повторюсь, исключение,
4208300	4215620	которое было кинуто внутри лаунч функции, то есть внутри блока для лаунч-крутинбилдера,
4215620	4224220	оно не прокинется как обычное исключение и не отдастся просто вот в функцию main. А вот эта
4224220	4231220	информация о исключении передастся через интерфейсы job. Соответственно, пользы в try-catch
4231220	4237420	здесь нет никакой, мы никогда не отловим exception вот таким вот образом. Информация об исключении
4237420	4245820	передастся дальше в job, к routine-scope, который я вызвал в самой первой строчке. Вот, пожалуйста,
4245820	4250780	вот мне кажется здесь надо обратить внимание явно и может быть еще раз вернуться к этой теме,
4250780	4254940	ну понять как это работает. Может быть даже попрактиковаться самим, понаписать просто
4254940	4261380	примеры кода, покидать исключения и посмотреть в какой момент вы можете их поймать. Есть,
4261380	4268420	повторюсь, кроме try-catch и run-catching, его полезное свойство в том, что он возвращает result.
4268420	4274140	Довольно полезная API, это такая оберточка над результатом, которая может нам сказать о том,
4274140	4279340	успешен ли вызов или нет внутри функции. То есть мы через run-catching слоим exception,
4279340	4286300	получается вернем результат, точка там, фейлур. Выглядит это вот следующим образом. Мы вызываем
4286300	4293140	run-catching, возвращаем результат типа result и дальше можем с этим результатом работать. У нас даже
4293140	4299060	в Яндексе есть прям целые проекты, которые работают через этот result API и местами даже довольно
4299060	4305860	полезно, на мой взгляд, вот этот API довольно полезно и может быть применимо, но с ним тоже
4305860	4312180	есть нюансы. Какие? Например, мы через run-catching слоим вообще практически все exception, в том числе
4312180	4321500	и cancellation exception. Про это не забываем. То есть если у нас внутри нашей, точнее, внутри нашей
4321500	4328500	крутины и внутри какой-то suspend функции есть точка приостановки и из нее вытащился cancellation
4328500	4335860	exception, то мы сломим его как в try-catch, так и в run-catching. И нам по-хорошему бы этот cancellation
4335860	4342980	exception заново отправить дальше в другие крутины, либо явно это обработать и понять, что окей,
4342980	4348100	нас кто-то решил здесь приостановить, давайте попробуем очистить ресурсы. В общем, этот API
4348100	4355220	полезный, удобный, но также с ним нужно уметь работать. И вот как в завершение того, что мы можем
4355220	4361220	использовать сами в коде без каких-то собственных костылей, это крутин exception handler. Повторюсь,
4361220	4368180	это элемент крутин контекста, он является его частью. Он обрабатывает неперехваченные исключения,
4368180	4373660	но опять же не всегда и не везде. Его нужно в нужное место, точнее так, его нужно вставить в
4373660	4378380	определенные места и тогда он будет работать. Опять же, на мой взгляд, такой некий недостаток
4378380	4388380	всего API-крутин. API нам позволяет делать слишком много всего, что не приносит нам должного профита,
4388860	4396060	или должного результата. Здесь я пишу, что если не указан в крутин scope, исключение передается
4396060	4401220	on code exception handler. Это такой handler, который у нас есть в Android, в том числе и вообще в любой
4401220	4408700	GVM. В случае с Android, этот handler просто-напросто крашнет приложение. Возможно, вы знаете,
4408700	4416220	что если мы в каком-то из потоков нашего основного процесса не отловим исключения и наш поток
4416220	4421900	полностью крашнется, то и все приложение может быть крашнуто. Нам бы не хотелось такого допускать,
4421900	4429460	поэтому лучше все же для нашего какого-то корневого крутин scope указать крутин exception
4429460	4436580	handler, который обработает вот такие неперехваченные исключения. Создать его довольно просто,
4436580	4441420	также как любой другой объект. Создаем, передаем ему финальную имплементацию того,
4441420	4446300	что делать с тем или иным исключением. Здесь в данном случае я просто печатаю текущий exception
4446300	4453740	в консоли. Как можно его использовать? И это, наверное, такой способ, который я могу хотя бы
4453740	4460860	порекомендовать, хотя бы рекомендовать к рассмотрению. Мы создаем handler, дальше мы создаем scope. Это
4460860	4466540	может быть какой-то ваш основной app scope внутри приложения, либо scope, привязанный к определенному
4466540	4473340	экрану вью модели, неважно. Дальше этому scope мы передаем supervisor job, позволяющий не отменять
4473340	4479660	наш дочерник крутины в случае чего, а также сам handler, который обработает неперехваченные
4479660	4485140	исключения. И вот если мы в такой концепции будем жить, в такой парадигме, у нас появляется
4485140	4490500	возможность на основе scope создать наш дочерник крутины, в них даже кинуть какие-то исключения,
4490500	4495780	как я это делаю в примере, кидаю runtime exception, а во второй крутине просто печатаю результат.
4495780	4503900	И здесь я получу ожидаемый результат. Я никем не обработал исключения, и оно дошло до конца,
4503900	4511220	дошло до верхушки цепочки job, дошла до крутины exception handler, и я его напечатал у себя в консоли.
4511220	4518860	А потом во второй крутине, так как благодаря нашему supervisor job, я смог не отменить ее и
4518860	4526340	благополучно напечатать в консоли результат. И это чуть ли не единственный вариант использования,
4526340	4532540	на мой взгляд, где мы и нормально используем supervisor job и handler, крутин exception handler.
4532540	4537740	В других случаях, так проспольерю, когда вы начнете чуть-чуть практиковаться, вы поймете,
4537740	4543180	что мы чуть ли не в любой крутин builder можем передать как supervisor job, так и handler,
4543180	4550780	но пользы от них будет не так много. Лучше рассмотреть и начать использование как supervisor job,
4550780	4560420	так и handler внутри крутин scope. Это будет ваш самый ротовый элемент во всей цепочке.
4560420	4566780	Вы от него, от крутин scope начнете создавать крутины и его специальным образом настроите.
4566780	4575020	Вот и тогда и крутин exception handler и supervisor job будут иметь всю свою мощь, всю свою силу внутри него.
4575020	4584060	Вот повторюсь, действительно для первой лекции, где мы погружаемся в тему крутин, отмена крутин
4584060	4589540	и обработка ошибок это чуть ли не самые сложные вещи, на мой взгляд. Их сложно понять сходу,
4589540	4595540	и нужно чуть-чуть практиковаться, может быть даже посмотреть не один доклад с объяснением и
4595540	4601780	почитать хорошо документацию. Надеюсь хотя бы какую-то базу сегодня я смог рассказать и
4601780	4607700	стало чуточку понятнее. Вот это наверное моя главная задача на сегодня. Ну что еще есть? Есть
4607700	4615540	dispatcher. Мы не раз, ну и я не раз упоминал его. Он нужен для, он тоже является крутин контекст
4615540	4623380	элементов, он необходим для переключения потоков. Его особенность в том, что мы его, вот его-то мы
4623380	4629020	можем практически везде передавать, и он действительно будет влиять практически всегда на поведение
4629020	4635140	крутин. Мы его можем передавать при создании крутин или с помощью крутин скоп функций, как vis
4635140	4643060	context, покажу на примере. Там мы также можем передать dispatcher и явно сказать в текущей
4643060	4647820	сопрограмме, в текущей крутине на каком пуле потоков, либо на конкретном потоке нужно исполняться.
4647820	4656060	Вот в данном примере я создаю с помощью крутин скопа свою новую крутину. Там я пытаюсь тысячу раз
4656060	4663020	запустить новые крутины, причем в каждой крутине делаю возможность запуститься на dispatcher с IO. То
4663020	4669340	есть я и явно говорю вот крутина создайся пожалуйста и выполняйся в определенном пуле потоков,
4669340	4679500	которые соответствуют dispatcher с IO. Это просто такое явное обозначение, что крутина, у меня есть
4679500	4685180	пул потоков из dispatcher с IO, используй его. Здесь я использую те инструменты, которые мы с вами
4685180	4690180	рассматривали на предыдущей лекции, вытаскиваю ими текущего потока, ну и соответственно могу
4690180	4697380	увидеть, что там top worker 1, top worker 4, top worker 3 печатаются. То есть мы наши тысячи крутин
4697380	4705380	запустили на пуле потоков и дальше печатаем текущее имя потока внутри них. А крутин скоп функцию,
4705380	4711580	которую я упинул ранее, viscontext, это можно также использовать для переключения потоков. Очень
4711580	4718380	полезная функция используется не только для dispatchers, но часто вы можете увидеть ее использование
4718380	4725860	только вот в таких вот конкретных сценариях. Здесь я уже внутри текущей крутины сначала печатаю имя
4725860	4736140	потока, а потом с помощью viscontext меняю dispatcher на IO и печатаю уже поток, имя потока внутри новой
4736140	4743140	свежесозданной крутины. Здесь я получаю сначала first main, потому что я на основном потоке запустил
4743140	4751180	мою родительскую крутину, а потом свежесозданную я уже запускаю на dispatcher с IO и получаю default
4751180	4760940	dispatcher. Здесь, к слову, можно заметить, что у нас есть определенный пул потоков для IO,
4760940	4766380	для dispatchers default и они может быть даже местами будут переиспользоваться, такое тоже возможно.
4766380	4773180	Более того, вы можете указать свой dispatcher, создать его и передавать внутри функции, и это супер
4773180	4779500	полезное свойство, так нужно делать. Обычно мы абстрагируем передачу dispatchers с помощью
4779500	4785220	определенных интерфейсов для чего? Чтобы потом при тестировании их подменять. Обычно сами мы
4785220	4790980	никогда не вызываем статичные функции dispatcher с IO, dispatcher default или dispatcher с main, а передаем
4790980	4797700	свою абстракцию над ними свой какой-то интерфейс, предоставляющий нужные конкретные реализации
4797700	4805060	наших плов. Опять же, для того чтобы подменить в тестах и передать нужную реализацию дальше.
4805060	4812580	Как бы мы могли работать с main потоком? Помните, у нас одна из основных проблем была в том,
4812580	4818500	в предыдущей лекции, что мы сначала выполняем что-то в background в потоке, а потом хотим вернуться на
4818500	4825580	основной поток. Это делается, например, так. Мы вызываем функцию visContext и передаем dispatcher.main.
4825580	4830700	В Android реализации, то есть вот крутины, они могут использоваться не только в Android, но и на
4830700	4838140	обычных GVM. И вот dispatcher с main там будет разный. В случае с Android мы будем использовать
4838140	4845740	нативный Android поток, вот main thread, который мы разбирали на прошлой лекции. И здесь мы явно
4845740	4853580	декларируем, что нашу функцию showUser всегда надо вызывать на dispatcher с main, и все содержимое
4853580	4859740	внутри visContext будет выполнено на main потоке до тех пор, пока мы явно сами не переключим этот
4859740	4870900	dispatcher на другой. Но что стоит помнить? Практически я это еще сегодня не упоминал. Это работа
4870900	4876780	со разделяемыми ресурсами. Помните, опять же, в предыдущей лекции это была чуть ли не главная
4876780	4883060	проблема по работе с потоками. Нам нужно уметь правильно читать и записывать в разделяемый
4883060	4888700	ресурс. В случае с крутинами большинство проблем решено за нас. Вот если бы мы создавали какие-то
4889580	4901340	функции внутри suspend функции и работали с локальными переменами, то вся магия по видимости наших
4901340	4911660	элементов, по атомарности изменений решалась самим фреймворком крутин и компилятором. Но в случае
4911660	4917340	если мы работаем явно с каким-то разделяемым ресурсом вне текущих крутин, как на слайде,
4917340	4923900	где у меня просто где-то в стране объявлен каунтер, просто какой-то разделяемый ресурс, и дальше мы
4923900	4930060	внутри своих крутин, своих дочерних крутин пытаемся с этим разделяемым ресурсом начать
4930060	4935620	работать, то у нас могут возникнуть проблемы ровно такие же, как при работе с потоками. То есть,
4935620	4941260	представьте, что наши крутины работают на каком-то пыле потоков, соответственно, этих потоков может
4941260	4947740	быть не один, а несколько, и нам нужно уметь заменеджить состояние нашего разделяемого
4947740	4954500	ресурса между этими потоками. Здесь на слайде я что делаю. Есть функция Massive Run, где я вызываю
4954500	4960460	какой-то action довольно много раз, тысячу раз я создаю крутин, и внутри каждой крутины тысячу
4960460	4968060	раз прогоняю этот action, переданной мне в Massive Run. А в самом Massive Run я пытаюсь инкриментировать
4968060	4975220	мою переменную, мой разделяемый ресурс, текущий свойство Counter. То есть, это такой счетчик,
4975220	4983700	который я хочу заинкриментить кучу раз в тысяче крутин по тысяче раз. И если я такое вызову,
4983700	4991940	причем на DispatchersDefault, то есть на пыле потоков, состоящем из не одного потока, а из нескольких,
4991940	4998540	я получу не то число, которое ожидаю. Ровно по тем же причинам, что у меня нет возможности никак
4998540	5005460	синхронизировать данные. В текущем коде нет явных признаков о том, что я хочу синхронизировать
5005460	5010820	доступ к Counter. И мне нужно использовать те инструменты, которые мы с вами разбирали. Это
5010820	5018340	Atomiki из Util Concurrent. Это Thread Confirmant, это определение, что мы работу с разделяемым ресурсом
5018340	5026580	выделяем в отдельный один поток, в котором нам уже не нужно переживать о том, что там есть
5026580	5032700	проблемы с видимостью, есть проблемы с атомарностью изменений и так далее. Ну есть Karoutine Mutics,
5032700	5041620	который очень похож на то, что мы использовали на предыдущей лекции с локами. Давайте рассмотрим
5041620	5047980	его чуть отдельно. У нас есть возможность его создать, у нас есть возможность также вызвать его
5047980	5056220	и выполнить какую-то логику, как вот с синхроной секцией, также и тут. Мы у Mutics вызываем VizLog
5056220	5062340	и выполняем какую-то функцию внутри него, какую-то логику внутри него. Главная особенность,
5062340	5069700	главное отличие обычно вот этого Mutics из Karoutine по сравнению с Mutics или с локом из обычных
5069700	5077220	потоков в том, что он не является reentrant. Помните такое свойство лока, позволяющее нам заходить в ту
5077220	5081940	же критическую секцию под тем же локом, точнее так заходить в критическую секцию под тем же локом,
5081940	5088100	который мы уже и так держим. Вот здесь на примере у меня есть функция Do Some Operation,
5088100	5093540	которая под локом вызывает функцию Do Some Other Operation, которая также под этим же локом пытается
5093540	5099380	что-то сделать. Так вот в случае использования Mutics из Karoutine у нас так сделать не получится,
5099380	5105620	мы засаспендимся навсегда при вызове Do Some Other Operation, потому что у нас нет возможности
5106020	5111900	заново зайти в ту же критическую секцию под тем же локом. Тут это стоит учитывать,
5111900	5117220	ну и в принципе, наверное, не проектировать IP так, чтобы у вас была потребность несколько раз
5117220	5126060	обращаться к одному и тому же Mutics внутри критических секций. И здесь мы словим определенный
5126060	5134100	deadlock. Опять же, здесь, наверное, я бы приостановился, мы обсудили с вами довольно много важных тем,
5134100	5138700	как отмена Karoutine, так и работа с включениями. Дальше нам предстоит чуть-чуть ознакомиться с
5138700	5147980	поддержкой Jetpack и рассмотреть немножко Flow и Channels. Грубо говоря, там две части мы уже с
5147980	5153100	вами довольно хорошо обсудили, давайте попробуем поотвечать на вопросы. Они, наверное, уже скопились.
5153100	5160700	Что заставляет Karoutine запуститься после отработавшего delay? Она же не может запустить
5160700	5170100	сама себя. Да, как раз прошу вас посмотреть, даже, наверное, доклады по ссылке, которую я приложил,
5170100	5178340	вы увидите в конце лекции. Там это объясняется. Как раз-таки компилятор за нас придумает и
5178340	5187100	реализует такую схему, позволяющую с помощью обьекта класса continuation заново вызвать нас и
5187100	5195380	восстановить тот стэк методов, который мы до этого прихранили. Сейчас это, мне кажется, я довольно
5195380	5201900	долго буду объяснять всю концепцию, пожалуйста, лучше посмотрите целый доклад про это. Но действительно,
5201900	5207300	сама по себе Karoutine себя заново не запустит. Это точно так. То есть мы с помощью компилятора
5207300	5212620	создаем такую магию и с помощью обьекта класса continuation позволяем нам возобновить работу.
5212620	5217580	Как выглядит место в коде, где происходит приостановка и переход к другому коду,
5217580	5221580	например, к отрисовке UI? Используются какие-то возможности, которые уже были в лекции рассказаны?
5221580	5229100	Как выглядит место в коде, где происходит приостановка? Может быть тоже такой нюанс и
5229100	5237540	особенность работы Karoutine, что если вы смотрите на код, может быть, на GitHub, на GitLab или еще где-то,
5237540	5244460	на pull request, где нет нормальной подсветки синтаксиса, то просто посмотрев на функцию,
5244460	5250740	у вас практически не будет возможности понять, что мы там находимся с suspend, кроме того,
5250740	5258020	что вы посмотрите на сигнатуру метода и увидите suspend модификатор в названии. Либо какие-то
5258020	5264500	ключевые функции типа delay, yield или еще что-то, которые явно говорят о том, что мы сейчас находимся
5264500	5273180	внутри suspend функций. В наших средах разработки типа Android Studio, типа IntelliJ IDE, там есть явное
5273180	5279980	обозначение, что есть suspend функция, и она слева напротив строчки кода будет обозначать,
5279980	5287500	что у нас здесь Karoutine может быть приостановлено. Что это значит? Представим, что у нас есть большая
5287500	5294260	suspend функция, и внутри нее мы видим такой значочек, типа вот api.fetchstudent, и там напротив нее
5294260	5298860	есть значочек приостановки. Это не значит, что мы прям при вызове fetchstudent приостановимся,
5298860	5306820	это скорее говорит о том, что внутри fetchstudent мы дойдем до места, где Karoutine полностью остановится,
5306820	5315780	и дальше вот мы вот это состояние прихраним, где-то захешируем, где-то положим на полочку,
5315780	5323380	а потом возобновим работу ровно в том месте. И так вот по цепочке, по стеку вызовов мы вернем
5323380	5328340	результат обратно к нашему клиенту, клиентской части, там где мы вызываем fetchstudent у api.
5328340	5334420	Вот подход примерно такой. Вся магия с тем, что мы стек вызовов прихраниваем с помощью
5334420	5341300	continuation, возобновляем работу, и там вообще используется стейт-машина с флажочками,
5341300	5347420	со стейтами, и мы в коде поймем, на каком этапе мы приостановились, и как в стейт-машине перейдем
5347420	5353260	на нужный индекс, на нужный этап работы нашей функции. То есть как бы наша функция и каждая
5353260	5358740	suspend точка, она будет помечаться для стейт-машины, которую создаст сам компилятор. Опять же вот
5358740	5365300	эту механику, если вам это интересно, можете отдельно подробно изучить, я приложил ссылку на доклад.
5365300	5372860	Вот, к примеру, мы берем какие-либо данные из базы данных по типу activity. Так, что будет
5372860	5383140	лучше передавать контекст к рутине? Сейчас, секунду, вопрос довольно сложно сформулирован,
5383140	5393780	я не могу сходу понять, о чем речь. Что будет лучше передавать контекст? Вкратце, ладно,
5393780	5400500	там вопрос про то, как мы будем использовать крутины в связке с репозиториями, с view-моделями
5400500	5406060	и так далее. Чуть позже на слайдах я покажу пример того, как бы я хотел, например, видеть
5406060	5414980	обычный дефолтный репозиторий, view-модель и так далее в контексте работы с крутиными. Надеюсь,
5414980	5419940	я смогу ответить на ваши вопросы именно там. Если использовать In-Chore Active, то где проводить
5419940	5426460	очистку ресурсов? Здесь, наверное, предполагается, что нам очищать-то ничего особо не надо. То есть,
5426460	5436020	если In-Chore Active мы называем, то мы ожидаем, что мы кинем исключение в случае вызова этой функции и
5436020	5444900	одновременно отмены данной крутины. Может быть, также через strike edge словить, но я бы так,
5444900	5448900	наверное, даже не делал. Может быть, просто вызову тогда флажочек, проверил, что из In-Chore Active и
5448900	5456220	погнали дальше. In-Chore Active это скорее прокейс, когда мы хотим явно сразу оборвать всю работу,
5456220	5463580	и быстро дойти через исключение, пробросить исключение выше по стеку вызовов и закончить
5463580	5469780	работу тут. И не писается бесконечный флс. Может быть, даже для читаемости это будет лучше.
5469780	5477940	Если в текущем потоке запустить через лаунж две крутины подряд сложными вычислениями непрестанавливаемыми,
5477940	5483900	то они будут последовательно выполняться. It depends зависит от того, как крутины настроены,
5484020	5489420	но по факту да. Если вы сделаете так, что эти крутины будут выполняться на одном потоке,
5489420	5494100	то никакой магии не произойдет. У вас поток всегда будет загружен какими-то вычислениями в одной
5494100	5500940	крутине, и это может повлиять на работу крутины номер два. Если все же у вас шарится какой-то
5500940	5507420	пул потоков и есть возможность распараллелить работу в этих двух крутинах, то как будто они
5507420	5516140	могут жить и рядом вместе. Если на одном потоке, то как будто бы да. У вас работа одной крутины
5516140	5525780	может повлиять на другую. Если так, это я прочитал, супервизор Job имеет смысл использовать только при
5525780	5532420	малой вложенности крутин. Скорее его нужно, на мой взгляд, уже так по практике, его нужно декларировать
5532420	5539060	как можно выше, желательно в крутинскопе, как я это указал на слайде. В общем, там нужно понимать,
5539060	5544460	что вы делаете в других кейсах, и я их специально не приводил сейчас здесь на слайде, как будто бы
5544460	5550180	только усложнил понимание того, как устроен супервизор Job. На мой взгляд, это непростая штука,
5550180	5556780	и нужно еще отдельно про него почитать и с ним попрактиковаться. А вот супербазовый пример,
5556780	5564940	тот пример, в котором я уверен, я привел на слайде. Немножко запутался MainThread и UITread.
5564940	5572020	UITread – это ведь одно и то же, но в моем контексте точно да. Есть MainThread, его еще называют UITread
5572020	5580860	на Android. Те примеры, которые я запускаю и привожу на слайдах, это скорее какие-то консольные программы,
5580860	5589100	они не привязаны к какому-то Android, и тут я имею в виду, что есть вот MainThread обычный из консольной
5589100	5597340	программы. Но если бы я запускал те же самые крутины внутри MainThread, то это был бы UITread из Android.
5597340	5605580	Так, наверное, ответил на все, что мне пришло. Давайте продолжим и закончим с нашей темы по
5605580	5614300	крутинам. На сегодня быстренько пройдемся по Jetpack поддержке и по Flow. Думаю, и так сегодня
5614300	5621620	довольно много информации прозвучало. Как я уже говорил ранее, не один раз в Jetpack есть поддержка,
5621620	5628860	крутин. Это очень круто. Это нам как разработчикам позволяет не сильно париться насчет
5628860	5633700	реализации своих каких-то концепций, как, например, нам бы пришлось делать Executor
5633700	5640460	Service. Даже мы понимаем, что такое Executor Service, умеем им пользоваться, но чтобы сделать это грамотно,
5640460	5648780	правильно, в контексте Android и обработать всевозможные проблемы с отменой, с переворотом
5648780	5654940	экрана, с сменой всего контекста внутри Activity. В общем, как будто бы много кейсов, которые нам
5654940	5661460	стоит учитывать и хорошо организовать работу Executor Service, не так уж и просто. А тут за нас уже
5661460	5667900	продумали многие вещи, добавили поддержку ViewModels, добавили поддержку Lifecycle Scope. Давайте попробуем
5667900	5676540	рассмотреть, что у нас есть уже из коробки при использовании обычного Android X пакета и набора
5676540	5683020	библиотека TUDO. У нас есть возможность использовать ViewModel. Я вообще, наверное, у вас еще не было
5683020	5690100	лекций по архитектуре и так далее. Наверное, еще до конца обсуждали те возможности, которые
5690100	5697020	есть JPEG. Но так вот на скидку скажу, что ViewModel довольно прикольная штука, позволяет вам хранить
5697020	5702700	внутри нее много информации о текущем экране, вообще хранить сам стейт экрана и дает возможность
5702700	5711580	переживать жизненный цикл Activity либо фрагмента, который сейчас находится непосредственно на самом
5711580	5718620	экране. И вот у нас есть поддержка, у текущей ViewModel поддержка крутин, имею ввиду. И у каждой
5718620	5726540	ViewModel можно дернуть ViewModel Scope, который, мне кажется, по факту чуть ли не всю реализацию тут сейчас приведу
5726540	5735420	на слайде, делает примерно то же самое, что мы с вами писали чуть ранее. Сам создает крутин Scope явно,
5735420	5743820	привязывает его к текущему инстанцию ViewModel и к его жизненному циклу ViewModel. И у нас есть
5743820	5750500	возможность в рамках ViewModel Scope, а соответственно и в рамках жизни ViewModel запускать крутины. И из
5750500	5756180	коробки у нас уже появится возможность отмены крутин. В том случае, когда ViewModel полностью
5756180	5763500	уничтожится и вызовется метод onClear at у ViewModel, мы отменим текущий ViewModel Scope и отменим все
5763500	5769980	эти чернику-рутины, которые еще не завершили свою работу, что очень удобно. И только благодаря
5769980	5778020	этому уже можно пользоваться default ViewModel Scope из коробки из Android Jetpack. Как бы это могло
5778020	5784100	выглядеть на каком-то нашем примере? Вот я здесь создал Yandex ViewModel, передаю ему опишку, с которой
5784100	5792780	наша ViewModel работает. Дальше внутри своей функции, в данном случае это Face Student, я на ViewModel Scope
5792780	5799900	запускаю свою новую крутину и хожу в API. Причем дальше там могу вызвать UpdateState,
5799900	5805940	поработать со стейтом экрана, неважно. Но главная фишка, главная идея, это то, что я использую
5805940	5811540	ViewModel Scope для создания крутины. И в случае, если моя ViewModel, в данном случае Yandex ViewModel,
5811540	5819260	уничтожится и захочет очистить ресурсы, моя дочерняя крутина с походом в API отменится сама,
5819260	5827260	вот что прикольно. Мы можем сами создать свой Scope в случае, если мы, ну знаете, это привожу
5827260	5834540	пример для каких-то кастомных классов, похожих на ViewModel. У нас в Yandex такой используется,
5834540	5840900	поэтому приведу пример и такого варианта. Здесь мы явно сами ручками создаем крутин Scope,
5840900	5847100	передаем ему DispatchersMain, чтобы мы по дефолту запускали задачи на Main потоке. Здесь ничего
5847100	5853180	страшного в принципе нет. Благодаря тому, что наши крутины не блокируют поток, а приостанавливают
5853180	5859180	свое выполнение и дают возможность потоку выполнять что-то еще, не сильно аффектит Main
5859180	5865940	поток. И мы многие, особенно какие-то базовые операции типа там, обнови переменную, обработай
5865940	5870260	какое-то действие пользователя, обнови стейт, можем спокойно вызывать на Main потоке, это не
5870260	5874940	блокировка на несколько сотен миллисекунд в ожидании ответа от API. Такого не произойдет,
5874940	5885260	и благодаря этому мы в принципе часто можем безопасно работать с данными внутри Main потока
5885260	5891940	с использованием Dispatchers.main. И тут я еще передаю Supervisor Job явно для того, чтобы не отменять
5891940	5898780	какие-то свои дочерние крутины в случае, если мы получили ошибку в одной из них. В OnCreate я
5898780	5907540	запускаю задачку, что-то там пытаюсь получить, а в OnClear это как раз из библиотеки функция callback,
5907540	5913900	которая будет дергаться, когда наша viewmodel уничтожается. Я беру текущий скоп, беру крутин
5913900	5919260	контекст из него и отменяю все дочерние крутины. Вот примерно то же самое происходит и во view
5919260	5924380	модели, которая приходит из коробки из Android Jetpack. Можете даже в этом убедиться, сами
5924380	5931820	посмотрите. Но повторюсь, используйте пожалуйста viewmodel, хороший класс замена
5931820	5938380	всевозможным презентером из MVP-архитектуры, каким-то своим кастомным классом, который могут
5938380	5945380	пережить жизненный цикл всей активе телефрагмента. Мне кажется, довольно удобный класс, дающий много
5945380	5952820	преимуществ, плюс еще из коробки у нас есть возможность использовать крутины, что тоже классно.
5952820	5961020	Есть еще lifecycle scope, у самих классов типа Activity фрагмента они являются lifecycle
5961020	5968140	owner, у них можно вытащить на основе lifecycle owner lifecycle scope. Этот lifecycle scope я бы
5968140	5976940	использовал для каких-то UI-ных крутин. В случае, если мы хотим обработать какое-то действие на
5976940	5981820	экране и запланировать какую-то задачу на самом UI, мы можем использовать lifecycle scope для этого.
5981820	5988500	Либо, что мне кажется самый частый кейс, это использовать lifecycle scope для запуска и для
5988500	5998100	дальнейшей подписки на изменение стейта lifecycle и подписки на стейт экрана. Сейчас довольно
5998100	6003880	популярный подход в Android разработке, где во view модели у нас хранится стейт экрана в виде
6003880	6011960	state flow. Чуть позже мы посмотрим, как это может выглядеть. Наш UI в виде Activity или фрагмента только
6011960	6018320	в определенные нужные моменты, когда этот UI активен доступен, подписывается на этот стейт из
6018320	6024280	view модели. Выглядит это всегда примерно так, как я показал на слайде. То есть, мы вызываем специальную
6024280	6031340	функцию repeat life cycle started у самого lifecycle. Перед этим все это дело вызываем, так как это
6031340	6038100	suspend функция. Все это дело перед этим вызываем с помощью новой свежесозданной корутины на основе
6038100	6045740	lifecycle scope из Activity или фрагмента. А внутри корутины мы подписываемся на state flow, то есть на стейт
6045740	6051460	нашего экрана и пытаемся реагировать на все обновления текущего стейта и как-то по-другому
6051460	6058580	отрисовывать UI. Будь то compose UI, либо обычные вьюшки, там уже не важно, в принципе. Этот механизм
6058580	6067820	позволяет работать и с тем и с тем. Резюмируя, в общем, из Android Jetpack, view модели и работа с
6067820	6074340	lifecycle scope, это чуть ли не самый маскет, который у нас есть. Есть куча библиотек, бесконечное
6074340	6078540	количество библиотек на самом деле у сейчас у гугла. Мне кажется, что 15 последнее время только
6078540	6082940	использовал. Практически у каждой из них есть поддержка корутин и вообще, как бы корутин,
6082940	6088780	это чуть ли не номер один инструмент работы в такой много поточной среде с точки зрения гугла и
6088780	6095540	Android разработки. Так что, кажется, вы не ошибетесь, если начнете изучать подробно корутины и начнете
6095540	6103140	пользоваться библиотеками из Android Jetpack. В заключение, я понимаю, что уже довольно
6103140	6109380	долго и довольно долго с вами тут сидим и изучаем корутины. Немножко пробежимся по channels
6109380	6116620	and flow. Повторюсь, главная задача текущей лекции вам в основном рассказать про корутины. Channels
6116620	6122860	and flow, на мой взгляд, это не такая сложная тема и их можно узнать самостоятельно, просто чуть-чуть
6122860	6129460	попрактиковавшись. Важно просто понимать всю концепцию корутин, работы со spin функциями и
6129460	6137020	работа там с jobs, с их lifecycle и так далее. А остальное, это дело наживное, вы сможете сами спокойно
6137020	6143700	разобраться в этой теме, хорошо поняв предварительную фундаментальную часть в виде корутин. Но все же,
6143700	6147020	все равно в рамках лекции мы чуть-чуть пробежимся по основным интерфейсам, поймем, как с ними
6147020	6154500	работать. У нас есть интерфейс channels. Вообще channels, как каналы, это возможность в виде, знаете,
6154500	6161940	это очень похоже на какой-то blocking queue, где вы имеете потребителя и имеете производителя каких-то
6161940	6168900	элементов общаться между собой. То есть у вас есть канал передачи, есть канал получения. И channels
6168900	6176100	реализуют оба таких входа, выходных точек. То есть есть send channel, позволяющий вам отправлять
6176100	6182580	что-либо, и receive channel, позволяющий вам получать что-либо. Отдельно здесь останавливаться не буду,
6182580	6187460	здесь все более-менее понятно. Есть функция send, которая отправляет значения, есть функция receive,
6187460	6194500	которая эти значения получает. И заметьте, что они являются suspend. Вот я сказал, что channel очень
6194500	6201860	похож на blocking queue, но вот blocking queue, судя по своему названию, блокируется. То есть мы, если мы
6201860	6208100	являемся потребителем и пытаемся получить новый элемент, которого нет еще, мы заблокируемся. Если
6208100	6215580	же мы являемся поставщиком элементов и на текущий момент нету потребителя, готова обработать наш
6215580	6220980	новый элемент, мы также заблокируемся. Так вот, в случае с channel-ами все примерно то же самое,
6220980	6226420	только мы не блокируемся, а приостанавливаемся, как и везде. Вот поэтому эти функции являются suspend.
6226420	6233820	Пример использования давайте рассмотрим. Здесь я явно сам создаю channel, использую этот channel для
6233820	6239340	того, чтобы отправить сообщение через, ну с помощью одной крутины. Вот и здесь я явно пометил, что это
6239340	6245140	у меня sender. Вот я создал крутину, здесь я 5 раз что-то пытаюсь в цикле пройтись и напечатать какую-то
6245140	6250780	строчку. Вот потом этот channel закрываю. А есть еще receiver, это какая-то соседняя крутина, которая,
6250780	6258140	причем видите здесь можно использовать обычный for each loop, то есть пройтись по всем элементам
6258140	6265500	channel-а, как в цикле и обработать эти сообщения. Вот и это будет нашим receiver. К слову, вот даже
6265500	6271780	в нашем проекте в Yandex.P мы используем вообще концепцию channel-ов и умеем обрабатывать вот
6271780	6276780	такие сообщения примерно так же, как я показал на слайде. То есть у нас есть поставщик каких-то
6276780	6282980	событий, есть получатель. И вот получатель также в for each цикле ожидает новые значения и их потом
6282980	6289100	как-то обрабатывает. Ключевой момент в том, что channel является горячим источником данных. Что это
6289100	6297100	значит? Что этому каналу особо-то не важно, есть ли у него сейчас какие-то потребители и он будет
6297100	6303540	производить, ну в случае, если мы просто создаем его через функцию produce, как на слайде, он будет
6303540	6309580	производить элементы и ему там не особо-то и важно, есть ли сейчас какие-то потребители, он может
6309580	6315460	там закашировать какие-то значения, если мы буфер изначально передали. Ну и какие-то элементы может
6315460	6324020	потом пропустить, если буфер не позволяет хранить все. Вот. И это важно, почему я вообще начал
6324020	6329060	говорить про горячий источник данных в том, что flow, который мы рассмотрим буквально на следующем
6329060	6333540	слайде, является изначально вот сам интерфейс с холодным источником данных. Вот. Горячий
6333540	6338700	получается, что он активно генерирует данные, даже если никто не принимает эти данные и не слушает
6338700	6344540	сейчас в моменте. И при подписке на горячий источник данных мы начнем получать данные, вот только
6344540	6349620	те актуальные, которые у него есть сейчас на данный момент или те данные, которые он закашировал
6349620	6357020	у себя в буфере. Вот. А flow он генерирует, обычный flow, который мы сейчас посмотрим, как создавать,
6357020	6362780	он будет генерирует, генерирует элементы только при запросе. И каждый подписчик начнет получать
6362780	6369340	свою, свою копию, свою серию данных, начиная сначала, ну начиная сначала создание элементов
6369340	6375740	внутри flow. Вот. Получается, что flow у нас холодный источник данных. И сейчас я не говорю про
6375740	6381620	state flow и про shared flow, а именно про обычный интерфейс flow, в котором мы также можем работать.
6381620	6388220	Вот. Flow сам по себе можно как-то перевести как поток, но пожалуйста не путайте его с тредами,
6388220	6392780	которые мы рассмотрели раньше. Просто это какой-то некий поток значений или поток данных,
6392780	6398940	который мы можем обработать, цепочка событий. Вот. Эти данные там могут работать и вычисляться
6398940	6410540	синхронно. И мы начнем получать данные только в момент непосредственно самой подписки. Сам интерфейс flow,
6410540	6415660	он выглядит полностью, я его полностью уже указал на слайде, то есть у него есть только одна функция
6415660	6421300	collect. Этот flow можно самим реализовать, но мы посмотрим на его там такие основные реализации
6421300	6428420	чуть позже. Вот. В flow есть два интерфейса основных, это непосредственно сам flow и flow collector,
6428420	6434380	который он принимает в своей функции collect. Использовать сам flow можно вот таким образом.
6434380	6442620	Мы вызываем фабричную функцию flow, в которой начинаем производить элементы. В примере со
6442620	6450820	students flow я что делаю? Я пытаюсь три раза после дилея заимитить юзера с текущим индексом. Но вот
6450820	6457340	вся особенность в том, что если я просто вызову students flow, который вернет мне flow моих
6457340	6468540	юзеров, не приведет к самому вычислению данных юзеров. Они начнут вычисляться и начнут приходить
6468540	6476220	мне как подписчику только в момент подписки. Вот я suspend функции main вызываю функцию collect,
6476220	6482940	и это является триггером для сбора элементов, для начала сбора элементов, для начала их создания.
6483900	6491820	И дальше уже в collect я начинаю этих подписчиков этих студентов обрабатывать. Получается,
6491820	6497700	что здесь отличие от channel в том, что produce моментально начнет производить элементы,
6497700	6502500	как только я их создам, а во flow мне нужно подписаться. И только после этого,
6502500	6507860	то есть должен быть какой-то терминальный оператор, терминальная функция, которая затриггерит запуск
6507860	6516980	имита, запуск отправки и создание новых элементов. Сама структура flow указана на слайде,
6516980	6522740	то есть у нас сначала есть flow builder, это обычно вот такая фабричная функция типа flow, где мы
6522740	6531620	внутри экшена пытаемся по особому алгоритму, как мы захотим, начать имитить значения. Дальше
6531620	6536620	обычно идет серия операторов. Что это такое? Intermediate операторы, я их тут так назвал,
6536620	6543540	это промежуточные операторы, которые как-то видоизменяют наш поток, нашу цепочку данных.
6543540	6548580	Вот здесь я привел в пример, что есть on itch, on start, on completion, catch. Ну вот для примера,
6548580	6553660	on itch возьмет текущий элемент и может с ним что-то сделать по ходу дела, как сайд эффект какой-то.
6553660	6560140	В данном случае я просто печатаю текущее значение, которое пришло в on itch на экран. Есть
6560140	6566980	on start, on completion. Это такие стартовые кулбеки, когда я только подписываюсь на новый flow,
6566980	6574020	или когда этот flow полностью завершается. Catch позволяет мне, как подписчику на flow,
6574020	6579500	обработать определенные исключения и заметить новые значения. В общем, на самом деле вот этих
6579500	6585300	операторов целая тьма, мы часть из них сейчас рассмотрим дальше на слайдах. А есть терминальная
6585300	6591580	операция, терминал operator как collect. Их на самом деле несколько бывает, но вот collect,
6591580	6598140	наверное, основной. Только он затриггерит запуск нашего flow. Как это происходит? Вот представьте,
6598140	6604740	что есть flow builder, он вернул нам какой-то объект. Это просто напросто какой-то действительно объект,
6604740	6609820	который ничего сейчас не делает. Дальше мы к нему применяем серию intermediate операторов,
6609820	6614620	которые также ничего не делают, они просто декларируют, что произойдет с элементами,
6614620	6620780	когда они начнут приходить. А есть терминальный оператор, который всю эту движуху запускает.
6620780	6626420	Он вот как по цепочке, вот как здесь по коду, начинает снизу вверх идти и просить дать ему
6626420	6633220	элементы. То есть функция collect затриггерит тот flow, который был передан после функции catch,
6633220	6638100	отдай мне, пожалуйста, элементы. Тут в свою очередь пойдет в он completion, тот вон start,
6638100	6644220	тот вон itch и так дойдет до, все дело дойдет до flow builder, который начнет иметь значение. Вот
6644220	6647500	это вот такая вот особенность в том, что есть терминальный оператор, который начинает
6647500	6654540	триггерить получение элементов, работает как в нашем flow в крутинах, так и в том же rig.java.
6654540	6661180	Поэтому, вот возвращаясь к теме с rigs, если вы сначала хорошо поймете крутины, потом на их
6661180	6667340	основе поймете, как работает flow, вы довольно легко справитесь с концепцией rig.java, потому что там
6667340	6672940	происходит примерно то же самое, что я вам рассказываю здесь. Есть исключения, есть отличия,
6672940	6678940	но концепция очень похожа. Есть колонны источник данных, мы на него подписываемся, точнее мы к нему
6678940	6684060	прикручиваем набор операторов, а потом с помощью терминального оператора пытаемся затриггерить
6684060	6691580	все создание данных внутри flow. И вот когда вы пишете какие-то участки кода, вы спокойно можете
6691580	6696940	формировать ваш flow, накручивать на него кучу операторов, но не беспокоиться о том, что он,
6696940	6703740	то есть вы уже что-то начинаете создавать. Запуск непосредственно начнется только в момент коллекта
6703740	6711100	каким-то образом. Надеюсь, здесь немножко концепцию объяснил. Что насчет промежуточных операторов?
6711100	6717460	Назову парочку из них довольно интересных и полезных. Есть мэп, который, соответственно, из
6717460	6725260	одних значений конвертит во что-то другое, причем отличие мэп от его аналогов из той же rigs java в том,
6725260	6730180	что этот мэп является suspend, и мы можем даже здесь приостановиться, дождаться какого-то
6730180	6740780	результата и после чего возобновить работу. Что я здесь делаю? Я, во-первых, создаю набор
6740780	6749500	чисел от 1 до 5 и превращаю их во flow. То есть если я начну коллектить мой flow из чисел,
6749500	6757420	то я начну по итративно по цепочке получать значение от 1 до 5. Дальше я использую промежуточный
6757420	6765380	оператор в виде мэп и пытаюсь текущее значение возвести в квадрат. Дальше уже с помощью коллект,
6765380	6775220	с помощью терминальной функции я запускаю генерацию моих элементов, начиная сначала с цепочки
6775220	6781780	создания numbers flow и после того как я замапил значения возвелых квадрат, я их печатаю в
6781780	6790660	консоли и получаю заветные 1,4,9,16,25. Все числа возвелых квадратов. И вообще мэп супер полезная
6790660	6795660	штука, она используется практически везде для разных целей. Здесь привел такой банальный пример
6795660	6802460	с маппингом одного числа в другое. Есть фильтр, который будет отфильтровывать набор данных. В данном
6802460	6810260	случае я пытаюсь проверить четное число или нет. Если да, то пропускаю дальше. Если нет, то не беру
6810260	6820500	с собой. В общем я их пропускаю и не отдаю остальным промежуточным операторам после оператора фильтра
6820500	6826620	в данном случае. То есть вот у меня есть 1,2,3,4,5 числа, потом я применяю к нему промежуточный оператор
6826620	6833380	в виде фильтра и фильтрую только те числа, которые являются четными и получается на выходе из фильтра
6833380	6839620	у меня уже будет только 2,4. И остальные операторы, промежуточные операторы будут работать с 2,4,
6839620	6847180	а 1,3,5 даже не увидят. Вот это как бы особенность оператора фильтра. С take, мне кажется, можете
6847180	6852860	догадаться и сами, то есть мы ему передаем число и он будет брать только определенный набор чисел
6852860	6859420	по счету. Вот здесь я вызываю take, не передаю 3, соответственно я возьму только первые 3 числа.
6859420	6866380	Я говорю числа, первых 3 элемента в данном случае это числа. Это 1 до 5 и получается первые 3 числа
6866380	6876020	1,2,3. Есть еще zip, который связывает набор данных. Вот представьте, что у нас есть два flow. Первый
6876020	6884860	возвращает числа, второй возвращает символы. В данном случае abcd, e. И я пытаюсь zip как цепочку
6884860	6891660	на молнии, я пытаюсь склеить один flow с другим и у меня будут сформированы пары значений. Вот,
6891660	6900300	то есть я получается вызвал numbersflow.zip и передал ему второй flow и дальше он будет склеивать
6900300	6905820	значения из этих flow, он будет склеивать между собой и формировать новое значение. Вот обычно
6905820	6912100	такие операторы используются для того, чтобы склеить походы в разные опишки, которые возвращают
6912100	6918700	свои flow и мы пытаемся на основе нескольких опишек получить финальный результат. Вот здесь опять же
6918700	6925660	такой пример синтетический простой, но поверьте в продакшн коде zip тоже используется как раз для
6925660	6930580	склеивания данных из разных опишек, из разных сервисов, чтобы потом получить какой-то единый
6930580	6936940	результат. Вот. И таких примеров, таких операторов уйма, я не хочу тратить ваше время, чтобы просто
6936940	6942660	объяснять каждый из них по отдельности. Кажется проще просто пройти по документации и почитать
6942660	6947100	про них. И я хотел именно объяснить концепцию того, что вот есть промежуточные операторы,
6947100	6952900	которые как-то видоизменяют наши элементы по ходу дела. Что насчет shared flow, state flow? Вот они
6952980	6961780	как раз являются горячими источниками данных, то есть они в отличие от обычного flow позволяют
6961780	6969100	нам генерить какие-то элементы по ходу дела и не зависит от того, есть ли у них сейчас подписчик или
6969100	6975940	нет. Вот. Shared flow как видите наследуется от flow, у него есть reply cache, который как раз нужен для
6975940	6983140	хранения элементов внутри себя. У него есть возможность, точнее так, есть shared flow как
6983140	6991420	red-only коллекция по аналогии с листами и mutable листами в Kotlin. У него есть свой аналог в виде mutable
6991420	6997660	shared flow, который позволяет изменять значения внутри flow, то есть имитить новые значения внутри него.
6997660	7005900	Вот. Как это обычно работает? Представим, что есть flow как поток данных, мы с помощью mutable
7005900	7011660	shared flow можем этот поток данных видоизменять с помощью внешнего интерфейса, с помощью функции try
7011660	7019420	emit, ну или просто emit. Как мы это делаем? Вот я здесь создаю shared flow, делаю mutable shared flow и
7019420	7027380	создаю две крутины, которые начинают коллектить мой shared flow. Делаюсь на секунду, а после чего
7027380	7034460	имитчу message1 и message2 вот в мой flow. То есть есть внешний контракт у самого mutable shared flow,
7034460	7040380	если возможно, заимитить значения, я это делаю, а в других крутинах пытаюсь подписаться и получить
7040380	7047540	результаты. Так как я подписался заранее, грубо говоря, и делай в одну секунду мне точно хватит на
7047540	7053340	то, чтобы создать крутины и подписаться, я получу ровно то, что ожидается. В каждой из крутин я
7053340	7061060	получу и первое сообщение, и второе. В случае, если бы я создал эти крутины сильно позже, после того,
7061060	7067260	сколько я бы заимитил, тут уже зависит от того, как реализован shared flow и какие гарантии он дает по
7067260	7074580	поводу хранения данных, заимиченных ранее до того, как кто-то подписался на этот shared flow.
7074580	7083660	Что такое shared flow? Это его аналог, это расширение концепции shared flow, он работает аналогично,
7083660	7090460	только его особенность в том, что reply cache, вот этот внутренний cache по хранению данных,
7090460	7096380	которые никому еще не были переданы, оно связано к одному, то есть state flow хранит в себе всегда
7096380	7103180	только одно конкретное значение. Для нас это супер важно в контексте работы с тем же стейтом
7103180	7109700	экрана. Почему? Нам не хочется хранить стейты экрана, какие-то предыдущие стейты экрана, а нам
7109700	7114980	всегда хочется иметь актуальное, единственное значение, которое ему соответствует. И вот state
7114980	7120740	flow это идеальный кандидат, для этого покажу каким образом. Получается в state flow у нас
7120740	7125980	есть всегда в единый момент времени текущее значение, его можно вытащить через value,
7125980	7134980	а есть в контракте mutable state flow возможность, причем атомарно, изменить текущее значение
7134980	7141180	внутри state flow. Это как раз делается примерно через те же концепции compare and set, которые я
7141180	7148780	объяснял на предыдущей лекции по многопоточности. Примерно та же концепция, как в атомиках. И функции
7148780	7154220	примерно также называются compare and set, update and get, в общем, очень похоже. Давайте покажу,
7154220	7159980	как это выглядит. Вот я создаю mutable state flow, опять же в какой-то курантине я на этот state
7159980	7166300	подписываюсь, дальше после задержки я во-первых, а какая еще особенность, я забыл про это сказать,
7166300	7171940	для state flow нужен initial value, то есть начальное значение. Мы его обязательно должны передать,
7171940	7178380	в данном случае я просто передаю буквку A. Дальше я в курантине пытаюсь подписаться на этот
7178380	7187260	state, печатаю значение, которое из этого state могут прийти, и после дилея я пытаюсь из текущего
7187260	7195420	стейта взять значение и его переназначить на буквку B. И это поможет, это будет работать,
7195420	7202780	я реально в state flow получу другое значение. И дальше после дилея я пытаюсь подписаться на этот
7202780	7211980	стейт еще раз и получу ровно буквку B, которую изменил ранее. Что тут важно? Во-первых, именно
7211980	7218940	state.value я бы так особо не делал. Почему? Хочется, чтобы вы явно создавали проблему работы с
7218940	7225940	разделяемым ресурсом, и что явно обращаться к переменной просто вот так и менять у нее значение
7225940	7232580	не стоит. Это можно делать только если вы явно знаете, что сейчас находитесь в usl, в main потоке,
7232580	7238060	в одном единственном потоке, и безопасно менять значение вот так вот на ходу. Что я вам предлагаю?
7238060	7244460	Работать примерно по такой концепции. Вот у вас есть view-модель. Туда вы передаете какие-то
7244460	7250220	репозиторы, интеракторы, use-кейсы, не важно что, это те классы, которые отвечают либо за работу с
7250220	7257820	датаслоем, с каким-то данными, либо за работу в domain-слое, то есть вашу бизнес-логику непосредственно.
7257820	7266940	Дальше есть UI-state, которая отвечает за state-экрана. Это может быть описание того, каких состояний
7267020	7272340	экран находится, какие кнопки нужно показать, какие скрыть, как реагировать на нажатие
7272340	7277340	пользователя, какую анимацию запустить, и так далее. В общем, этот UI-state должен описывать то, как
7277340	7284620	выглядит ваш экран. И обычно это происходит так, что вы в mutable-state-flow храните, причем с нижним
7284620	7293740	подчеркиванием для чего, чтобы явно разделить интерфейсы read-only-flow и mutable-flow. В общем,
7293740	7300580	вы в mutable-state-flow храните state-вашего экрана, а внутри функции, типа вот как у меня onCreate,
7300580	7307180	вы получаете определенные данные, а потом автомарно, например, через функцию update,
7307180	7313220	которая есть в mutable-state-flow, вы обновляете ваш state-экран. И это происходит, повторюсь,
7313220	7321100	автомарно и безопасно для работы в многопоточной среде. Вот такой концепции я бы ожидал от вас в
7321180	7330340	ваших работах и в ваших проектах. То есть есть state-flow, который олицетворяет вообще ваш state-экран,
7330340	7336580	и вы его автомарно меняете с помощью функции update в разных точках, либо вообще в определенном
7336580	7344060	каком-то месте, где, может быть, у вас есть, не знаю, switch или van по всем состояниям экрана или
7344060	7349620	там бизнес-логики, и вы явно говорите, что только вот в этой функции вы можете менять state-экрана
7349620	7358620	через функцию update в state-flow. В общем, вот что-то такое я бы в первую очередь начал делать в
7358620	7366540	проектах, так использовать state-flow. В общем, наверное, ключевая мысль. Повторюсь, здесь явно вынес
7366540	7373660	надельный слайд. Вот обновлять state стоит вот так. Не нужно обращаться к переменной точке value у
7373660	7382780	state-flow и что-то у нее менять, потому что тем самым вы можете для себя же в будущем поломать логику
7382780	7388980	работы, если вы из того не сего начнете работать со state в нескольких потоках. Лучше явно сразу
7388980	7399020	обезопаситься и работать автомарно со значениями внутри него. И напоследок я приведу пример того,
7399020	7405380	как у нас работают некоторые репезитории в проектах. В случае, если мы хотим, чтобы репезитории
7405380	7410900	работали по такой концепции, что в in-memory кэше, например, они хранили данные, и эти данные могли
7410900	7416380	меняться только автомарно, вот мы обычно делаем примерно следующее. То же самое, как в view-модели.
7416380	7426060	У нас есть state-flow, который хранит данные, и мы через него обновляем само состояние внутри. А
7426060	7431620	есть flow, который вытащен наружу для чтения. Все наши подписчики наших репезиторий будут
7431620	7436740	подписываться на state-flow и получать актуальное значение оттуда. И причем давайте, наверное,
7436740	7442140	еще ни разу не объяснял, и вот как раз завершающая мысль будет, почему есть такое разделение на
7442140	7447500	mutable state-flow и на обычный state-flow. Mutable state-flow нужен только для внутреннего использования
7447500	7455420	внутри класса, и он позволяет видоизменять на state-flow. А наружу мы вытаскиваем интерфейс
7455420	7462500	state-flow, не позволяющий нам никак влиять на state-flow и менять значение внутри него. Благодаря
7462500	7469660	этому у нас есть возможность вытащить наружу только red-only вариант. И на этом на самом деле
7469660	7475340	сегодня все. Я, мне кажется, прошелся по основным концепциям, которые, на мой взгляд, важны,
7475340	7484260	которые вам стоит использовать у себя в коде. Давайте еще раз напомню, какие темы мы с вами
7484260	7489580	обсудили. Мы узнали, что такое крутина, хотя бы, надеюсь, на базовом уровне. Мы узнали, что такое
7489580	7499020	крутин-билдеры, узнали, как работать с estate наших крутин, немножко окунулись в тему отмены крутин,
7499020	7506940	работать с исключениями и немножко познакомились с state-flow и с shared-flow. Надеюсь, сегодня было
7506940	7513740	довольно полезно хотя бы для такой вводной встречки. На что стоит посмотреть. Каждый год
7513740	7520620	рекомендую примерно одно и то же. Здесь немножко поменял ссылки, мне кажется. В общем, на самом деле
7520620	7526660	можете приходить ко мне еще в личку, порекомендую еще такой же большой список. Здесь основное,
7526660	7532740	что точно стоит прочитать и узнать. Официальный гайд по крутинам, пройдитесь, пожалуйста, там довольно
7532740	7539620	много ключевой информации изложено. Каждый раз привожу ссылку Scott Linkon, где объясняю эту
7539620	7544660	концепцию, работа с исключениями. Там как раз один из примеров, которые я указывал на слайде.
7544660	7551180	Всегда топлю за статьи Романа Лизарова, прочитал, мне кажется, все его статьи на медиуме. Вот тоже
7551180	7560700	прошу вас глянуть. Как раз это один из основных авторов крутин. Особенно в начале работы над
7560700	7567020	крутинами и проектированием крутин в 18-19 годах он очень много писал статей на медиуме и объяснял
7567020	7573140	причины того, почему крутина работает так, как они сейчас устроены и что служило доводом для
7573140	7577060	этого. Плюс объясняет некоторые концепции, как, например, работа с разделяемыми ресурсами,
7577060	7582460	объясняет, что такое как раз таки холодный поток и горячий поток, ну и много всего другого
7582460	7588820	полезного, так что прошу посмотрите. Вот. А насчет того, как устроены крутины, есть много докладов.
7588820	7593980	От того же Романа Лизарова несколько докладов, причем на разных конференциях. Есть вот Мартсен
7593980	7599660	Маскала, который автор нескольких книг про котлин, в том числе по крутины, и вот в ролике,
7599660	7604380	который ссылку, которые прикладываю здесь, он объясняет то, как крутина устроена под
7604380	7610060	капотом и во что превращаются наши suspend функции после работы компилятора. Мне кажется, как раз этот
7610060	7616980	доклад сможет вам помочь в освоении крутин и в понимании того, как крутины устроены под капотом.
7616980	7626060	Вот. На этом все. Давайте попробуем ответить на вопросы, на последнюю часть, и сегодня закончим.
7626060	7634860	Можно ли вручную задать размер пул потоков для диспатчера? Да. Вы можете передать свой
7634860	7640900	кастомный диспатчер и сформировать его так, как хотите. Можете создать пул потоков из одного
7640900	7646780	потока всего, то есть сделать его таким однопоточным и использовать для своих нужд, например,
7646780	7653500	для упрощенной работы с многопоточным кодом со со разделяемым ресурсом. Можете указать даже
7653500	7658620	пул потоков из тех же экзекьюторов, почему нет? Ну, тех же пул потоков, которые используются в
7658620	7666620	экзекьюторах у вас с другой частью кода. Подписка в UI на Stateflow из VM выглядит избыточно, особенно если
7666620	7674900	стейтов много. Есть ли смысл в Core модуль выносить логику подписки? Не уверен, что это выглядит
7674900	7681700	избыточно. Есть ли смысл в Core модуль выносить логику подписки? Мне кажется, сложно мне ответить
7681700	7686380	на такой вопрос, потому что я не до конца его понимаю, что мы хотим вынести в Core модуль. Ну,
7686380	7691740	я бы сказал так. Для начала точно стоит отталкиваться от концепции, что у нас есть
7691740	7698420	view модель, которая хранит какой-то стейт, а в UI мы не храним сами по себе никакой стейт,
7698420	7703580	мы только лишь подписываемся на что-то, что имеет жизненный цикл больше, чем у вьюшки,
7703580	7709780	у нашего активити, у нашего фрагмента или там у каких-то компус-функций, и мы получаем данные
7709780	7715420	из той же view модели, точнее подписываемся на эти данные тогда, когда нам удобно, когда мы можем
7715420	7720580	что-то отрисовать и реагируем на изменения. Вот эту концепцию я бы точно использовал практически
7720580	7726700	везде, на всех экранах, и она уже доказала свою состоятельность и может быть по праву
7726700	7737060	использована практически везде. Вопрос стоит, нужно ли использовать крутины? Так, при наблюдении
7737060	7743500	за flow или live data можно еще пару предложений об этом. Тоже не совсем понял вопрос, но услышал
7743500	7750980	ключевое слово live data. На мой взгляд, ее особо не стоит использовать уже. Это избыточный фреймворк,
7750980	7756380	который вам по факту-то не нужен. Я бы все же рекомендовал везде использовать flow и обычные
7756380	7763580	крутины и live data практически нигде не использовать. Мне кажется, потом будет вам сложнее от нее уйти,
7763580	7771620	в случае, если будете по-прежнему ее использовать. На мой взгляд, это история временная и скоро live
7771620	7778340	data практически не будет. Я не вижу предпосылок, чтобы она имела популярность и смогла закрыть
7778340	7784060	какие-то определенные кейсы из state flow или из обычного flow. Можешь привести примеры
7784060	7791420	использования Channel именно в Android? К сожалению, я думал о том, чтобы показать пример того,
7791420	7797660	как у нас в проекте используется Channel. Давайте просто на словах объясним. У нас используется
7797660	7806420	Channel. Мы его используем для отправки... Давайте так. Есть концепция MVI. Это один из таких
7806420	7811780	архитектурных паттернов для presentation слоя. Он может быть по-разному использован. Есть библиотека
7811780	7819740	Orbit. Можете прогуглить, что это такое. Там есть механизм отправки интентов. У нас в проекте
7819740	7826460	аналогично используется отправка интентов. Мы отправляем интенты путем сэнда в Channel событий
7826460	7833780	на этот интент, на обработку какого-либо действия. А дальше наш обработчик и обрабатывает все интенты
7833780	7842700	и как-то их менеджит у себя внутри. Там мы как раз используем концепцию Channel. Все extension
7842700	7852740	коллекциям будут работать с Flow. Что ни вопрос, я пока не очень понимаю, как на них отвечать. Все
7852740	7860220	extension с коллекциями будут работать с Flow. Смотрите, если имеется в виду, что я создал набор чисел и
7860220	7870700	потом их превратил в Flow, вообще, можно практически любую коллекцию завернуть во Flow и начать имитить
7870700	7875700	значения оттуда. Наверное, да. То есть вы можете даже сами вручную такое сделать, создать свой
7875700	7881580	factory method Flow и начать имитить значения оттуда, просто притерировавшись по коллекции. Почему нет?
7881580	7889020	Зачем повторно подписываться на Slateflow, разве данные не должны изменяться динамически? Слайд
7889020	7894020	139. Так, а я на каком сейчас слайде? Давайте, ладно, тут всего пару слайдов, я дойду до конца.
7894020	7903720	Дело в том, что здесь уже создана другая крутина, то есть я в двух крутинах подписываюсь на одно и
7903720	7908460	тоже. Просто привожу пример, что подписчиков может быть несколько и каждый из подписчиков будет
7908460	7915740	получать свои значения. То есть я в каждой крутине получу значение актуальное. Как-то так.
7915740	7928140	Почему немутабельный UIStateSharedFlow, а не StateFlow? Так, опять же, наверное, это в контексте какого-то
7928140	7932420	слайда, пожалуйста, если прям интересно, можете написать мне отдельно с указанием слайда,
7932420	7938060	я постараюсь ответить. И давайте последний вопрос, вижу он как раз мне пришел, и на этом
7938060	7943220	закончим. А почему для public StateFlow не использовать Getter Value? На слайде было явное создание через
7943220	7949740	присвоение. Не, вообще, на самом деле, это можно по-разному реализовать эту концепцию. Главная идея
7949740	7957260	того, что мы скрываем интерфейс, который видоизменяет наш StateFlow, и наружу выставляем
7957260	7963380	только Redon-ли часть. Это можно сделать реально по-разному. Можно через Getter и закрыть приватную
7963380	7971700	Setter. Можно сделать, как я указал, мы используем приватный полис с mutable StateFlow, а наружу вытаскиваем
7971700	7977100	публично только Redon-ли часть. В общем, я здесь не утверждаю, что это единственный верный путь,
7977100	7981900	то как я указал на слайде, скорее хотел передать главную идею того, что мы делаем. Мы не отдаем
7981900	7987100	подписчикам возможность видоизменять на StateFlow, а делаем это только внутри, то есть мы именно
7987100	7995060	скрываем внутреннюю реализацию. Наверное, на этом все. Довольно много вопросов было, я надеюсь,
7995060	8001700	на большинство из них ответил и, в принципе, сегодня было полезно. По остальным вопросам,
8001700	8008460	прошу, можете писать мне в личку, в телеграмме, постараюсь ответить, как будет время. А на сегодня
8008460	8011580	все. Всем спасибо за внимание и до новых встреч.
8047100	8049100	С вами был Игорь Негода.
8077100	8079100	С вами был Игорь Негода.
