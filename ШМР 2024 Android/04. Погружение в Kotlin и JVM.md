Конспект лекции школы мобильной разработки Яндекса, направление Android, 2024 год

Лектор – Александр Вайцеховский, руководитель группы Android разработки Яндекс Музыки

# `Kotlin`
* Мультипарадигменный
* Статически типизированный
* Кроссплатформенный
* Общего назначения

Был разработан как лучшая версия и замена `Java`, для комплияции `bytecode` и для исполнения на `виртуальных машинах`

Но со временем это изменилось и котлин теперь компилируется не только в байткод, но и, например, в `Javascript` для web-разработки, нативный код

Байткод попадает в `VM`, чаще всего в `JVM`, и он уже запускается на различных настоящих машинах (на телефонах, компьютерах, ноутбках), а точнее на разных операционных системах

# Содержание
Ответим на такие вопросы:
* Как собирается приложение?
* Как исполняется приложение?
* Какие возможности доступны в языке и... почему?

Порядок лекции:
1. [`Сборка приложения`](#1-сборка-android-приложения) (как мы его собираем, где исполняем, кто его собирает)

   1.1 [В сборке участвуют три компилятора](#11-в-сборке-участвуют-три-компилятора)

   1.2 [Установка и запуск: AOT и JIT компиляции](#12-установка-и-запуск-aot-и-jit-компиляции)

2. [`Виртуальные машины`](#2-виртуальные-машины)
    
    2.1 [JVM – Java Virtual Machine](#21-jvm--java-virtual-machine)
    
    2.2 [Какая идея стояла за виртуальной машиной](#22-какая-идея-стояла-за-виртуальной-машиной)
    
    2.3 [Dalvik VM (Android 4.4-)](#23-dalvik-vm-andriod-44-)
    
    2.4 [ART (Android 5.0)](#24-art-android-50)
   
    2.5 [ART (Android 7.0)](#25-art-android-70)
   
    2.6 [ART (Android 9.0)](#26-art-android-90)
    
    2.7 [Цикл работы Android Runtime](#27-цикл-работы-android-runtime)
   
    2.8 [Виртуальная машина](#28-виртуальная-машина)
    
    2.9 [Android OS](#29-android-os)
   
    2.10 [App Process подробнее: Java Memory Model](#210-app-process-подробнее-java-memory-model)

3.  [`Компилятор и плагины`](#3-kotlin-compiler)

    3.1 [Kotlin K2 Compiler](#31-kotlin-k2-compiler)

    3.2 [Kotlin K2 Compiler Plugins](#32-kotlin-k2-compiler-plugins)

4.  [`Kotlin Features`](#4-kotlin-features) (Зная всю информацию выше, посмотрим на фичи языка котлин. Так будет понятнее, зачем они нужны и где действительно помогают)

    4.1 [Extension Functions](#41-extension-functions)

    4.2 [Scope Functions](#42-scope-functions)

    4.3 [Functional Types](#43-functional-types)

    4.4 [Sealed Classes](#44-sealed-classes)

    4.5 [Null safety](#45-null-safety)

    4.6 [Special Types](#46-special-types)

    4.7 [Mutable-immutable Collections](#47-mutable--immutable-collections)
    
    4.8 [Generics](#48-generics)

## `1` Сборка Android приложения
![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image.png)
1. Есть исходники формата `.kt` и `.java`
2. Из них можем получить байткод формата `.class`
3. Можем добавить различные библиотеки `.jar`
4. Получаем `.dex` файл
5. К нему можем добавить `resources`
6. И всё это упаковывается в `.apk` файл (на самом деле это просто zip-архив. Можно переименовать, разархивировать и посмотреть из чего он состоит)

Всё, что присходит на этапе 1-5 называется `Compile Time`

У Android-разработчика есть 3 времени:
1. `Design Time` – придумывание и написание кода
2. `Compile Time` – код собирается и исполняется различными компиляторами
3. `Run Time` – всё, что происходит при запуске приложения после его сборки

### `1.1` В сборке участвуют три компилятора

1. В первую очередь это `Kotlin Compiler`

   .kt и .java `–>` .class

2. За ним идут ещё два компилятора `dexer` и `shrinker`
   
   .jar и .class `–>` .dex
   
   `dexer d8` – компилятор java-байткода в dex-байткод – формат, в котором умеет исполняться байткод на виртуальных машинах андроида (vm android разные бывают). Главная фишка дексера – дешугаринг. Это такой процесс, когда различные новые фишки языка могут быть скомпилированы с обратной совместимостью с более старыми виртуальными машинами

   `shrinker r8` – компилятор-оптимизатор
   * Удаляет неиспользуемое: код, ресурсы, строки. Это уменьшает размер приложения и ускоряет его работу
   * Оптимизирует код – какие-то участки кода можно писать не самым эффективным способом, а шринкер знает, как  его сделать более эффективным для исполнения на какой-то машине
   * Запутывает код (obfuscation) – приложения можно декомпилировать и достать исходный код. Чтобы ваш код не утекал так легко, его запутывают
3. Далее происходит просто упаковка в .apk

Жизнь приложения на этом только начинается, наступает дистрибуция – его выгружают в `Store`

Опубликованное приложение устанавливается на телефоны

### `1.2` Установка и запуск: AOT и JIT компиляции

При установке происходит ещё одна компиляция – `AOT compilation` (Ahead of Time compilation)

Виртуальные машины работают с `JIT compilation` (Just in Time compilation), а в андроиде начиная с 5-й версии происходит AOT компиляция

Далее приложение запускается – начинается runtime, и в нём работает JIT компиляция

То есть код на этапе сборки уже компилировался тремя компиляторами, а потом он ещё будет продолжать компилироваться всю жизнь, установленную на телефон

Такие этапы:
1. AOT compilation
2. installation
3. Runtime
4. JIT compilation

Ими занимается виртуальная машина, на которой запускается приложение

## `2` Виртуальные машины 

### `2.1` JVM – Java Virtual Machine

Всё запускается на виртуальных машинах. Самая известная – java virtual machine, на её основе строится android virtual machine (с dex-байткодом вместо java-байткода)

Если знать, как устроена JVM, легко узнать и как устроены андроидные машины

### `2.2` Какая идея стояла за виртуальной машиной
![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-1.png)
Есть исходники, например, на плюсах. Существует много разных компиляторов, которые преобразуют код в машинный код или в код для ОС. Затем он запускается на разных девайсах с разной архитектурой

Но нам как разработчикам не хочется думать, кто и где какую версию запускает

Хочется один раз скомпилировать, отдать и чтоб оно работало

Идея java машины в этом и состоит:
1. Компилируем байткод, получаем .class файлы
2. Отдаём их в виртуальную машину
3. А виртульная машина уже установлена на различных устройствах. И если она там есть, там наш код можно исполнить

То есть идея «что-то сделай один раз и исполняй везде»

### `2.3` Dalvik VM (Andriod 4.4-)
В андроиде не java-байткод, а dex-байткод, и не java virtual machine, а какая-то другая виртуальная машина, которая умеет исполнять .dex файлы

Раньше ей был Dalvik, а потом ART (Android runtime)

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-2.png)
Нескомпилированный dex-code занимает мало места, но при запуске приложения весь код нужно постоянно компилировать – это требует ресурсы железа и быстрее сажает батарейку

### `2.4` ART (Android 5.0)
![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-3.png)
Много кода приложения компилируется заранее во время установки, поэтому приложение работает быстрее и тратит меньше ресурсов

### `2.5` ART (Android 7.0)
![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-4.png)
Вернули JIT компиляцию, т.к. скомпилировать всё заранее невозможно – стандартная библиотека джавы предоставляется виртуальной машиной, её нельзя скомпилировать заранее

Там есть такие штуки как рефлексия, аннотации, класс лоудеры. Они препятствуют тому, чтобы можно было вычислить, как код ведёт себя в runtime, поэтому приходится его компилировать кусочками в процессе

### `2.6` ART (Android 9.0)
![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-5.png)
В девятом андроиде пошли дальше

Если есть миллион устройств, которые уже компилируют одно и то же приложение под свои процессоры, можно попытаться поделиться этой информацией между устройствами

`Google Play` как маркет этим занимается. Мы можем ему предоставить некоторый baseline profile (файл, в котором описано, как лучше компилировать наши файлы), с ним AOT compiler знает лучше, как обрабатывать наш код, а дальше приложение на устройстве выполняет JIT компиляцию, собирает информацию во время работы и делится ею с Google Play. Тогда при установке можно отправить ещё один профайл – cloud profile, и девайс получит опыт миллионов других устройств, чтобы запустить приложение, и оно будет работать ещё быстрее

До таких идей доходят в процессе оптимизации работы андроида, поэтому приложения становятся всё быстрее и быстрее в новых версиях

### `2.7` Цикл работы Android Runtime
![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-6.png)

### `2.8` Виртуальная машина
это система, которая эмулирует аппаратное обеспечение компьютера и исполняет программы. То есть машина внутри другой машины

Бывают разных видов: `системные` и `процессные`

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-7.png)

**Системные виртуальные** машины устанавливаются на сервера, часто используются в больших датацентрах

Как эти сервера устроены:
* Есть мощная машина с кучей железа
* На ней запускается симулятор (так часто называют виртуальную машину для серверов)
* На симуляторе устанавливают ОС
* В этой ОС крутятся приложения

И так одну физическую машину можно разграничить на какие-то зоны и получить набор из виртуальных машин, поделив ресурсы физической машины

В андроиде используются **процессные виртуальные машины**. Они устроены чуть иначе:
* Операционная система работает с железом напрямую
* Есть даже какие-то низкоуровневые приложения, которые работают с этой операционной системой (у обычного пользователя нет к ним доступа)
* Рядом устанавливается экземпляр виртуальной машины, внутри которого запускается приложение. Их может создаваться несколько: когда в телефоне запускается 5 приложений, для каждого из них создаётся свой экземпляр виртуальной машины

Документация гугла:

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-8.png)

### `2.9` Android OS
Как этой всё запускается?

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-9.png)

1. Пользователь запускает что-то в телефоне, происходит событие на запуск приложения
2. Система ловит это событие. Есть специально заготовленный класс `Zygote` (биологический термин). Зиготы делятся – порождается процесс `process.fork()`
3. Отдельный процесс инициализируется:
   
   * Запускается виртуальная машина (`ART VM`)
   * Устанавливается особый обработчик исключений (`ExceptionHandler`), чтобы если ваш процесс испортился, он не повлиял на всю систему
   * Запускается главный поток (`Main Thread`)
   * Происходит связывание сервисов(`Bind Services`) между процессами: в системе работают какие-то сервисы, дающие доступ к драйверам, камере, физическим носителям, к Acitivity-manager и т.д. Обращение к таким штукам не быстрые, часто приводят к зависаниям
4. Когда процесс готов, на нём создаётся единственный класс `Application`
5. В этом Application запускается `Acivity`, `Service`, всё, что указано в манифесте
6. Пользователь это видит и доволен

### `2.10` App Process подробнее: Java Memory Model
он устроен так же, как и JVM. А точнее, он даёт доступ к памяти, а эта память устроена в ART точно так же, как и в JVM. Это называется `Java Memory Model`

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-10.png)

* В этой модели есть главный поток и какие-то другие потоки (которые мы создаём для асинхронной работы)
* В потоках мы вызываем методы, выделяем память под переменные и т.д.
* Примерно так строится единый стек вызовов в потоке (`Thread Stack`)
* Отдельная область памяти называется куча (`Heap`). В ней находятся сами объекты, а в стеке только ссылки на них (`references`). Эти ссылки могут идти на общие объекты, могут на разные. Здесь начинается тема следующей лекции про многопоточность

На самом деле всё знание про Java Memory Model про то, как же нам синхронизировать работу этих потоков. Но в этой лекции будем не об этом, а посмотрим повнимательнее, как устроена эта память

#### Какие ошибки могут случиться в стеке:
* `MethodNotFoundException` – метод может быть не найден, потому что почему-то он куда-то не загрузился
* `OutOfMemoryException` – может не хватить памяти, когда мы выделяем место под очередную переменную. Например, когда загружаем большую картинку
* `NullPointerException` – когда наша ссылка больше никуда не указывает
* `StackOverflowException` – выход за границу стека
* `NoClassDefFoundException` – класс не найден при выделении памяти

У стека есть единственное свойство – его размер. Мы можем его задать, если сами запускаем виртуальную машину, при помощи флага `-Xss1024k`

В старых андроидах размер стека был очень маленький:
* API 3 ([Android 1.5](https://android.googlesource.com/platform/dalvik.git/+/4da052510571aea4711d04de25a24b58cab1dadc%5E1..4da052510571aea4711d04de25a24b58cab1dadc/)) = 8 KB
* API 4-10 ([Android 1.6](https://android.googlesource.com/platform/dalvik/+/android-1.6_r1/vm/Thread.h) - [Android 2.3.7](https://android.googlesource.com/platform/dalvik/+/android-2.3.7_r1/vm/Thread.h)) = 12 KB
* API 14-17 ([Android 4.0](https://android.googlesource.com/platform/dalvik/+/android-cts-4.0_r1/vm/Thread.h) - [Android 4.2.2](https://android.googlesource.com/platform/dalvik/+/android-4.2.2_r1.1/vm/Thread.h)) = 16 KB
* Сейчас = 8 MB (не точно, так как размер стека определяют производители андроид устройства)

Размером стека мы не управляем, поэтому нужно аккуратно писать код, быть аккуратными с рекурсиями, использовать хвостовую рекурсию (которая компилируется и разворачивается), внерекурсивные вызовы. Потому что, если что, изменить мы это не сможем – устройства, на которых запускается приложение, у нас не под контролем, в отличии, например от бекенд-разработки, где, если что-то не так, можно поднять размер стека

#### Теперь про кучу – место, где живут сами объекты

Строго говоря, память это не только куча, но и ещё одно пространство – раньше оно называлось `PermGen` (Permanent Generation), сейчас называется `MetaSpace` начиная с восьмой версии Java. В них хранится немного разная информация

Куча это не один сплошной кусок памяти, он делится на поколения: есть молодые и старые

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-11.png)

Эти поколения наблюдаются специальной штукой, которая называется `Garbage Collector` (GC). Он их мониторит, удаляет оттуда объекты или перемещает

И даже молодые поколения состоят из нескольких этапов:
* Поколение `Eden` – самое молодое, куда попадает только что созданный объект
* Поколение `S0`
* Поколение `S1`

Они нужны, чтобы GC работал чуть оптимальнее – если бы он запускался на весь Heap, пришлось бы остановить работу приложения, чтобы проанализировать то, что там находится

Мы памятью напрямую не управляем, за нас это делает виртуальная машина при помощи GC

В молодых поколениях объекты нужно собирать чаще, а если объект уже пережил 10-20 сборок, то, наверное, он будет жить и дальше, и такие объекты можно смотреть чуть-чуть реже

Существуют разные GC: какие-то работают параллельно, какие-то останавливают все потоки и идут определять достижимость объектов из памяти. Возможности выбирать GC у нас тоже нет – он зашит на девайсе. Как правило, сейчас работают параллельные, которые работают в фоне

В отличие от Heap, которая является памятью внутри виртуальной машины, MetaSpace – это нативная память (динамическая), она доступна железу напрямую. Там хранятся самые важные вещи для работы приложения, которые почти никогда не должны выгружаться

Например, там хранятся `Class Metadata` – таблицы, где записано, какие методы к каким классам относятся, как они устроены, что позволяет стеку правильно работать. Так же туда предоставляется доступы к классам, которые поступают извне. Например, стандартная библотека Java

В Java и Kotlin есть класслоудеры, которые позволяют что-то добавить или убрать из MetaSpace

В старых версиях (PermGen) эта область была фиксированного размера и это приводило к OutOfMemoryException. MetaSpace динамическая, она расширяется

До Java 8 здесь ещё находился `String Pool`, сейчас он и другие пулы наодятся в Heap

#### Пулы (`Pools`) – области, где хранятся переиспользуемые объекты

Бывают разные: String Pool, Int Pool, Char Pool, Byte Pool, Short Pool

В пуле могут находиться одинаковые по содержанию, но разные по ссылке объекты, если использовать какие-то сложные методы создания объектов:

```kotlin
// String literals
"hello" == "hello"                                      // true
"hello" === "hello"                                     // true

// String builders
"hello" == StringBuiler("hello").toString()             // true
"hello" === StringBuilder("hello").toString()           // false

// Intern from Pool
"hello" === StringBuilder("hello").toString().intern()  // true
```

В котлине '==' это проверка на равенство по содержанию, а '===' по ссылке

StringBuilder генерирует строку как объект, поэтому созданные так строки по содержанию эквивалентны, а по ссылке разные

Существует метод `intern()` (интернирование), он говорит "не надо создавать новый объект, сложи его в пул, а если в пуле уже лежит этот объект, достань его оттуда". Тогда по ссылке они будут одинаковы

В Int Pool есть ограничение в 1 байт. Если все числа попадают в 1 байт, они будут браться из пула, если числа больше размером, то они будут браться откуда-то снаружи (будут создаваться новые объекты в куче)

```kotlin
val a: Int? = 127
val b: Int? = 127

a == b                  // true
a === b                 // true

val c: Int? = 128
val d: Int? = 128

c == d                  // true
c === d                 // false
```

В этом примере специально использован nullable тип, чтобы обмануть комплиятор. Примитивные типы данных хранятся напрямую в стеке и не выделяют никаких ссылок в кучу. А объектные типы с ссылкой заставляют создать объект, и тогда компилятор создаёт их

С интами идея простая: в вашем коде некоторые числа используются гораздо чаще, чем другие. И чтобы под них выделить заранее объекты и не создать десяток одинаковых существует пул

Все эти пулы нужны для оптимизации потребления памяти, скорости работы виртуальной машины

#### GC – определение мусора

Как определить, какой объект является мусором?

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-12.png)

Для этого существует понятие `GC Roots`. Они позволяют понять, что собрать, а что удалить

GC Root – это точка старта, откуда GC будет обходить ссылки и вычислять достижимость объектов. Если объект достижим – он живой, если нет – надо его убирать. GC видит всё, он отмечает достижимые объекты, а всё остальное попадает в мусор. GC Root находится вне кучи

Здесь существует ловушка, в которую разработчики могут попасть

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-13.png)

Например, Object 2 уже не используется, но где-то утекла ссылка. Такая утёкшая ссылка называется `утечкой памяти` (memory leak). Она транзитивно может переходить и на другие объекты и не давать очистить огромный кусок памяти. За такими вещами надо следить

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-14.png)

В реальном примере это могли бы быть классы Application, Activity, EventListener

У нас есть Activity, у неё есть UI Element, и мы в Application устанавливаем какой-то глобальный Listener, который меняет кнопку. Если забыть убрать ссылку из Application на этот Listener, то Activity никогда не очистится

Поэтому нужно быть аккуратным, в разных LifeCycle-зависимых методах снимать ссылки симметрично и следить за утечками

Несмотря на то, что GC за нами всё чистит, наша задача – следить, чтобы никакая ссылка не утекла

## `3` Компилятор и плагины

### `3.1` Kotlin K2 Compiler

Компилятор – программа, переводящая написанный на языке программирования текст в набор машинных кодов

Для нас это чёрный ящик. Мы подаём в него исходники, зависимости, флаги и настройки, а на выходе он даёт скомпилированный код – для нас это байткод (.class, .js, .so)

Текущая версия компилятора Котлина называется Kotlin K2 Compiler, вышла стабильная версия в конце мая 2024 года

Внутри компилятор работает в две фазы: `Frontend` и `Backend`

На фронтенде анализируется код, правильно ли он написан, стоит ли с ним дальше работать. Если неправильно, то где именно, а если правильно, то пытается понять его смысл – получить семантику

То есть фронтенд пытается понять смысл написанного вами кода. Если этот смысл понятен, то, наверное, бэкенд справится с его переводом в байткод

Бэкендов существует много разных, фронтенд – один. Бэкенд, с которым работаем мы, называется `JVM IR` (Intermediate Representation). Для джаваскрипта другой бэкенд – JS IR, для нативного кода – Native, для WebAssembly – WASM

Как устроен фронтенд:
1. У нас есть исходники, на выходе должны получить семантику
2. `Parser`: эти исходники мы будем парсить, то есть разбирать на токены

   Пример:
   ```kotlin
   private val kotlinFiles = mutableListOf(1, 2, 3)
   ``` 
   разобъётся на
   ```kotlin
   Private
   Var
   kotlinFiles
   ArrayList
   Int(1), Int(2), Int(3)
   ```
3. `Syntax Analysis`: эти токены будем проверять на синтаксические ошибки (как диктант в школе)
4. `Fir Builder`: дальше пытаемся построить смысл – строим `PSI` дерево. Это представление хранится в памяти, но его можно сериализовать – записать на файловую систему. Так, например, реализуется кеш компилятора (он не будет перекомпилировать не изменившиеся файлы)
5. `Resolution`: если с деревом всё ок, можно из него получить семантическое представление, в которую ещё на фазе резолюции подставим какие-то дополнительные штуки
6. Получим на выходе файл `FIR` (Frontend Intermediate Representation)

Перед отправкой на бэкенд, FIR преобразуется инструментом `fir2ir` для упрощения работы бэкенда. Дальше бэкенд генерирует итоговый файл

Bytecode Generator –> .class

JavaScript Generator –> .js

Native Code Generator –> .so

У каждого бэкенда отличается только генератор кода, ну и на выходе они дают разный результат

На лекции был краткий пересказ статьи с Хабра про Kotlin K2 Compiler https://habr.com/ru/companies/kts/articles/813085/

Компилятор котлина устроен очень здорово. Принципы разработки, которые там использованы, полезны в повседневной жизни – можно вдохновиться тем, как сделан компилятор и в вашем коде тоже что-то реализовть по такой схеме

### `3.2` Kotlin K2 Compiler Plugins

К компилятору можно подключать плагины на любом этапе работы компилятора: и в синтаксический анализ, и перед ним, и при генерации дерева. Давайте разбираться на примерах, что такое плагины. Мы с ними имеем дело постоянно:

#### <u>***Kotlin Compose Plugin***</u>

Compose работает в паре с компилятором. Аннотации типа @Composable очень часто намекают на то, что где-то используется рефлексия или плагин компилятора котлина

Рассмотрим типичную Composable функцию
```kotlin
@Composable
fun Counter() {
    var count by remember() { mutableStateOf(0) }
    Button(
        text = "Count: $count",
        onPress = { count += 1 }
    )
}
```

После работы плагина, этот код превращается в такой:
```kotlin
fun Counter($composer: Composer) {
    $composer.start(123)
    var count by remember($composer) { mutableStateOf(0) }
    Button(
        $composer,
        text = "Count: $count",
        onPress = { count += 1 }
    )
    $composer.end()
}
```

Пропала аннотация, появился обрамляющий весь код composer. Его подстановкой занимается плагин

Плагин позволяет скрыть от разработчиков захламляющую информацию (что называется boilerplate), чтобы концентрироваться только на значимых вещах

Первый код гораздо понятнее читается и видна суть написанного

#### ***<u>kotlinx.serialization Plugin***</u>

Этот плагин тоже при помощи аннотаций и специального класса `Json` позволяет генерировать из вашего дата класса json-представление (чтобы, например, отправлять его в Сеть)

```kotlin
@Serializable
data class Project(
    val name: String,
    val owner: Account,
    val group: String = "R&D"
)

@Serializable
data class Account(val userName: String)

val moonshot = Project("Moonshot", Account("Jane"))
val cleanup = Project("Cleanup", Account("Mike"),  "Maintenance")

fun main() {
    val string = Json.encodeToString { listOf(moonshot, cleanup) }
    println(string)
    // [{"name":"Moonshot","owner":{"userName":"Jane"}},{"name":"Cleanup","owner":{"userName":"Mike"},"group":"Maintenance"}]

    val projectCollection = Json.decodeFromString<List<Project>>(string)
    println(projectCollection)
    // [Project(name=Moonshot, owner=Account(userName=Jane), group=R&D), Project(name=Cleanup, owner=Account(userName=Mike), group=Maint)]
}
```

Раньше для этого использовали различные библиотеки, сейчас делают просто с помощью плагина. Логично, ведь есть схема дата класса, мы знаем какие поля там есть – наверное можно сгенерировать код, который превращает его в строку с какой-то специфичной структурой. Собственно, kotlinx.serialization это делаает. И при помощи класса Json мы можем либо закодировать data class в json-представление, либо из строки декодировать обратно и получить data class

#### ***<u>ksp (Kotlin symbol processing)***</u>

– API Kotlin для написания плагинов компилятора

В целом, ksp довольно простая вещь, за которой скрывается очень мощный инструмент. На самом деле, работая с ksp вам не надо до конца понимать, как устроены плагины или как их писать, какие этапы у компилятора есть

ksp работает где-то в середине frontend части компиляции

Чтобы сделать свой плагин на котлине, нам надо воспользоваться фреймворком SymbolProcessorProvider – создать SymbolProcessor. У него есть две части:
* Resolver – API для чтения файлов, он возвращает классы:
  * KSFile
  * KSDeclaration
  * KSAnnotation
  * KSValueArgument

* SymbolProcessorEnvironment (окружение) – API для генерации файлов, что-то типа контекста в андроиде 
   ```kotlin
   codeGenerator.createNewFile(
       filename = "generated",
       extension = "kt",
   )
   ```

Рассмотрим на примере: допустим, мы хотим создать аннотацию, которой мы будем размечать в коде файлы, и мы хотим все эти файлы собрать в список

Это можно применять к Activity, т.к. их всегда нужно регистрировать в манифесте. А вам может быть лень это делать, вы бы хотели, чтобы кодогенератор сам их туда прописал. Поэтому для начала можно хотя бы собрать все такие файлы в единый список, может быть полезно

В Музыке мы такое делали. У нас есть аннотация Experiment – feature toggle (закрывает кусок кода). Раньше у нас постоянно возникали конфликты во время разработки из-за того, что разработчики в один и тот же файл добавляют новые и новые эксперименты, их может быть сотни, а символ процессор эту проблему решил – каждый разметил свой файл, чужие файлы не трогаются, и никому не надо думать, кто в каком порядке туда добавил

```kotlin
SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation("com.yandex.MyAnnotation")
      
        val declarations = findAnnotatedFiles(symbols)
      
        if (declarations.isNotEmpty()) {
            createFile(declarations)
        }

        return symbols
           .filterNot { it.validate() }
           .toList()
    }
}

private fun findAnnotatedFiles(symbols: Sequence<KSAnnotated>): List<KSDeclaration> { 
    return symbols
        .filter { it.validate() }
        .filterIsInstance<KSClassDeclaration>()
        .toList()
}

private fun createFile(
    declarations: Sequence<KSDeclaration>,
    annotatedFileInfos: List<AnnotatedFileInfo>,
) {
    val file = codeGenerator.createNewFile(
        Dependencies(
            aggregating = true,
            sources = declarations.mapNotNull { it.containingFile }
                .distinct()
                .toList()
                .toTypedArray(),
        ),
        packageName = "com.school.ksp.example",
        fileName = "SchoolAnnotationRegistry"
    )

    file.bufferedWriter().use {
        generateCode(annotatedFileInfos).writeTo(it)
    }
}
```

Делается это с помощью резолвера. Где-то в коде мы завели свою аннотацию и из резолвера мы можем достать все файлы, размеченные аннотацией. Что можно с ними сделать:
   * Например, достать только классы, размеченные аннотацией (аннотацию можно вешать и на методы)
      ```kotlin
      .filterIsInstance<KSClassDeclaration>()
      ```

   * Так же можно посмотреть KSMethod, KSField, KSClass, KSProperty 

Посмотрим, как собрать все файлы в список:
1. В первом блоке генерим лист. `ControlFlow` это фигурные скобки (то есть блок кода, который исполняется). Открываем ControlFlow, который называется buildList (то есть будет вызов функции buildList). Внутри этих фигурных скобок будем добавлять классы, которые нашли. Надо найти имя класса, который был отмечен аннотацией. Здесь доступен шаблонизатор `%T`, можем с помощью него подставить это имя + "()"
2. Этот лист нужно куда-то сохранить. Создаём объект с помощью `objectBuilder()` (`classBuilder()` может создать класс, нам достаточно object), создаём у него переменную files типа List с параметром T = ClassName, в инициализаторе указываем блок, который выше описывали

```kotlin
val buildListBlock = CodeBlock.builder()
    .beginControlFlow("buildList")
    .apply {
        files.forEach { file ->
            addStatement("add(%T())", ClassName(file.packageName, file.simpleName))
        }
    }
    .endControlFlow()
    .build()

return FileSpec.builder(packageName, "Registry")
    .addType(
        TypesSpec.objectBuilder("Registry")
            .addProperty(
                PropertySpec.builder("files", List::class.asClassName().parametrizedBy("ClassName"))
                .initializer(buildListBlock)
                .build()
            )
           .build()
    )
    .build()
```

И на выходе получим такой объект

```kotlin
public object Registry {
    public val files: List<ClassName> = buildList {
        add(SomeClassName())
        add(AnotherClassName())
    }
}
```

Примерно так работает ksp. Как видите, не надо обладать большой базой, чтобы работать с ним. Здесь происходит только чтение и запись, больше ничего сложного там нет

Когда мы сгенерировали файл, главное не забыть вернуть символы (код, который анализировался) обратно следующему процессору (они работают по цепочке, ksp плагинов может быть много, каждый следующий обрабатывает какой-то поток, то есть они друг на друга влиюят)

```kotlin
SymbolProcessor {
    ...

    return symbols
        .filterNot { it.validate() }
        .toList()
}
```

Подведём итоги ksp плагина:
1. Это API Kotlin для написания плагинов компилятора
2. Писать плагины для котлина можно на котлине
   
   (котлин пишется на котлине, и компилятор котлина пишется на котлине)

3. Достаточно простой синтаксис 

    (в сравнении с тем, как пишутся обычные плагины)

4. Похож на рефлексию
   
   Отличие в том, что рефлексия работает в runtime и требует обращения в MetaSpace, а обрашаться туда сложно. Из-за рефлексии мы не можем использовать AOT компиляцию, поэтому её приходится процессить в JIT. Рефлексия медленная. Но если мы проделаем всю работу рефлексии заранее, напишем код, сгенерируем его из многих файлов, это будет гораздо лучше. Мы как разработчики не хотим писать boilerplate code, поэтому компилятор и плагин сделают это за нас. В целом, ksp можно рассматривать как рефлексию на стероидах

5. Но ksp не позволяет нам менять уже написанный код, как можно было в рефлексии. Мы можем только посмотреть и создать что-то дополнительное новое. Для остального нужно писать уже более сложные плагины с API написания плагинов. Тем не менее, при помощи ksp можно сделать очень многое

## `4` Kotlin Features

Фич гораздо больше, чем описано здесь, но эти на мой взгляд ключевые. Они позволяют писать код удобнее, чем это было раньше. Делают Котлин современным языком, который выбирают всё больше разработчиков даже с других платформ

### `4.1` Extension Functions

Расширение API класса. Это возможность вызывать функции над классами, даже если у нас нет доступа к ним внутрь

Например, объявить над интом функцию возведения в квадрат и вызывать её в синтаксисе, как будто она была где-то внутри

```kotlin
fun Int.squared(): Int = this * this
val result = 5.squared()
```

На этом построены прикольные апишки, например, библиотека kotlintime. Мы можем работать с классом Duration, просто указывая "10.seconds". Это гораздо читаемее, чем duration(10) – вызывать функцию, которая возвращает Duration, и отдавать туда 10
```kotlin
val duration: Duration = 10.seconds
duration.toComponents { minutes, seconds, nanos -> 
    println("Went: $minutes mins $seconds secs and $nanos nanos")
}
```

Благодаря этому можно перевернуть код и он будет читаться как книга, а не как исходники на плюсах

Так же и вы можете строить расширения над библиотеками или классами, которые используете, и получать более читаемый и простой код

В конечном счётё, на Extension функциях строится DSL код: например, можно build файлы для андроида писать на котлине

### `4.2` Scope Functions

Функции, которые меняют `this` внутри блока, или создают изолированный блок, позволяющий там внутри создать переменные и работать с ними

| Function | Object reference | Return value   | Is extension function                       |
| :------- | :--------------- | :------------- | :------------------------------------------ |
| `let`    | it               | Lambda         | Yes                                         |
| `run`    | this             | Lambda         | Yes                                         |
| `run`    | -                | Lambda         | No: called without the context object       |
| `with`   | this             | Lambda result  | No: takes the context object as an argument |
| `apply`  | this             | Context object | Yes                                         |
| `also`   | it               | Context object | Yes                                         |

https://kotlinlang.org/docs/scope-functions.html

![alt text](res/04.%20Погружение%20в%20Kotlin%20и%20JVM/image-15.png)

Используем `run` вместо `if`, чтобы записать код лаконичнее

Допустим, функция использует только non-nullable тип, но исторически nullable тоже приходят. В блоке run это объясняем
```kotlin
fun test(arg: Any?) {
    val validArg = arg ?: run {
        prinln("argument is null!")
        return
    }

    println("do the job with $validArg")
}
```

Или, например, хотим собрать список, добавить туда какие-то значения. `apply` позволяет не писать `List.add()`, `List.add()`, `List.add()`, в этом кусочке кода видим только самую суть

```kotlin
ArrayList<Any>().apply {
    add(5)
    add("6")
    add(7.0)
}
```

Или, например, у нас есть список пользователей, мы их фильтруем, но код работает неправильно. Мы хотим проверить, как выглядит результат где-то посередине. Обычно надо завести промежуточную переменную, её куда-то распечатать. `also` позволяет вклиниться в середину этого процесса

```kotlin
fun process(users: List<String?>): List<Int> {
    return users
        .filterNotNull()
        .also { println("filtered to $it") }
        .map { it.length }
}
```

Но у Scope функций есть проблема. Язык даёт возможность одно и то же записать 2-3-4 способами, и если использовать их неправильно, можно только запутать. Слишком большая гибкость. Можно вложить run в apply, apply в run и понять, какая переменная под this подразумевается, будет очень сложно

Поэтому нужно спрашивать себя "Подходит ли эта функция сюда? Стал ли код читаемее? Не будет понятнее просто использовать if?"

### `4.3` Functional Types

В котлине есть лямбды, как и в других языках. Но здесь это *переменная с функциональным типом*, то есть у переменной есть что-то на вход и она что-то возвращает

С функциями, принимающими переменные функционального типа, можно работать по-разному:

```kotlin
fun process(processor: (String) -> Int) {
    val result = processor("five")
    println("five is $result")
}

process(processor = { it.length })
process { it.length }

val lambda: (String) -> Int = { it.length }
process(processor = lambda)
```

Также в котлине есть анонимные функции. Отличие от лямбд в том, что из них можно делать return (только внутри неё), а в лямбдах несколько сложнее: им нужно давать какую-то метку, или они могут возвращать из вложенных лямбд, нельзя пользоваться оператором return. Функция, объявленная через анонимную функцию это тот же самый функциональный тип и она может быть использована внутри process

```kotlin
val function = fun(arg: String): Int { return arg.length }
process(processor = function)
```

Вообще, функциональные типы это такой мостик котлина для парадигмы функционального программирования

Мы можем объявить функцию умножения двух чисел в функциональном стиле

```kotlin
fun multiply(a: Int, b: Int): Int = a * b
```

И в функциональном программировании есть понятие *карирования функций*, когда мы из функции несколько переменных возвращаем функцию меньшего количества переменных, то есть упрощаем её

Например, через оператор карирования можем сделать из функции умножения двух чисел функцию умножения на два:

```kotlin
fun carry(
    def: Int,
    function: (Int, Int) -> Int
): (Int) -> Int {
    return { arg -> function(arg, def) }
}

val double: (Int) -> Int = carry(2, ::multiply)
val ten = double(5)
```

Котлин мультипарадигменный – можно писать в ООП стиле, можно в функциональном. Ваша задача выбрать как вы пишете, в андроид разработке ООП подход более используемый, тем не менее такие возможности есть и иногда это очень сильно экономит код

У функционального стиля есть множество плюсов: он лучше тестируется, подходит под многопоточные среды. Но это тема отдельной большой лекции

### `4.4` Sealed Classes

Одна из самых мощных вещей в плане создания приложений, которые придётся поддерживать с ходом их жизни. То есть если вы написали приложение и выкинули его, оно где-то живёт, то sealed классы не особо на что-то влияют, но если вы меняете этот код постоянно – вот здесь они раскрываются в полной красе

`Sealed class`, или "замкнутый" класс, – класс, для которого **компилятор знает количество наследников**

У интерфейса Animal только три наследника определено и компилятор это знает:

```kotlin
sealed interface Animal {
    class Cat: Animal
    class Elephant: Animal
    class Wolf: Animal
}
```

А раз он знает, мы можем писать такой код:

```kotlin
val animal: Animal = loadAnimal()
val name = when (animal) {
    is Animal.Cat -> "cat"
    is Animal.Elephant -> "elephant"
    is Animal.Wolf -> "wolf"
}
```

`when` будет перебирать все типы и у него не будет ветки `else`

Почему это так полезно? Если кто-то захочет добавить новый класс-наследник Animal, то **во время компиляции** он увидит все места, где компилятор его заставит добавить ещё одну ветку. Компилятор знает, что не сможет приравнять к `name` никакую строку, потому что нету ветки для ещё одного четвёртого типа

В реальной жизни sealed классы очень спасают. Например, у нас в приложении Музыки есть интерфейс `playable` – мы можем играть в нашем плеере разного вида медиа-источники: mp3 файлы, бесконечная трансляция (бесконечный медиа-файл – бесконечно получаем из сервера) и другие форматы. Всё это разные playable, и если мы собрались поддерживать новый, то у нас в приложении может быть 100 мест, где мы смотрим, как их обрабатывать: для одного нарисуем одни кнопки, для другого – другие, плеер будет по-другому работать, по-другому декодировать этот файл надо. Когда это всё закрыто sealed class-ом, расширять становится гораздо проще – компилятор заставит вас продумать про все 100 мест, где это используется

Я лично добавлял и расширял такой интерфейс и я и половины мест не знал в коде, работая несколько лет в проекте. **И именно компилятор на них указал, а не приложение где-то себя неправильно повело и мы только при тестировании про это узнали**

Также sealed class-ы позволяют делать возвращение нескольких разных типов результата из функции

Когда функция объявлена, она возвращает только один тип, и альтернативой в виртуальной машине и джаве первых версий были исключения (`exceptions`) – способ прервать выполнение функции и вернуть поток на предыдущий метод из стека

В котлине можно не пользоваться исключениями вообще, потому что sealed class позволит писать такие лаконичные возвращаемые результаты:

```kotlin
sealed interface Result<out T : Any> {
    data class Success<T : Any>(val value: T) : Result<T>
    data class Error(val error: Exception) : Result<Nothing>
}

fun loadResult(): Result<Int> {
    if (Random.nextBoolean()) {
        return Result.Success(500)
    } else {
        return Result.Error(Exception())
    }
}
```

Здесь функция возвращает тип Result и мы не выбрасываем исключение в случае ошибки, мы можем обработать результат и так:

```kotlin
val result: Result<Int> = loadResult()

val resultValue = when (result) {
    is Result.Success -> result.value
    is Result.Error -> {
        println(result.error.message)
        0
    }
    println("continue with $resultValue")
}
```

Выбрасывание эксепшена штука довольно дорогая, они собирают мета-информацию об исполнении кода – есть thread, есть MetaSpace, эксепшн собирает стек вызовов в этом треде – это вещь, которую нельзя скомпилировать в AOT, соответственно, исполняется медленно

В примере необязательно возвращать Exception(), можно и строку, нам без разницы в какой точке приложение упало, мы обработаем этот error как нам удобно

И в котлине есть `when`, мы знаем, что есть результаты Success и Error, и никаких других результатов не существует – если бы мы без sealed класса объявили интерфейс, компилятор заставил бы нас написать ветку `else`, чтобы указать все остальные типы, а это какая-то бесполезная обработка, которую нужно выдумывать

При работе с сетью лучше возвращать результаты разных типов, чем кидать исключения, чтобы это работало в том числе и быстрее

Ну и решается холивар программистов "исключения это хорошо или плохо?"

### `4.5` Null safety


```kotlin
val nullable: Any? = null
val nonNull: Any = "string"
```

Это, наверное, то, о чём многие рассказывают в первую очередь. Я расскажу чуть-чуть с другой стороны

Нуллабельность типов позволяет работать с ними в generic-ах

String – наследник String?, в него нельзя записать String?, компилятор об этом сообщает

```kotlin
class Result<T>(val value: T)
val result = Result<String?>(null)
val type: String = result.value // Type mismatch. Required: String, Found: String?
```

Или можно указать ограничение сверху для типов generic-а с помощью Any. Любой Any не является наследником nullable типа, Any – наследник Any?

```kotlin
class Result<T : Any>(val value: T)
val result = Result(null as String?) // Type argument is not within its bounds. Expected: Any, Found: String?
val type: String = result.value
```

Null safety позволяет проверку на null делать не только для ссылок, но ещё и для системы типов. И это попадает на уровень Compile Time, это довольно мощный инструмент в котлине

### `4.6` Special Types

Специальными их называют, потому что в джаве их не было

#### **Special Type – `Unit`**
Это тип, который возвращается из всех функций. Поэтому можно написать, например, такой код

```kotlin
fun test(arg: Any) {
    println("arg is $arg")
}

val wtf = test("hello").hashCode()
```

Вообще, это позволяет делать expression-ы (выражения). То есть if else может вернуть результат, нам не надо присваивать этот результат в переменную, объявленную до if else. То же самое с when и т.д. Это делает код более читаемым

```kotlin
val type = if (true) "string" else test("string")
```

#### **Special Type – `Any`**

Главный класс котлина, от которого наследуются все остальные классы, если не считать его брата близнеца Any?, от которого наследуются все нуллабельные типы и он сам

В джаве были доступы ко всяким функциям типа wait(), notify(), для работы с многопоточностью, для синхронизации на мониторах. В котлине такого нет

```kotlin
val any = Any()
any.wait() // Unresolved reference: wait
```

Это связано с тем, что котлин можно скомпилировать на другие языки, в которых таких функций нет, это особенность jvm. Но если мы знаем, что работаем на коде, который будет компилироваться под jvm, то можем привести Any к типу Object (на самом деле Any это тот же самый java.lang.Object в байткоде, но в его публичном интерфейсе нет методов wait, notify. Следующим хаком можно до них добраться)

```kotlin
val obj = Any() as java.lang.Object
obj.wait()
obj.notify()
```

#### **Special Type – `Nothing`**

Позволяет строить очень эффективные вещи вместе с generic-ами

```kotlin
class NothingExample {
    fun returnNothing(): Nothing = throw Exception()
    fun acceptNothing(value: Nothing) = Unit
}

val example = NothingExample()
fun example() {
    example.returnNothing()
    println("hello world") // Unreachable code
}

example.acceptNothing(Any()) // Type mismatch. Required: Nothing, Found: Any
```

Nothing является наследником всех классов. Даже если вы напишете свой класс, Nothing будет его наследником. Поэтому это самый узкий класс и получается замкнутая система от всего (Any?) до ничего (Nothing)

### `4.7` Mutable / Immutable Collections

Разделение коллекций на изменяемые и неизменяемые. Порядок наследования типов:
```kotlin
Mutable Iterable -> Iterable
Mutable Collection -> Collection
Mutable List -> List
Mutable Set -> Set
```

### `4.8` Generics

Про них гораздо глубже, всё остальное было подводкой к этому. Эту тему редко понимают глубоко и её часто спрашивают на собеседованиях в компании. Я считаю, что дженерики – одна из ключевых вещей в разработке, потому что они позволяют строить действительно удобные системы, проектировать свои фреймворки, на которых будут работать ваши программы где-то внутри

Правильное использование дженериков позволило котлину сделать удобную систему коллекций. На этом построен stream api, когда у коллекции вызываем filter(), он принмает фильтр типа T

Заведём иерархию типов для дальнейшей лекции:

```kotlin
interface Animal
interface Mammal : Animal
interface Predator : Mammal

class Elephant : Mammal
class Cat : Predator
```

Наша задача – открыть ресторан для хищников, будем кормить их мясом

Компилятор запрещает писать такой код:

```kotlin
fun restaurant(predators: ArrayList<Predator>) {
    predators.forEach { println("feed $it") }
}

val cats = ArrayList<Cat>()
restaurant(cats) // Type mismatch 
// Required: kotlin.collections.ArrayList<Scratch.Predator>
// Found: kotlin.collections.ArrayList<Scratch.Cat>
```

Причина – внутри функции мы можем испортить что-то у списка:

```kotlin
fun restaurant(predators: ArrayList<Predator>) {
    predators.add(Wolf())
}

restaurant(cats)
```

Компилятор заранее не знает, а синтаксически так можно, поэтому на всякий случай он запрещает передавать этот тип

И если бы мы потом хотели с нашими котами что-то сделать, мы бы внезапно достали из списка Волка, который не является котом, но является хищником

```kotlin
cats.forEach { it.purr() } // ClassCastException
```

#### **Heap Pollution**

Такая ситуация называется `Heap Pollution`. В Runtime в момент чтения мы ловим исключение: мы испортили в куче систему типов. Мы ожидали, что храним что-то одно, а там хранится ссылка на что-то другое – это проблема, от которой нас защищает компилятор

Но нам хочется использовать все возможности ООП. Да, я могу передавать наследников класса, но как передать типизированного наследника? Я вот уверен, что кошка это хищник, как рассказать это компилятору?

Почему вообще такое происходит?

```kotlin
fun restaurant(predators: ArrayList<Predator>) {
    predators.add(Wolf())
}

cats.forEach { it.hashCode() }
```

Дело в том, что на уровне байткода никаких дженериков нет, и если байткод декомпилировать обратно, в данном случае, в джаву, то получим следующее:

```java
public final void restaurant(ArrayList predators) {
    Intrinsics.checkNotNullParameter(predators, "predators");
    predators.add(new Wolf());
}

Iterable $this$forEach$iv = (Iterable)this.cats;
Iterator var4 = $this$forEach$iv.iterator();

while (var4.hasNext()) {
    Object element$iv = var4.next();
    Cat it = (Cat)element$iv;
    it.hashCode();
}
```

Ресторан просто принимает список каких-то объектов, там просто какие-то ссылки и именно поэтому в него можно добавить что угодно, компилятор не знает, что вы хотите туда добавить

А при чтении компилятор дополнительно приводит элемент к типу Cat, поэтому вылезает ошибка

```java
Cat it = (Cat)element$iv;
```

#### **Стирание типов – Type Erasure**

Это называется стирание типов (`Type Erasure`). Когда мы компилируем код для JVM, в JVM нет никакой информации о типе T, но JVM доверяет компилятору, она знает, что он проверил код и гарантирует его работоспособность, поэтому просто исполняет

Стирание типов также запрещает делать такие штуки:

```kotlin
val cats = ArrayList<Cat>()
if (cats is List<Int>) { // Type mismatch. Cannot check for instance of erased type: List<Int>
    // test
}
```

Ещё если мы хотим внутри функции получить тип переменной

```kotlin
fun <T : Any> test(value: T) {
    val valueClass = value::class
}
test("string")
```

Декомпилировав из байткода в джаву увидим, что используется getClass(), то есть рефлексия

```java
public final void test(Object value) {
    Intrinsics.checkNotNullParameter(value, "value");
    Class valueClass = value.getClass();
}
```

Решить проблему стирания типов и ускорить работу позволяют `inline` функции Котлина

```kotlin
inline fun <reified T> reifiedTest(value: T) {
    val valueClass = T::class
}
reifiedTest("string")
```

Такой код сгенерится в гораздо более простую штуку:

```java
Object value$iv = "string";
Class var5 = String.class;
```

Коду с inline и reified не нужно лезть в MetaSpace за классом объекта, он сразу передаёт экземпляр класса String, потому что компилятор знает, в каком окружении функция вызывается и у него ещё есть информация о типе T

#### **Вариантность**

Это математическое понятие, которое позволяет работать с системами типов

Допустим, мы создаём свою иерархию коллекций

```kotlin
interface MutableList<T> { fun add(value: T) }
interface ReadableList<T> { fun get(): T }

class MyList<T>() : ReadableList<T>, MutableList<T> {
    override fun add(value: T)
    override fun get(index: Int): T
}
```

Создали только изменяемый лист, только читаемый лист и лист-наследник обоих

Ключевое здесь – то, где расположен Generic (буква T). Если он располагается внутри функции (`fun add(value: T)`) это один тип вариантности, а если снаружи (`fun get(): T`) – другой

Рассмотрим примеры

#### **Вариантность – `covariance`**

У нас есть три листа с разными типами T и есть переменные, куда я хочу их присваивать (это тоже самое, что передавать в функцию, как мы передавали в ресторан). Могу ли я список хищников просто читать как список хищников? Ну да, по типам всё сходится. Можно ли присвоить его в тип млекопитающих или животных? Ну если ожидают животных, то каждый хищник является животным. То есть такие присваивания, зная, что ReadableList позволяет только читать, вроде бы легальные. Чтобы это знал и компилятор, существует ключевое слово `out` – обязательство только читать из этого типа

```kotlin
val animals: MyList<Animal> = MyList()
val mammals: MyList<Mammal> = MyList()
val predators: MyList<Predator> = MyList()

val rp: ReadableList<out Predator> = predators
val rm: ReadableList<out Mammal> = predators // mammals
val ra: ReadableList<out Animal> = predators // mammals // animals
```

#### **Вариантность – `contravariance`**

В обратную сторону. MutableList это интерфейс, в котором Generic внутрь передаётся. Здесь ключевое слово `in` – обязательство только передавать аргументы

```kotlin
val animals: MyList<Animal> = MyList()
val mammals: MyList<Mammal> = MyList()
val predators: MyList<Predator> = MyList()

val mp: MutableList<in Predator> = animals // mammals // predators
val mm: MutableList<in Mammal> = animals // mammals
val ma: MutableList<in Animal> = animals
```

Можно представить такую аналогию: у вас есть список животных и вы организуете зоопарк. В этот зоопарк можно добавлять новых животных. Если ваш зоопарк поддерживает всех животных, можно ли сказать, что он принимает хищников? Любой переданный хищник будет являться животным, поэтому такое присваивание работает

Когда сам тип и его производный тип сонаправлены (являются наследниками) – ковариантность. Ключевое слово `out`

Коллекция                   | Класс     
:--------------------------:| :-------:
ReadableList`<out Animal>`  | Animal
⤴                          | ⤴
ReadableList`<out Mammal>`  | Mammal
⤴                          | ⤴
ReadableList`<out Predator>`| Predator

Когда сам тип и его производный тип противоположно направлены – контрвариантность. Ключевое слово `in`

Коллекция                 | Класс     
:------------------------:| :-------:
MutableList`<in Animal>`  | Animal
⤵                        | ⤴
MutableList`<in Mammal>`  | Mammal
⤵                        | ⤴
MutableList`<in Predator>`| Predator

#### **Вариантность – `declaration-site variance`**

При такой вариантности не нужно при объявлении переменной указывать out или in – достаточно указать это один раз при объявлении интерфейса. Переменные будут знать это по умолчанию

```kotlin
interface ReadableList<out T> { fun get(): T }

val rp: ReadableList<Predator> = predators
val rm: ReadableList<Mammal> = predators // mammals
val ra: ReadableList<Animal> = predators // mammals // animals



interface MutableList<in T> { fun add(value: T) }

val mp: MutableList<Predator> = animals // mammals // predators
val mm: MutableList<Mammal> = animals // mammals
val ma: MutableList<Animal> = animals
```

#### **Матрицы вариантностей**

Посмотреть на это можно ещё и с другой стороны. **Галочки означают, что можно присваивать**

CoVariance               | MyList`<Animal>` | MyList`<Mammal>` | MyList`<Predator>`
:----------------------: | :--------------: | :--------------: | :----------------:
ReadableList`<Animal>`   | ✔                | ✔                | ✔
ReadableList`<Mammal>`   |                  | ✔                | ✔
ReadableList`<Predator>` |                  |                  | ✔

InVariance         | MyList`<Animal>` | MyList`<Mammal>` | MyList`<Predator>`
:----------------: | :--------------: | :--------------: | :----------------:
MyList`<Animal>`   | ✔                |                  | 
MyList`<Mammal>`   |                  | ✔                | 
MyList`<Predator>` |                  |                  | ✔

ContraVariance          | MyList`<Animal>` | MyList`<Mammal>` | MyList`<Predator>`
:---------------------: | :--------------: | :--------------: | :----------------:
MutableList`<Animal>`   | ✔                |                  |
MutableList`<Mammal>`   | ✔                | ✔               | 
MutableList`<Predator>` | ✔                | ✔               | ✔

#### Пример контрвариантности

Если определён порядок над вещественными числами – то определён и над целыми числами

```kotlin
public interface Comparable<in T> {
    public operator fun compareTo(other: T): Int
}

val realNumbers = object : Comparable<Real> {
    override fun compareTo(other: Real): Int = 0
}

val ints: Comparable<Int> = realNumbers
```

#### **Пример всех вариантностей**

```kotlin
val predators = ArrayList<Predator>()
val mammals = ArrayList<Mammal>()

predators.copyTo(to = mammals)

fun <T> ArrayList<out T>.copyTo(to: ArrayList<in T>) {
    this.forEach { item: T ->
        to.add(item)
    }
}
```

#### Как исправить исходный пример с рестораном

Первое решение – написать out в сигнатуре метода ресторана. То есть ресторан обязуется только читать и ничего не дописывать в список

```kotlin
fun restaurant(predators: ArrayList<out Predator>) {
    predators.forEach { println("feed $it") }
}

val cats = ArrayList<Cat>()
restaurant(cats)
```

Второе решение – ещё лучше. Можно было сказать, что у вас тип List уже иммутабельный и в нём это внутри прописано, что это out

```kotlin
fun restaurant(predators: List<out Predator>) {
    predators.forEach { println("feed $it") }
}

val cats = ArrayList<Cat>()
restaurant(cats)
```

#### Для самых внимательных

Если посмотреть на интерфейс List, который является наследником Коллекции, можно увидеть, что, хотя тип элемента является out, в нём есть функции, которые принимают его внутрь

```kotlin
public interface List<out E> : Collection<E> {
    override val size: Int
    override fun isEmpty(): Boolean
    override fun iterator(): Iterator<E>
    public operator fun get(index: Int): E

    override fun contains(element: @UnsafeVariance E): Boolean
    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean
    public fun indexOf(element: @UnsafeVariance E): Int
    public fun lastIndexOf(element: @UnsafeVariance E): Int
}
```

Почему это работает? Аннотация `@UnsafeVariance` позволяет сказать компилятору, что мы уверены, что вызов этого метода с дженериком в позиции in ничего не испортит

Рекомендую вам после этой лекции порешать **Kotlin Coans** https://kotlinlang.org/docs/koans.html